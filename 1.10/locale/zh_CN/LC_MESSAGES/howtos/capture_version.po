# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2018, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:21+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../howtos/capture_version.rst:3
msgid "How to capture package version from SCM: git"
msgstr ""

#: ../../../howtos/capture_version.rst:5
msgid ""
"The ``Git()`` helper from tools, can be used to capture data from the Git "
"repo in which the *conanfile.py* recipe resides, and use it to define the "
"version of the Conan package."
msgstr ""

#: ../../../howtos/capture_version.rst:8
msgid ""
"from conans import ConanFile, tools\n"
"\n"
"def get_version():\n"
"    git = tools.Git()\n"
"    try:\n"
"        return \"%s_%s\" % (git.get_branch(), git.get_revision())\n"
"    except:\n"
"        return None\n"
"\n"
"class HelloConan(ConanFile):\n"
"    name = \"Hello\"\n"
"    version = get_version()\n"
"\n"
"    def build(self):\n"
"        ..."
msgstr ""

#: ../../../howtos/capture_version.rst:26
msgid ""
"In this example, the package created with :command:`conan create` will be "
"called ``Hello/branch_commit@user/channel``. Note that ``get_version()`` "
"returns ``None`` if it is not able to get the Git data. This is necessary "
"when the recipe is already in the Conan cache, and the Git repository may "
"not be there,. A value of ``None`` makes Conan get the version from the "
"metadata."
msgstr ""

#: ../../../howtos/capture_version.rst:33
msgid "How to capture package version from SCM: svn"
msgstr ""

#: ../../../howtos/capture_version.rst:35
msgid ""
"The ``SVN()`` helper from tools, can be used to capture data from the "
"subversion repo in which the *conanfile.py* recipe resides, and use it to "
"define the version of the Conan package."
msgstr ""

#: ../../../howtos/capture_version.rst:38
msgid ""
"from conans import ConanFile, tools\n"
"\n"
"def get_svn_version(version):\n"
"    try:\n"
"        scm = tools.SVN()\n"
"        revision = scm.get_revision()\n"
"        branch = scm.get_branch() # Delivers e.g trunk, tags/v1.0.0, "
"branches/my_branch\n"
"        branch = branch.replace(\"/\",\"_\")\n"
"        if scm.is_pristine():\n"
"            dirty = \"\"\n"
"        else:\n"
"            dirty = \".dirty\"\n"
"        return \"%s-%s+%s%s\" % (version, revision, branch, dirty) # e.g. "
"1.2.0-1234+trunk.dirty\n"
"    except Exception:\n"
"        return None\n"
"\n"
"class HelloLibrary(ConanFile):\n"
"    name = \"Hello\"\n"
"    version = get_svn_version(\"1.2.0\")\n"
"\n"
"    def build(self):\n"
"        ..."
msgstr ""

#: ../../../howtos/capture_version.rst:63
msgid ""
"In this example, the package created with :command:`conan create` will be "
"called ``Hello/generated_version@user/channel``. Note that "
"``get_svn_version()`` returns ``None`` if it is not able to get the "
"subversion data. This is necessary when the recipe is already in the Conan "
"cache, and the subversion repository may not be there. A value of ``None`` "
"makes Conan get the version from the metadata."
msgstr ""

#: ../../../howtos/capture_version.rst:70
msgid "How to capture package version from text or build files"
msgstr ""

#: ../../../howtos/capture_version.rst:72
msgid ""
"It is common that a library version number would be already encoded in a "
"text file, build scripts, etc. As an example, let's assume we have the "
"following library layout, and that we want to create a package from it:"
msgstr ""

#: ../../../howtos/capture_version.rst:75
msgid ""
"conanfile.py\n"
"CMakeLists.txt\n"
"src\n"
"   hello.cpp\n"
"   ..."
msgstr ""

#: ../../../howtos/capture_version.rst:84
msgid ""
"The *CMakeLists.txt* will have some variables to define the library version "
"number. For simplicity, let's also assume that it includes a line such as "
"the following:"
msgstr ""

#: ../../../howtos/capture_version.rst:87
msgid ""
"cmake_minimum_required(VERSION 2.8)\n"
"set(MY_LIBRARY_VERSION 1.2.3) # This is the version we want\n"
"add_library(hello src/hello.cpp)"
msgstr ""

#: ../../../howtos/capture_version.rst:94
msgid "Typically, our *conanfile.py* package recipe will include:"
msgstr ""

#: ../../../howtos/capture_version.rst:97
msgid ""
"class HelloConan(ConanFile):\n"
"    name = \"Hello\"\n"
"    version = \"1.2.3\""
msgstr ""

#: ../../../howtos/capture_version.rst:104
msgid ""
"This usually requires very little maintenance, and when the CMakeLists "
"version is bumped, so is the *conanfile.py* version. However, if you only "
"want to have to update the *CMakeLists.txt* version, you can extract the "
"version dynamically, using:"
msgstr ""

#: ../../../howtos/capture_version.rst:108
msgid ""
"from conans import ConanFile\n"
"from conans.tools import load\n"
"import re\n"
"\n"
"def get_version():\n"
"    try:\n"
"        content = load(\"CMakeLists.txt\")\n"
"        version = re.search(b\"set\\(MY_LIBRARY_VERSION (.*)\\)\", content)."
"group(1)\n"
"        return version.strip()\n"
"    except Exception as e:\n"
"        return None\n"
"\n"
"class HelloConan(ConanFile):\n"
"    name = \"Hello\"\n"
"    version = get_version()"
msgstr ""

#: ../../../howtos/capture_version.rst:127
msgid ""
"Even if the *CMakeLists.txt* file is not exported to the local cache, it "
"will still work, as the ``get_version()`` function returns None when it is "
"not found, and then takes the version number from the package metadata "
"(layout)."
msgstr ""
