# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2019, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.24\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:03+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../versioning/lockfiles.rst:4
msgid "Lockfiles"
msgstr ""

#: ../../../versioning/lockfiles.rst:8
msgid ""
"This is an **experimental** feature subject to breaking changes in future "
"releases."
msgstr ""

#: ../../../versioning/lockfiles.rst:10
msgid ""
"Lockfiles are files that store the information of a dependency graph, "
"including the exact versions, revisions, options, and configuration of that "
"dependency graph. As they depend on the configuration, and the dependency "
"graph can change with every different configuration, there will be one "
"lockfile for every configuration."
msgstr ""

#: ../../../versioning/lockfiles.rst:15
msgid ""
"Lockfiles are useful for achieving deterministic builds, even if the "
"dependency definitions in conanfile recipes are not fully deterministic, for "
"example when using version ranges or using package revisions."
msgstr ""

#: ../../../versioning/lockfiles.rst:19
msgid ""
"Let's say we have 3 package recipes ``pkgc``, ``pkgb``, and ``pkga``, that "
"define this dependency graph:"
msgstr ""

#: ../../../versioning/lockfiles.rst:23
msgid ""
"The first time, when a :command:`conan install .` is executed, the "
"requirement defined in ``pkgb`` is resolved to **pkga/1.0**, because that "
"was the latest at that time that satisfied the version range ``pkga/[*]``. "
"After such install, the user can build and run an application in the source "
"code of ``pkgc``. But some time later, another colleague tries to do exactly "
"the same, and suddenly it is pulling a newer version of ``pkga`` that was "
"recently published, getting different results (maybe even not working). "
"Builds with version ranges are not reproducible by default."
msgstr ""

#: ../../../versioning/lockfiles.rst:32
msgid "Using lockfiles"
msgstr ""

#: ../../../versioning/lockfiles.rst:33
msgid ""
"Lockfiles solve this problem creating a file that stores this information. "
"In the example above, the first :command:`conan install .` will generate a "
"*conan.lock* file that can be used later:"
msgstr ""

#: ../../../versioning/lockfiles.rst:37
msgid ""
"$ cd PkgC\n"
"$ conan install .  # generates conan.lock\n"
"# After PkgA/1.1 has been created\n"
"$ conan install . --lockfile # uses the existing conan.lock"
msgstr ""

#: ../../../versioning/lockfiles.rst:44
msgid ""
"The second time that :command:`conan install . --lockfile` is called, with "
"the lockfile argument it will load the previously generated *conan.lock* "
"file, that contains the information that ``pkga/1.0`` is used, and will "
"apply it again to the dependency resolution, resolving exactly the same "
"dependency graph:"
msgstr ""

#: ../../../versioning/lockfiles.rst:51
msgid ""
"The *conan.lock* file contains more information than the versions of the "
"dependencies, it contains:"
msgstr ""

#: ../../../versioning/lockfiles.rst:53
msgid ""
"The \"effective\" profile that has been used to compute this lockfile. The "
"effective profile is the combination of the profile files that could have "
"been passed in the command line, plus any other settings or options directly "
"defined in the command line."
msgstr ""

#: ../../../versioning/lockfiles.rst:56
msgid ""
"It encodes a graph, not just a list of versions, as different nodes in the "
"graph might be using different versions too."
msgstr ""

#: ../../../versioning/lockfiles.rst:58
msgid ""
"The options values at each package. As downstream consumers can define "
"options values, it is important that this information is also stored, so it "
"is also possible to build intermediate nodes of the graph leading to the "
"same result."
msgstr ""

#: ../../../versioning/lockfiles.rst:61
msgid "Another kind of requirements like python_requires."
msgstr ""

#: ../../../versioning/lockfiles.rst:63
msgid ""
"Again, it is important to remember that every different configuration will "
"generate a different graph, and then a different *conan.lock* as result. So "
"the example above would be more like the following if we wanted to work with "
"different configurations (e.g. Debug/Release):"
msgstr ""

#: ../../../versioning/lockfiles.rst:67
msgid ""
"$ cd PkgC\n"
"$ cd release\n"
"$ conan install .. # generates conan.lock (release) in this folder\n"
"$ cd ../debug\n"
"$ conan install .. -s build_type=Debug # generates conan.lock (debug)\n"
"# After PkgA/1.1 has been created\n"
"$ conan install .. --lockfile # uses the existing conan.lock (debug)\n"
"$ cd ../release\n"
"$ conan install .. --lockfile # uses the existing conan.lock (release)"
msgstr ""

#: ../../../versioning/lockfiles.rst:80
msgid "Commands"
msgstr ""

#: ../../../versioning/lockfiles.rst:82
msgid ""
"There are 2 main entry points for lockfile information in conan commands:"
msgstr ""

#: ../../../versioning/lockfiles.rst:84
msgid ":command:`--lockfile` argument in :command:`install/create/export/info`"
msgstr ""

#: ../../../versioning/lockfiles.rst:86
msgid ""
"If the command builds a package, it can modify its reference. Even if the "
"version is not changed, if something in the recipe changes, it will get a "
"new recipe revision RREV and if the package is built from sources again, it "
"might end with a new, different package revision PREV. Those changes will be "
"updated in the *conan.lock* lockfile, and the package will be marked as "
"\"modified\"."
msgstr ""

#: ../../../versioning/lockfiles.rst:91
msgid ":command:`conan graph` command"
msgstr ""

#: ../../../versioning/lockfiles.rst:93
msgid ""
"This command group contains several functions related to the management of "
"lockfiles:"
msgstr ""

#: ../../../versioning/lockfiles.rst:95
msgid ":command:`conan graph lock`"
msgstr ""

#: ../../../versioning/lockfiles.rst:97
msgid ""
"This command will generate a *conan.lock* file. It behaves like :command:"
"`conan install` command, (this will also generate a lockfile by default), "
"but without needing to actually install the binaries, so it will be faster. "
"In that regard, it is equal to :command:`conan info` that can also generate "
"a lockfile, but the problem with :command:`conan info -if=.` is that it does "
"not allow to specify a profile or settings."
msgstr ""

#: ../../../versioning/lockfiles.rst:103
msgid ":command:`conan graph clean-modified`"
msgstr ""

#: ../../../versioning/lockfiles.rst:105
msgid ""
"When a :command:`conan create` command that uses a lockfile builds a new "
"binary, its reference will change. This change, typically in the form of a "
"recipe revision and/or package revision is updated in the lockfile and the "
"node is marked as \"modified\". This :command:`clean-modified` removes these "
"\"modified\" flags from a lockfile. This operation is typically needed "
"before starting the build of a package in a locked graph, to know exactly "
"which nodes have been modified by this operation."
msgstr ""

#: ../../../versioning/lockfiles.rst:112
msgid ":command:`conan graph update-lock`"
msgstr ""

#: ../../../versioning/lockfiles.rst:114
msgid ""
"Update the current lockfile with the information of the second lockfile. "
"Only the nodes marked as \"modified\" will be updated. Trying to update to "
"the current lockfile one node that has already been \"modified\" will result "
"in an error."
msgstr ""

#: ../../../versioning/lockfiles.rst:118
msgid ":command:`conan graph build-order`"
msgstr ""

#: ../../../versioning/lockfiles.rst:120
msgid ""
"Takes a lockfile as an argument, and return a list of lists indicating the "
"order in which packages in the graph have to be built. It only returns those "
"packages that really need to be built, following the :command:`--build` "
"arguments and the ``package_id()`` rules."
msgstr ""

#: ../../../versioning/lockfiles.rst:124
msgid "For more information see :ref:`commands`"
msgstr ""

#: ../../../versioning/lockfiles.rst:127
msgid "How to use lockfiles in CI"
msgstr ""

#: ../../../versioning/lockfiles.rst:131
msgid ""
"The code used in this section, including a *build.py* script to reproduce "
"it, is in the examples repository: https://github.com/conan-io/examples"
msgstr ""

#: ../../../versioning/lockfiles.rst:None
msgid ""
"$ git clone https://github.com/conan-io/examples.git\n"
"$ cd features/lockfiles/ci\n"
"$ python build.py"
msgstr ""

#: ../../../versioning/lockfiles.rst:140
msgid ""
"One of the applications of lockfiles is to be able to propagate changes in "
"one package belonging to a dependency graph downstream its affected "
"consumers."
msgstr ""

#: ../../../versioning/lockfiles.rst:143
msgid ""
"Lets say that we have the following project in which packages ``pkga``, "
"``pkgb``, ``pkgc``, ``pkgz`` and ``app`` have already been created and only "
"one version of each, the version 0.1 exists. All packages are using version "
"ranges with a range like ``pkgz/[>0.0]``, so basically they will resolve to "
"any new version of their dependencies that it is published."
msgstr ""

#: ../../../versioning/lockfiles.rst:148
msgid ""
"Also, the ``full_version_mode`` will be defined for dependencies. This means "
"that if the version number of one package dependencies change, then it will "
"require a new binary. This assumption is reasonable, as PkgA, PkgZ are "
"header only libraries and PkgB and PkgC are static libraries that inline "
"functionality defined in PkgA and PkgZ. No matter what the changes in PkgA "
"and PkgZ are in new versions, it will be necessary to build new binaries for "
"the downstream consumers."
msgstr ""

#: ../../../versioning/lockfiles.rst:157
msgid "$ conan config set general.default_package_id_mode=full_version_mode"
msgstr ""

#: ../../../versioning/lockfiles.rst:158
msgid ""
"Now, some developer does some changes to PkgA, and do a pull request to the "
"develop branch, and we want our CI to build the new binaries for the "
"dependants packages, down to the final application App, to make sure that "
"every works as expected."
msgstr ""

#: ../../../versioning/lockfiles.rst:162
msgid ""
"The process starts generating a *conan.lock* lockfile in the *release* "
"subfolder:"
msgstr ""

#: ../../../versioning/lockfiles.rst:164
msgid "$ conan graph lock app/0.1@user/testing --lockfile=release"
msgstr ""

#: ../../../versioning/lockfiles.rst:168
msgid ""
"This lockfile will contain the resolved dependencies in the graph, as we "
"only have one version 0.1 for all the packages, all of them will be locked "
"to that 0.1 version."
msgstr ""

#: ../../../versioning/lockfiles.rst:175
msgid ""
"Once the lockfile has been generated, it doesn't matter if new, unrelated "
"versions of other packages, like **pkgz/0.2** is created with ``cd pkgz && "
"conan create . pkgz/0.2@user/testing``"
msgstr ""

#: ../../../versioning/lockfiles.rst:178
msgid ""
"Now we can safely create the new version of **pkga/0.2**, that will resolve "
"to use **pkgz/0.1** instead of the latest 0.2, if we use the lockfile:"
msgstr ""

#: ../../../versioning/lockfiles.rst:181
msgid ""
"cd pkga && conan create . pkga/0.2@user/testing --lockfile=../release\n"
"# lockfile in release/conan.lock is modified to contain pkga/0.2"
msgstr ""

#: ../../../versioning/lockfiles.rst:186
msgid ""
"Note that the lockfile is modified, to contain the new **pkga/0.2** version."
msgstr ""

#: ../../../versioning/lockfiles.rst:188
msgid ""
"The next step is to know which dependents need to be built because they are "
"affected by the new **pkga/0.2** version:"
msgstr ""

#: ../../../versioning/lockfiles.rst:191
msgid ""
"$ conan graph build-order ./release --json=bo.json --build=missing\n"
"[[PkgC, PkgD], [App]]  # simplified format"
msgstr ""

#: ../../../versioning/lockfiles.rst:196
msgid ""
"This command will return a list of lists, in order, of those packages to be "
"built. It will be stored in a *bo.json* json file too. Note that the ``--"
"build=missing`` follows the same rules as :command:`create` and :command:"
"`install` commands. The result of evaluating the graph with the **pkga/0.2** "
"version, due to the ``full_version_mode`` policy is that new binaries for "
"PkgB, PkgC and App are necessary, and they do not exist yet. If we don't "
"provide the ``--build=missing`` it will return an empty list (but it will "
"fail later, because binary packages are not available)."
msgstr ""

#: ../../../versioning/lockfiles.rst:203
msgid "We can now proceed iteratively with the following procedure:"
msgstr ""

#: ../../../versioning/lockfiles.rst:206
msgid ""
"pop the first element of the first sublist of the build order result, get "
"its ``ref`` reference"
msgstr ""

#: ../../../versioning/lockfiles.rst:None
msgid ""
"# python\n"
"_, ref = build_order[0][0]\n"
"ref = ref.split(\"#\", 1)[0]"
msgstr ""

#: ../../../versioning/lockfiles.rst:214
msgid ""
"allocate some resource, like a CI build server, or create a temporary folder."
msgstr ""

#: ../../../versioning/lockfiles.rst:None
msgid "$ mkdir build_server_folder && mkdir build_server_folder/release"
msgstr ""

#: ../../../versioning/lockfiles.rst:220
msgid "copy the lockfile to that resource (and move to it)"
msgstr ""

#: ../../../versioning/lockfiles.rst:None
msgid ""
"$ cp release/conan.lock build_server_folder/release\n"
"$ cd build_server_folder"
msgstr ""

#: ../../../versioning/lockfiles.rst:227
msgid "build the package"
msgstr ""

#: ../../../versioning/lockfiles.rst:None
msgid "$ conan install <ref> --build=<ref> --lockfile=release"
msgstr ""

#: ../../../versioning/lockfiles.rst:233
msgid "go back to the parent, update the lockfile with the changes"
msgstr ""

#: ../../../versioning/lockfiles.rst:None
msgid ""
"$ cd ..\n"
"$ conan graph update-lock release build_server_folder/release\n"
"$ rm -rf build_server_folder"
msgstr ""

#: ../../../versioning/lockfiles.rst:241
msgid "compute again the build-order of packages, if not empty, goto 1"
msgstr ""

#: ../../../versioning/lockfiles.rst:243
msgid "$ conan graph build-order ./release --json=bo.json --build=missing"
msgstr ""

#: ../../../versioning/lockfiles.rst:247
msgid "clean \"modified\" nodes from the lockfile"
msgstr ""

#: ../../../versioning/lockfiles.rst:None
msgid "$ conan graph clean-modified release/"
msgstr ""

#: ../../../versioning/lockfiles.rst:254
msgid ""
"Note that this is a suboptimal approach, in order to explain the "
"functionality, which is more easy to follow if it is sequential. In reality, "
"the CI can take the first sublist output of :command:`conan graph build-"
"order` and fire all its packages in parallel, because they are guaranteed to "
"be independent. Then, as soon as they start finishing and build servers "
"become available, the :command:`conan graph build-order` can be reevaluated, "
"and new builds can be launched accordingly, just taking care of not re-"
"launching the same build again. Note that the result of build-order contains "
"a unique UUID, which is the identifier of the node in the graph, which could "
"be useful to dissambiguate."
msgstr ""

#: ../../../versioning/lockfiles.rst:265
msgid ""
"With this later approach, a deterministic build with optimal Continuous "
"Integration process with optimal utilization of resources and minimizing "
"unnecessary rebuilds is achieved."
msgstr ""

#: ../../../versioning/lockfiles.rst:268
msgid ""
"Note that this example has been using incremental versions and version "
"ranges. With package revisions it is also possible to achieve the same flow "
"without bumping the versions and using fixed version dependencies:"
msgstr ""

#: ../../../versioning/lockfiles.rst:271
msgid ""
"It will not be necessary to change the recipes or even to inject the values "
"in CI. Every change in a recipe will produce a new different recipe revision."
msgstr ""

#: ../../../versioning/lockfiles.rst:273
msgid "Revisions are also locked in lockfiles."
msgstr ""

#: ../../../versioning/lockfiles.rst:274
msgid ""
"As revisions are resolved by default to latest, and the conan cache can only "
"hold one revision, it might be necessary to pass ``--update`` argument so "
"the correct revision is updated in the cache."
msgstr ""

#: ../../../versioning/lockfiles.rst:276
msgid ""
"It is necessary to define the ``recipe_revision_mode`` or the "
"``package_revision_mode`` if we want to guarantee that the binaries "
"correctly model the dependencies changes."
msgstr ""

#: ../../../versioning/lockfiles.rst:278
msgid ""
"For implementing this flow, it might be necessary to share the different "
"``conan.lock`` lockfiles among different machines, to pass them to build "
"servers. A git repo could be used, but also an Artifactory generic "
"repository could be very convenient for this purpose."
msgstr ""

#: ../../../versioning/lockfiles.rst:282
msgid ""
"There is a **very experimental, temporary** configuration (``general."
"relax_lockfile``), that allows to expand dependency graphs with packages "
"that are not in the lockfile. This scenario happens for example when a "
"``test_package/conanfile.py`` contains other requirements. If the lockfile "
"was built from another downstream consumer, the ``test_package`` and its "
"requirements will not be contained in the lockfile. But we might still want "
"to do a ``conan create`` for that node of the graph. Putting the ``general."
"relax_lockfile=1`` will allow this case. This is a temporary thing "
"introduced at 1.23, will be removed in future versions (while probably "
"leaving the behavior in some of its forms)"
msgstr ""
