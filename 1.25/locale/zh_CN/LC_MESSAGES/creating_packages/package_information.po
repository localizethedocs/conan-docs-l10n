# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2019, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.25\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:18+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../creating_packages/package_information.rst:4
msgid "Define the package information"
msgstr ""

#: ../../../creating_packages/package_information.rst:6
msgid ""
"When creating a recipe to package a library, it is important to define the "
"information about the package so consumers can get the information "
"correctly. Conan achieves this by decoupling the information of the package "
"from the format needed using :ref:`generators_reference`, that translate the "
"generic information into the appropriate format file."
msgstr ""

#: ../../../creating_packages/package_information.rst:10
msgid ""
"This generic information is defined inside the recipe, using the :ref:"
"`method_package_info` method. There you can declare package information like "
"the location of the header files, library names, defines, flags..."
msgstr ""

#: ../../../creating_packages/package_information.rst:13
msgid ""
"from conans import ConanFile\n"
"\n"
"class MyConan(ConanFile):\n"
"    name = \"cool_library\"\n"
"    ...\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.includedirs = [\"include/cool\"]\n"
"        self.cpp_info.libs = [\"libcool\"]\n"
"        self.cpp_info.defines= [\"DEFINE_COOL=1\"]"
msgstr ""

#: ../../../creating_packages/package_information.rst:26
msgid ""
"The package information is done using the attributes of the :ref:"
"`cpp_info_attributes_reference` object. This information will be aggregated "
"by Conan and exposed via ``self.deps_cpp_info`` to consumers and generators."
msgstr ""

#: ../../../creating_packages/package_information.rst:31
msgid ""
"This information is important as it describes the package contents in a "
"generic way with a pretty straightforward syntax that can later be "
"translated to a suitable format. The advantage of having this information "
"here, is that the package could be consumed from a different build system "
"that the one used to compile the library. For example, a library that builds "
"using Autotools can be consumed later in CMake with this information using "
"any of the CMake generators."
msgstr ""

#: ../../../creating_packages/package_information.rst:38
msgid "Read :ref:`method_package_info` to learn more about this method."
msgstr ""

#: ../../../creating_packages/package_information.rst:43
msgid "Using Components"
msgstr ""

#: ../../../creating_packages/package_information.rst:45
msgid ""
"If your package contains more than one library or you want to define "
"separated components so consumers can have more granular information, you "
"can use components in your :ref:`method_package_info` method."
msgstr ""

#: ../../../creating_packages/package_information.rst:50
msgid ""
"This is a **experimental** feature subject to breaking changes in future "
"releases."
msgstr ""

#: ../../../creating_packages/package_information.rst:52
msgid ""
"When you are creating a Conan package, it is recommended to have only one "
"library (*.lib*, *.a*, *.so*, *.dll*...) per package. However, especially "
"with third-party projects like Boost, Poco or OpenSSL, they would contain "
"several libraries inside."
msgstr ""

#: ../../../creating_packages/package_information.rst:55
msgid ""
"Usually those libraries inside the same package depend on each other and "
"modelling the relationship among them is required."
msgstr ""

#: ../../../creating_packages/package_information.rst:57
msgid ""
"With **components**, you can model libraries and executables inside the same "
"package and how one depends on the other. Each library or executable will be "
"one component inside ``cpp_info`` like this:"
msgstr ""

#: ../../../creating_packages/package_information.rst:60
msgid ""
"def package_info(self):\n"
"    self.cpp_info.name = \"OpenSSL\"\n"
"    self.cpp_info.components[\"crypto\"].names[\"cmake_find_package\"] = "
"\"Crypto\"\n"
"    self.cpp_info.components[\"crypto\"].libs = [\"libcrypto\"]\n"
"    self.cpp_info.components[\"crypto\"].defines = [\"DEFINE_CRYPTO=1\"]\n"
"    self.cpp_info.components[\"ssl\"].names[\"cmake\"] = \"SSL\"\n"
"    self.cpp_info.components[\"ssl\"].includedirs = [\"include/"
"headers_ssl\"]\n"
"    self.cpp_info.components[\"ssl\"].libs = [\"libssl\"]\n"
"    self.cpp_info.components[\"ssl\"].requires = [\"crypto\"]"
msgstr ""

#: ../../../creating_packages/package_information.rst:72
msgid ""
"You can define dependencies among different components using the "
"``requires`` attribute and the name of the component. The dependency graph "
"for components will be calculated and values will be aggregated in the "
"correct order for each field."
msgstr ""

#: ../../../creating_packages/package_information.rst:75
msgid ""
"def package_info(self):\n"
"    self.cpp_info.components[\"LibA\"].libs = [\"liba\"]      # Name of the "
"library for the 'LibA' component\n"
"    self.cpp_info.components[\"LibA\"].requires = [\"LibB\"]  # Requires "
"point to the name of the component\n"
"\n"
"    self.cpp_info.components[\"LibB\"].libs = [\"libb\"]\n"
"\n"
"    self.cpp_info.components[\"LibC\"].libs = [\"libc\"]\n"
"    self.cpp_info.components[\"LibC\"].requires = [\"LibA\"]\n"
"\n"
"    self.cpp_info.components[\"LibD\"].libs = [\"libD\"]\n"
"    self.cpp_info.components[\"LibD\"].requires = [\"LibA\"]\n"
"\n"
"    self.cpp_info.components[\"LibE\"].libs = [\"libe\"]\n"
"    self.cpp_info.components[\"LibE\"].requires = [\"LibB\"]\n"
"\n"
"    self.cpp_info.components[\"LibF\"].libs = [\"libf\"]\n"
"    self.cpp_info.components[\"LibF\"].requires = [\"LibD\", \"LibE\"]"
msgstr ""

#: ../../../creating_packages/package_information.rst:95
msgid ""
"For consumers and generators, the order of the libraries from this "
"components graph will be:"
msgstr ""

#: ../../../creating_packages/package_information.rst:97
msgid ""
"self.deps_cpp_info.libs == [\"libf\", \"libe\", \"libd\", \"libc\", "
"\"liba\", \"libb\"]"
msgstr ""

#: ../../../creating_packages/package_information.rst:101
msgid "Declaration of requires from other packages is also allowed:"
msgstr ""

#: ../../../creating_packages/package_information.rst:103
msgid ""
"class MyConan(ConanFile):\n"
"    ...\n"
"    requires = \"zlib/1.2.11\", \"openssl/1.1.1g\"\n"
"\n"
"def package_info(self):\n"
"    self.cpp_info.components[\"comp1\"].requires = [\"zlib::"
"zlib\"]             # Depends on all components in zlib package\n"
"    self.cpp_info.components[\"comp2\"].requires = [\"comp1\", \"openssl::"
"ssl\"]  # Depends on ssl component in openssl package"
msgstr ""

#: ../../../creating_packages/package_information.rst:113
msgid ""
"By default, components **won't link against any other package required by "
"the recipe**. The requires list has to be **populated explicitly** with the "
"list of components from other packages to use: it can be the full "
"requirement (``zlib::zlib``) or a single component (``openssl::ssl``)."
msgstr ""

#: ../../../creating_packages/package_information.rst:119
msgid ""
"Components information is still not available from the generators' side. We "
"are planning to complete this feature in next releases."
msgstr ""

#: ../../../creating_packages/package_information.rst:121
msgid ""
"Currently, the information of components is not lost but aggregated to the "
"*global* scope and the usage of components should be transparent right now."
msgstr ""

#: ../../../creating_packages/package_information.rst:126
msgid ""
"Read :ref:`components reference <cpp_info_attributes_reference>` for more "
"information."
msgstr ""
