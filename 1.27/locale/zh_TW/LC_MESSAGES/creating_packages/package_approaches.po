# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2019, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.27\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:12+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../creating_packages/package_approaches.rst:2
msgid "Packaging Approaches"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:4
msgid ""
"Package recipes have three methods for controlling the package's binary "
"compatibility and for implementing different packaging approaches: :ref:"
"`method_package_id`, :ref:`method_build_id` and :ref:`method_package_info`."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:7
msgid ""
"These methods let package creators select the method most suitable for each "
"library."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:10
msgid "1 config (1 build) -> 1 package"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:12
msgid ""
"A typical approach is to have one configuration for each package containing "
"the artifacts. Using this approach, for example, the debug pre-compiled "
"libraries will be in a different package than the release pre-compiled "
"libraries."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:16
msgid ""
"So if there is a package recipe that builds a “hello” library, there will be "
"one package containing the release version of the \"hello.lib\" library and "
"a different package containing a debug version of that library (in the "
"figure denoted as \"hello_d.lib\", to make it clear, it is not necessary to "
"use different names)."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:26
msgid ""
"Using this approach, the ``package_info()`` method, allows you to set the "
"appropriate values for consumers, letting them know about the package "
"library names, necessary definitions and compile flags."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:29
msgid ""
"class HelloConan(ConanFile):\n"
"\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.libs = [\"mylib\"]"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:38
msgid ""
"It is very important to note that it is declaring the ``build_type`` as a "
"setting. This means that a different package will be generated for each "
"different value of such setting."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:41
msgid ""
"The values declared by the packages (the *include*, *lib* and *bin* "
"subfolders are already defined by default, so they define the include and "
"library path to the package) are translated to variables of the respective "
"build system by the used generators. That is, running the ``cmake`` "
"generator will translate the above definition in the *conanbuildinfo.cmake* "
"to something like:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:46
msgid ""
"set(CONAN_LIBS_MYPKG mylib)\n"
"# ...\n"
"set(CONAN_LIBS mylib ${CONAN_LIBS})"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:52
msgid ""
"Those variables, will be used in the ``conan_basic_setup()`` macro to "
"actually set the relevant cmake variables."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:55
msgid ""
"If the developer wants to switch configuration of the dependencies, they "
"will usually switch with:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:57
msgid ""
"$ conan install -s build_type=Release ...\n"
"# when need to debug\n"
"$ conan install -s build_type=Debug ..."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:63
msgid ""
"These switches will be fast, since all the dependencies are already cached "
"locally."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:65
msgid ""
"This process offers a number of advantages: - It is quite easy to implement "
"and maintain. - The packages are of minimal size, so disk space and "
"transfers are faster, and builds from sources are also kept to the necessary "
"minimum. - The decoupling of configurations might help with isolating issues "
"related to mixing different types of artifacts, and also protecting valuable "
"information from deploy and distribution mistakes. For example, debug "
"artifacts might contain symbols or source code, which could help or directly "
"provide means for reverse engineering. So distributing debug artifacts by "
"mistake could be a very risky issue."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:75
msgid "Read more about this in :ref:`method_package_info`."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:80
msgid "N configs -> 1 package"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:82
msgid ""
"You may want to package both debug and release artifacts in the same "
"package, so it can be consumed from IDEs like Visual Studio. This will "
"change the debug/release configuration from the IDE, without having to "
"specify it in the command line. This type of package can contain different "
"artifacts for different configurations and can be used to include both the "
"release and debug version of a library in the same package."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:94
msgid ""
"A complete working example of the following code can be found in the "
"examples repo: https://github.com/conan-io/examples"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:None
msgid ""
"$ git clone https://github.com/conan-io/examples.git\n"
"$ cd features/multi_config\n"
"$ conan create . user/channel"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:102
msgid "Creating a multi-configuration debug/release package is simple"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:104
msgid ""
"The first step will be to remove ``build_type`` from the settings. It will "
"not be an input setting and the generated package will always contain both "
"debug and release artifacts."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:107
msgid ""
"The Visual Studio runtime is different for debug and release (``MDd`` or "
"``MD``) and is set using the default runtime (``MD``/``MDd``). If this meets "
"your needs, we recommend removing the ``compiler.runtime`` subsetting in the "
"``configure()`` method:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:110
msgid ""
"class HelloConan(ConanFile):\n"
"    # build_type has been omitted. It is not an input setting.\n"
"    settings = \"os\", \"compiler\", \"arch\"\n"
"    generators = \"cmake\"\n"
"\n"
"    # Remove runtime and use always default (MD/MDd)\n"
"    def configure(self):\n"
"        if self.settings.compiler == \"Visual Studio\":\n"
"            del self.settings.compiler.runtime\n"
"\n"
"    def build(self):\n"
"        cmake_release = CMake(self, build_type=\"Debug\")\n"
"        cmake_release.configure()\n"
"        cmake_release.build()\n"
"\n"
"        cmake_debug = CMake(self, build_type=\"Release\")\n"
"        cmake_debug.configure()\n"
"        cmake_debug.build()"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:131
msgid ""
"In this example, the binaries will be differentiated with a suffix in the "
"CMake syntax, so we have to add this information to the data provided to the "
"consumers in the `package_info` function:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:133
msgid "set_target_properties(mylibrary PROPERTIES DEBUG_POSTFIX _d)"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:137
msgid "Such a package can define its information for consumers as:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:139
msgid ""
"def package_info(self):\n"
"    self.cpp_info.release.libs = [\"mylibrary\"]\n"
"    self.cpp_info.debug.libs = [\"mylibrary_d\"]"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:145
msgid "This will translate to the CMake variables:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:147
msgid ""
"set(CONAN_LIBS_MYPKG_DEBUG mylibrary_d)\n"
"set(CONAN_LIBS_MYPKG_RELEASE mylibrary)\n"
"# ...\n"
"set(CONAN_LIBS_DEBUG mylibrary_d ${CONAN_LIBS_DEBUG})\n"
"set(CONAN_LIBS_RELEASE mylibrary ${CONAN_LIBS_RELEASE})"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:155
msgid ""
"And these variables will be correctly applied to each configuration by "
"``conan_basic_setup()`` helper."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:157
msgid ""
"In this case you can still use the general and not config-specific "
"variables. For example, the include directory when set by default to "
"*include* remains the same for both debug and release. Those general "
"variables will be applied to all configurations."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:162
msgid ""
"The above code assumes that the package will always use the default Visual "
"Studio runtime (``MD``/``MDd``). To keep the package configurable for "
"supporting static(MT)/dynamic(MD) linking with the VS runtime library, you "
"can do the following:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:166
msgid ""
"Keep the ``compiler.runtime`` setting, e.g. do not implement the "
"``configure()`` method removing it."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:167
msgid ""
"Don't let the CMake helper define the ``CONAN_LINK_RUNTIME`` variable to "
"define the runtime and define ``CONAN_LINK_RUNTIME_MULTI`` instead."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:169
msgid ""
"In *CMakeLists.txt*, use the ``CONAN_LINK_RUNTIME_MULTI`` variable to "
"correctly setup up the runtime for debug and release flags."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:170
msgid ""
"Write a separate ``package_id()`` methods for MD/MDd and for MT/MTd defining "
"the packages to be built."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:172
msgid ""
"All these steps are already coded in the repo https://github.com/conan-io/"
"examples/tree/master/features/multi_config and commented out as "
"**\"Alternative 2\"**."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:178
msgid ""
"The automatic conversion of multi-config variables to generators is "
"currently implemented in the ``cmake``, ``visual_studio``, ``txt``, and "
"``cmake_find_package`` generators (and also for their corresponding "
"``_multi`` implementations). If you want to have support for them in another "
"build system, please open a GitHub issue."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:184
msgid "N configs (1 build) -> N packages"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:186
msgid ""
"It’s possible that an existing build script is simultaneously building "
"binaries for different configurations, like debug/release, or different "
"architectures (32/64bits), or library types (shared/static). If such a build "
"script is used in the previous \"Single configuration packages\" approach, "
"it will definitely work without problems. However, we'll be wasting precious "
"build time, as we'll be rebuilding the project for each package, then "
"extracting the relevant artifacts for the relevant configuration, while "
"ignoring the others."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:193
msgid ""
"It is more efficient to build the logic, whereby the same build can be "
"reused to create different packages:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:200
msgid ""
"This can be done by defining a ``build_id()`` method in the package recipe "
"that will specify the logic."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:203
msgid ""
"settings = \"os\", \"compiler\", \"arch\", \"build_type\"\n"
"\n"
"def build_id(self):\n"
"    self.info_build.settings.build_type = \"Any\"\n"
"\n"
"def package(self):\n"
"    if self.settings.build_type == \"Debug\":\n"
"        #package debug artifacts\n"
"    else:\n"
"        # package release"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:216
msgid ""
"Note that the ``build_id()`` method uses the ``self.info_build`` object to "
"alter the build hash. If the method doesn't change it, the hash will match "
"the package folder one. By setting ``build_type=\"Any\"``, we are forcing "
"that for both the Debug and Release values of ``build_type``, the hash will "
"be the same (the particular string is mostly irrelevant, as long as it is "
"the same for both configurations). Note that the build hash ``sha3`` will be "
"different of both ``sha1`` and ``sha2`` package identifiers."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:223
msgid ""
"This does not imply that there will be strictly one build folder. There will "
"be a build folder for every configuration (architecture, compiler version, "
"etc). So if we just have Debug/Release build types, and we’re producing N "
"packages for N different configurations, we’ll have N/2 build folders, "
"saving half of the build time."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:228
msgid "Read more about this in :ref:`method_build_id`."
msgstr ""
