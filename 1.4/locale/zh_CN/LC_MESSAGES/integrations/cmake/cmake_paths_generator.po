# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2018, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../integrations/cmake/cmake_paths_generator.rst:4
msgid "``cmake_paths`` generator"
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:6
msgid ""
"This generator is especially useful if you are using ``CMake`` based only on "
"the ``find_package`` feature to locate the dependencies."
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:9
msgid ""
"The ``cmake_paths`` generator creates a file named ``conan_paths.cmake`` "
"declaring:"
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:11
msgid ""
"``CMAKE_MODULE_PATH`` with the folders of the required packages, to allow "
"CMake to locate the included cmake scripts and ``FindXXX.cmake`` files. The "
"folder containing the ``conan_paths.cmake`` (`self.install_folder` when used "
"in a recipe) is also included, so any custom file will be located too. "
"Check :ref:`cmake_find_package <cmake_find_package_generator>` generator."
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:14
msgid ""
"``CMAKE_PREFIX_PATH`` used by ``FIND_LIBRARY()`` to locate library files (."
"a, .lib, .so, .dll) in your packages."
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:17
msgid "conanfile.txt"
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:17
msgid ""
"[requires]\n"
"zlib/1.2.11@conan/stable\n"
"...\n"
"\n"
"[generators]\n"
"cmake_paths"
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:28
#: ../../../integrations/cmake/cmake_paths_generator.rst:85
msgid "CMakeList.txt"
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:28
msgid ""
"cmake_minimum_required(VERSION 3.0)\n"
"project(helloworld)\n"
"add_executable(helloworld hello.c)\n"
"find_package(Zlib)\n"
"if(ZLIB_FOUND)\n"
"   include_directories(${ZLIB_INCLUDE_DIRS})\n"
"   target_link_libraries (helloworld ${ZLIB_LIBRARIES})\n"
"endif()"
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:42
msgid ""
"In the example above, the ``zlib/1.2.11@conan/stable`` package is not "
"packaging a custom ``FindZLIB.cmake`` file, but the ``FindZLIB.cmake`` "
"included in the CMake installation directory (`/Modules`) will locate the "
"zlib library from the Conan package because of the ``CMAKE_PREFIX_PATH`` "
"used by the ``FIND_LIBRARY()``."
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:46
msgid ""
"If the ``zlib/1.2.11@conan/stable`` would had included a custom ``FindZLIB."
"cmake`` in the package root folder or any declared :ref:`self.cpp_info."
"builddirs <cpp_info_attributes_reference>`, it would have been located "
"because of the ``CMAKE_MODULE_PATH`` variable."
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:50
msgid ""
"You can use the generated ``conan_paths.cmake`` file as a **cmake "
"toolchain** or including it in a **CMakeLists.txt** of even including it in "
"another toolchain:"
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:54
msgid "Included as a toolchain"
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:56
msgid ""
"Without modifying your **CMakeLists.txt** file you can use the ``conan_paths."
"cmake`` as a toolchain:"
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:58
msgid ""
" $ mkdir build && cd build\n"
" $ conan install ..\n"
" $ cmake .. -DCMAKE_TOOLCHAIN_FILE=conan_paths.cmake -G \"Unix Makefiles\" -"
"DCMAKE_BUILD_TYPE=Release\n"
" $ cmake --build ."
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:68
msgid "Included using the CMAKE_PROJECT_<PROJECT-NAME>_INCLUDE"
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:70
msgid ""
"With ``CMAKE_PROJECT_<PROJECT-NAME>_INCLUDE`` you can specify a file to be "
"included by the project() command. If you already have a toolchain file you "
"can use this variable to include the ``conan_paths.cmake`` and insert your "
"toolchain with the ``CMAKE_TOOLCHAIN_FILE``."
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:74
msgid ""
"$ mkdir build && cd build\n"
"$ conan install ..\n"
"$ cmake .. -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release -"
"DCMAKE_PROJECT_helloworld_INCLUDE=build/conan_paths.cmake\n"
"$ cmake --build ."
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:83
msgid "Included in your CMakeLists.txt"
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:85
msgid ""
"cmake_minimum_required(VERSION 3.0)\n"
"project(helloworld)\n"
"include(${CMAKE_BINARY_DIR}/conan_paths.cmake)\n"
"add_executable(helloworld hello.c)\n"
"find_package(Zlib)\n"
"if(ZLIB_FOUND)\n"
"   include_directories(${ZLIB_INCLUDE_DIRS})\n"
"   target_link_libraries (helloworld ${ZLIB_LIBRARIES})\n"
"endif()"
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:100
msgid ""
"$ mkdir build && cd build\n"
"$ conan install ..\n"
"$ cmake .. -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release\n"
"$ cmake --build ."
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:108
msgid ""
"Check the section :ref:`Reference/Generators/cmake_paths "
"<cmake_paths_generator_reference>` to read more about this generator."
msgstr ""

#: ../../../integrations/cmake/cmake_paths_generator.rst:113
msgid ""
"The ``CMAKE_MODULE_PATH`` and ``CMAKE_PREFIX_PATH`` contain the paths to the "
"``builddirs`` of every required package. By default, the root package folder "
"is the only declared ``builddirs`` directory. Check the :ref:`Reference/"
"conanfile.py/attributes <cpp_info_attributes_reference>`."
msgstr ""
