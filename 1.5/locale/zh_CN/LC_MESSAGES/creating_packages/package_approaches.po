# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2018, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.5\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../creating_packages/package_approaches.rst:2
msgid "Packaging approaches"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:4
msgid ""
"Package recipes have three methods to control the package's binary "
"compatibility and to implement different packaging approaches: :ref:"
"`method_package_id`, :ref:`method_build_id` and :ref:`method_package_info`."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:7
msgid ""
"The above methods let package creators follow different package approaches "
"to choose the best fit for each library."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:11
msgid "1 config (1 build) -> 1 package"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:13
msgid ""
"A typical approach is to have one configuration for each package containing "
"the artifacts. In this approach, for example, the debug pre-compiled "
"libraries will be in a different package than the release pre-compiled "
"libraries."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:17
msgid ""
"So if there is a package recipe that builds a “hello” library, there will be "
"one package containing the release version of the \"hello.lib\" library and "
"a different package containing a debug version of that library (in the "
"figure denoted as \"hello_d.lib\", to make it clear, it is not necessary to "
"use different names)."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:27
msgid ""
"In this approach, the ``package_info()`` method can just set the appropriate "
"values for consumers, to let them know about the package library names, and "
"necessary definitions and compile flags."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:30
msgid ""
"class HelloConan(ConanFile):\n"
"\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.libs = [\"mylib\"]"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:39
msgid ""
"It is very important to note that it is declaring the ``build_type`` as a "
"setting. This means that a different package will be generated for each "
"different value of such setting."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:42
msgid ""
"The values that packages declare here (the *include*, *lib* and *bin* "
"subfolders are already defined by default, so they define the include and "
"library path to the package) are translated to variables of the respective "
"build system by the used generators. That is, if using the ``cmake`` "
"generator, such above definition will be translated in *conanbuildinfo."
"cmake* to something like:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:47
msgid ""
"set(CONAN_LIBS_MYPKG mylib)\n"
"# ...\n"
"set(CONAN_LIBS mylib ${CONAN_LIBS})"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:53
msgid ""
"Those variables, will be used in the ``conan_basic_setup()`` macro to "
"actually set cmake relevant variables."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:56
msgid ""
"If the developer wants to switch configuration of the dependencies, he will "
"usually switch with:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:58
msgid ""
"$ conan install -s build_type=Release ...\n"
"# when need to debug\n"
"$ conan install -s build_type=Debug ..."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:64
msgid ""
"These switches will be fast, since all the dependencies are already cached "
"locally."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:66
msgid ""
"This process has some advantages: it is quite easy to implement and "
"maintain. The packages are of minimal size, so disk space and transfers are "
"faster, and builds from sources are also kept to the necessary minimum. The "
"decoupling of configurations might help with isolating issues related to "
"mixing different types of artifacts, and also protecting valuable "
"information from deploy and distribution mistakes. For example, debug "
"artifacts might contain symbols or source code, which could help or directly "
"provide means for reverse engineering. So distributing debug artifacts by "
"mistake could be a very risky issue."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:74
msgid "Read more about this in :ref:`method_package_info`."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:77
msgid "N configs -> 1 package"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:79
msgid ""
"It is possible that someone wants to package both debug and release "
"artifacts in the same package, so it can be consumed from IDEs like Visual "
"Studio changing debug/release configuration from the IDE, and not having to "
"specify it in the command line. This type of package will include different "
"artifacts for different configurations, like both the release and debug "
"version of the \"hello\" library, in the same package."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:92
msgid ""
"A complete working example of the following code can be found in a github "
"repo. You should be able to run:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:95
msgid ""
"$ git clone https://github.com/memsharded/hello_multi_config\n"
"$ cd hello_multi_config\n"
"$ conan create . user/channel -s build_type=Release\n"
"$ conan create . user/channel -s build_type=Debug --build=missing"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:102
msgid ""
"Creating a multi-configuration Debug/Release package is not difficult, see "
"the following example using CMake."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:105
msgid ""
"The first step is to remove ``build_type`` from the settings. It will not be "
"an input setting, the generated package will always be the same, containing "
"both Debug and Release artifacts. The Visual Studio runtime is different for "
"debug and release (``MDd`` or ``MD``), so if we are fine with the default "
"runtime (MD/MDd), it is also good to remove the ``runtime`` subsetting in "
"the ``configure()`` method:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:112
msgid ""
"class Pkg(ConanFile):\n"
"    # build_type has been ommitted. It is not an input setting.\n"
"    settings = \"os\", \"compiler\", \"arch\"\n"
"\n"
"    def configure(self):\n"
"        # it is also necessary to remove the VS runtime\n"
"        if self.settings.compiler == \"Visual Studio\":\n"
"            del self.settings.compiler.runtime\n"
"\n"
"    def build(self):\n"
"        cmake = CMake(self)\n"
"        if cmake.is_multi_configuration:\n"
"            cmmd = 'cmake \"%s\" %s' % (self.source_folder, cmake."
"command_line)\n"
"            self.run(cmmd)\n"
"            self.run(\"cmake --build . --config Debug\")\n"
"            self.run(\"cmake --build . --config Release\")\n"
"        else:\n"
"            for config in (\"Debug\", \"Release\"):\n"
"                self.output.info(\"Building %s\" % config)\n"
"                self.run('cmake \"%s\" %s -DCMAKE_BUILD_TYPE=%s'\n"
"                        % (self.source_folder, cmake.command_line, config))\n"
"                self.run(\"cmake --build .\")\n"
"                shutil.rmtree(\"CMakeFiles\")\n"
"                os.remove(\"CMakeCache.txt\")"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:139
msgid ""
"In this case, we are assuming that the binaries will be differentiated with "
"a suffix, in cmake syntax:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:142
msgid "set_target_properties(mylibrary PROPERTIES DEBUG_POSTFIX _d)"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:146
msgid "Such a package can define its information for consumers as:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:148
msgid ""
"def package_info(self):\n"
"    self.cpp_info.release.libs = [\"mylibrary\"]\n"
"    self.cpp_info.debug.libs = [\"mylibrary_d\"]"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:154
msgid "This will translate to the cmake variables:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:156
msgid ""
"set(CONAN_LIBS_MYPKG_DEBUG mylibrary_d)\n"
"set(CONAN_LIBS_MYPKG_RELEASE mylibrary)\n"
"# ...\n"
"set(CONAN_LIBS_DEBUG mylibrary_d ${CONAN_LIBS_DEBUG})\n"
"set(CONAN_LIBS_RELEASE mylibrary ${CONAN_LIBS_RELEASE})"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:164
msgid ""
"And these variables will be correctly applied to each configuration by "
"``conan_basic_setup()`` helper."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:167
msgid ""
"In this case you can still use the general, not config-specific variables. "
"For example, the include directory, set by default to *include*, is still "
"the same for both debug and release. Those general variables will be applied "
"for all configurations."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:173
msgid ""
"The above code assumes that the package will always use the default Visual "
"Studio runtime (MD/MDd). If we want to keep the package configurable for "
"supporting static(MT)/dynamic(MD) linking with the VS runtime library, some "
"extra work is needed. Basically:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:177
msgid ""
"Keep, the ``compiler.runtime`` setting, i.e. do not implement the "
"``configure()`` method removing it"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:178
msgid ""
"Don't let the ``CMake`` helper define the ``CONAN_LINK_RUNTIME`` env-var to "
"define the runtime, because being defined by the consumer it would be "
"incorrectly applied to both Debug and Release artifacts. This can be done "
"with a ``cmake.command_line.replace(\"CONAN_LINK_RUNTIME\", "
"\"CONAN_LINK_RUNTIME_MULTI\")`` to define a new variable"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:182
msgid ""
"Write a ``package_id()`` method that defines the packages to be built, one "
"for MD/MDd, and other for MT/MTd"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:183
msgid ""
"In *CMakeLists.txt*, use the ``CONAN_LINK_RUNTIME_MULTI`` variable to "
"correctly setup up the runtime for debug and release flags"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:186
msgid ""
"All these steps are already coded in the repo https://github.com/memsharded/"
"hello_multi_config and commented out as **\"Alternative 2\"**"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:189
msgid ""
"Also, you can use any custom configuration you want, they are not "
"restricted. For example, if your package is a multi-library package, you "
"could try doing something like:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:192
msgid ""
"def package_info(self):\n"
"    self.cpp_info.regex.libs = [\"myregexlib1\", \"myregexlib2\"]\n"
"    self.cpp_info.filesystem.libs = [\"myfilesystemlib\"]"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:198
msgid ""
"These specific config variables will not be automatically applied, but you "
"can directly use them in your consumer CMake build script."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:203
msgid ""
"The automatic conversion of multi-config variables to generators is "
"currently only implemented in the ``cmake`` and ``txt`` generators. If you "
"want to have support for them in another build system, please open a GitHub "
"issue for it."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:208
msgid "N configs (1 build) -> N packages"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:210
msgid ""
"It’s possible that an already existing build script is building binaries for "
"different configurations at once, like debug/release, or different "
"architectures (32/64bits), or library types (shared/static). If such build "
"script is used in the previous “Single configuration packages” approach, it "
"will definitely work without problems, but we’ll be wasting precious build "
"time, as we’ll be re-building the whole project for each package, then "
"extracting the relevant artifacts for the given configuration, leaving the "
"others."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:217
msgid ""
"It is possible to specify the logic, so the same build can be reused to "
"create different packages, which will be more efficient:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:225
msgid ""
"This can be done by defining a ``build_id()`` method in the package recipe "
"that will specify the logic."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:228
msgid ""
"settings = \"os\", \"compiler\", \"arch\", \"build_type\"\n"
"\n"
"def build_id(self):\n"
"    self.info_build.settings.build_type = \"Any\"\n"
"\n"
"def package(self):\n"
"    if self.settings.build_type == \"Debug\":\n"
"        #package debug artifacts\n"
"    else:\n"
"        # package release"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:241
msgid ""
"Note that the ``build_id()`` method uses the ``self.info_build`` object to "
"alter the build hash. If the method doesn’t change it, the hash will match "
"the package folder one. By setting ``build_type=\"Any\"``, we are forcing "
"that for both Debug and Release values of ``build_type``, the hash will be "
"the same (the particular string is mostly irrelevant, as long as it is the "
"same for both configurations). Note that the build hash ``sha3`` will be "
"different of both ``sha1`` and ``sha2`` package identifiers."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:248
msgid ""
"This doesn’t imply that there will be strictly one build folder. There will "
"be a build folder for every configuration (architecture, compiler version, "
"etc). So if we just have Debug/Release build types, and we’re producing N "
"packages for N different configurations, we’ll have N/2 build folders, "
"saving half of the build time."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:253
msgid "Read more about this in :ref:`method_build_id`."
msgstr ""
