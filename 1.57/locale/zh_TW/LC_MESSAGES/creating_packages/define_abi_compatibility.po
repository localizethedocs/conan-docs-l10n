# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2022, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.57\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../creating_packages/define_abi_compatibility.rst:4
msgid "Defining Package ABI Compatibility"
msgstr "定義軟體包 ABI 相容性"

#: ../../../creating_packages/define_abi_compatibility.rst:6
msgid ""
"Each package recipe can generate *N* binary packages from it, depending on "
"these three items: ``settings``, ``options`` and ``requires``."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:9
msgid ""
"When any of the :ref:`settings_property` of a package recipe changes, it "
"will reference a different binary:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:12
msgid ""
"class MyLibConanPackage(ConanFile):\n"
"    name = \"mylib\"\n"
"    version = \"1.0\"\n"
"    settings = \"os\", \"arch\", \"compiler\", \"build_type\""
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:19
msgid ""
"When this package is installed by a *conanfile.txt*, another package "
"*conanfile.py*, or directly:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:21
msgid "$ conan install mylib/1.0@user/channel -s arch=x86_64 -s ..."
msgstr "$ conan install mylib/1.0@user/channel -s arch=x86_64 -s ..."

#: ../../../creating_packages/define_abi_compatibility.rst:25
msgid "The process is:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:27
msgid ""
"Conan gets the user input settings and options. Those settings and options "
"can come from the command line, profiles or from the values cached in the "
"latest :command:`conan install` execution."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:29
msgid ""
"Conan retrieves the ``mylib/1.0@user/channel`` recipe, reads the "
"``settings`` attribute, and assigns the necessary values."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:30
msgid ""
"With the current package values for ``settings`` (also ``options`` and "
"``requires``), it will compute a SHA1 hash that will serve as the binary "
"package ID, e.g., ``c6d75a933080ca17eb7f076813e7fb21aaa740f2``."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:32
msgid ""
"Conan will try to find the ``c6d75...`` binary package. If it exists, it "
"will be retrieved. If it cannot be found, it will fail and indicate that it "
"can be built from sources using :command:`conan install --build`."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:35
msgid ""
"If the package is installed again using different settings, for example, on "
"a 32-bit architecture:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:37
msgid "$ conan install mylib/1.0@user/channel -s arch=x86 -s ..."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:41
msgid ""
"The process will be repeated with a different generated package ID, because "
"the ``arch`` setting will have a different value. The same applies to "
"different compilers, compiler versions, build types. When generating "
"multiple binaries - a separate ID is generated for each configuration."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:45
msgid ""
"When developers using the package use the same settings as one of those "
"uploaded binaries, the computed package ID will be identical causing the "
"binary to be retrieved and reused without the need of rebuilding it from the "
"sources."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:48
msgid ""
"The ``options`` behavior is very similar. The main difference is that "
"``options`` can be more easily defined at the package level and they can be "
"defaulted. Check the :ref:`conanfile_options` reference."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:51
msgid ""
"Note this simple scenario of a **header-only** library. The package does not "
"need to be built, and it will not have any ABI issues at all. The recipe for "
"such a package will be to generate a single binary package, no more. This is "
"easily achieved by not declaring ``settings`` nor ``options`` in the recipe "
"as follows:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:55
msgid ""
"class MyLibConanPackage(ConanFile):\n"
"    name = \"mylib\"\n"
"    version = \"1.0\"\n"
"    # no settings defined!"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:62
msgid ""
"No matter the settings are defined by the users, including the compiler or "
"version, the package settings and options will always be the same (left "
"empty) and they will hash to the same binary package ID. That package will "
"typically contain just the header files."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:65
msgid ""
"What happens if we have a library that can be built with GCC 4.8 and will "
"preserve the ABI compatibility with GCC 4.9? (This kind of compatibility is "
"easier to achieve for example for pure C libraries)."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:68
msgid ""
"Although it could be argued that it is worth rebuilding with 4.9 too -to get "
"fixes and performance improvements-. Let's suppose that we don't want to "
"create 2 different binaries, but just a single built with GCC 4.8 which also "
"needs to be compatible for GCC 4.9 installations."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:74
msgid "Defining a Custom package_id()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:76
msgid ""
"The default ``package_id()`` uses the ``settings`` and ``options`` directly "
"as defined, and assumes the `semantic versioning <https://semver.org>`_ for "
"dependencies is defined in ``requires``."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:79
msgid ""
"This ``package_id()`` method can be overridden to control the package ID "
"generation. Within the ``package_id()``, we have access to the ``self.info`` "
"object, which is hashed to compute the binary ID and contains:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:82
msgid ""
"**self.info.settings**: Contains all the declared settings, always as string "
"values. We can access/modify the settings, e.g., ``self.info.settings."
"compiler.version``."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:85
msgid ""
"**self.info.options**: Contains all the declared options, always as string "
"values too, e.g., ``self.info.options.shared``."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:87
msgid ""
"Initially this ``info`` object contains the original settings and options, "
"but they can be changed without constraints to any other string value."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:90
msgid ""
"For example, if you are sure your package ABI compatibility is fine for GCC "
"versions > 4.5 and < 5.0, you could do the following:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:92
msgid ""
"from conans import ConanFile, CMake, tools\n"
"from conans.model.version import Version\n"
"\n"
"class PkgConan(ConanFile):\n"
"    name = \"pkg\"\n"
"    version = \"1.0\"\n"
"    settings = \"compiler\", \"build_type\"\n"
"\n"
"    def package_id(self):\n"
"        v = Version(str(self.settings.compiler.version))\n"
"        if self.settings.compiler == \"gcc\" and (v >= \"4.5\" and v < "
"\"5.0\"):\n"
"            self.info.settings.compiler.version = \"GCC version between 4.5 "
"and 5.0\""
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:107
msgid ""
"We have set the ``self.info.settings.compiler.version`` with an arbitrary "
"string, the value of which is not important (could be any string). The only "
"important thing is that it is the same for any GCC version between 4.5 and "
"5.0. For all those versions, the compiler version will always be hashed to "
"the same ID."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:111
msgid ""
"Let's try and check that it works properly when installing the package for "
"GCC 4.5:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:113
msgid ""
"$ conan create . pkg/1.0@myuser/mychannel -s compiler=gcc -s compiler."
"version=4.5 ...\n"
"\n"
"Requirements\n"
"    pkg/1.0@myuser/mychannel from local\n"
"Packages\n"
"    pkg/1.0@myuser/mychannel:af044f9619574eceb8e1cca737a64bdad88246ad\n"
"..."
msgstr ""
"$ conan create . pkg/1.0@myuser/mychannel -s compiler=gcc -s compiler."
"version=4.5 ...\n"
"\n"
"Requirements\n"
"    pkg/1.0@myuser/mychannel from local\n"
"Packages\n"
"    pkg/1.0@myuser/mychannel:af044f9619574eceb8e1cca737a64bdad88246ad\n"
"..."

#: ../../../creating_packages/define_abi_compatibility.rst:123
msgid ""
"We can see that the computed package ID is ``af04...46ad`` (not real). What "
"happens if we specify GCC 4.6?"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:125
msgid ""
"$ conan install pkg/1.0@myuser/mychannel -s compiler=gcc -s compiler."
"version=4.6 ...\n"
"\n"
"Requirements\n"
"    pkg/1.0@myuser/mychannel from local\n"
"Packages\n"
"    pkg/1.0@myuser/mychannel:af044f9619574eceb8e1cca737a64bdad88246ad"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:134
msgid ""
"The required package has the same result again ``af04...46ad``. Now we can "
"try using GCC 4.4 (< 4.5):"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:136
msgid ""
"$ conan install pkg/1.0@myuser/mychannel -s compiler=gcc -s compiler."
"version=4.4 ...\n"
"\n"
"Requirements\n"
"    pkg/1.0@myuser/mychannel from local\n"
"Packages\n"
"    pkg/1.0@myuser/mychannel:7d02dc01581029782b59dcc8c9783a73ab3c22dd"
msgstr ""
"$ conan install pkg/1.0@myuser/mychannel -s compiler=gcc -s compiler."
"version=4.4 ...\n"
"\n"
"Requirements\n"
"    pkg/1.0@myuser/mychannel from local\n"
"Packages\n"
"    pkg/1.0@myuser/mychannel:7d02dc01581029782b59dcc8c9783a73ab3c22dd"

#: ../../../creating_packages/define_abi_compatibility.rst:145
msgid ""
"The computed package ID is different which means that we need a different "
"binary package for GCC 4.4."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:147
msgid ""
"The same way we have adjusted the ``self.info.settings``, we could set the "
"``self.info.options`` values if needed. If you want to make packages "
"independent on ``build_type`` removing the ``build_type`` from the package "
"settings in the ``package_id()`` will work for OSX and Linux. However when "
"building with Visual studio the ``compiler.runtime`` field will change based "
"on the ``build_type`` value so in that case you will also want to delete the "
"compiler runtime field like so:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:150
msgid ""
"def package_id(self):\n"
"    if self.settings.os in [\"Windows\",\"WindowsStore\"] and self.settings."
"compiler == \"Visual Studio\":\n"
"        del self.info.settings.build_type\n"
"        del self.info.settings.compiler.runtime"
msgstr ""
"def package_id(self):\n"
"    if self.settings.os in [\"Windows\",\"WindowsStore\"] and self.settings."
"compiler == \"Visual Studio\":\n"
"        del self.info.settings.build_type\n"
"        del self.info.settings.compiler.runtime"

#: ../../../creating_packages/define_abi_compatibility.rst:160
msgid ""
"Check :ref:`method_package_id` to see the available helper methods and "
"change its behavior for things like:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:162
msgid "Recipes packaging **header only** libraries."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:163
msgid "Adjusting **Visual Studio toolsets** compatibility."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:170
msgid "Compatible packages"
msgstr "相容的軟體包"

#: ../../../creating_packages/define_abi_compatibility.rst:174
msgid ""
"Some parts of this feature are **deprecated**. Please refer to the :ref:"
"`Migration Guidelines<conan2_migration_guide>` to find the feature that will "
"carry over. The :ref:`method_compatibility` documented below is the current "
"recommendation."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:177
msgid ""
"The above approach defined 1 package ID for different input configurations. "
"For example, all ``gcc`` versions in the range ``(v >= \"4.5\" and v < "
"\"5.0\")`` will have exactly the same package ID, no matter what was the gcc "
"version used to build it. It worked like an information erasure, once the "
"binary is built, it is not possible to know which gcc was used to build it."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:182
msgid ""
"But it is possible to define compatible binaries that have different package "
"IDs. For instance, it is possible to have a different binary for each "
"``gcc`` version, so the ``gcc 4.8`` package will be a different one with a "
"different package ID than the ``gcc 4.9`` one, and still define that you can "
"use the ``gcc 4.8`` package when building with ``gcc 4.9``."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:187
msgid ""
"We can define an ordered list of compatible packages, that will be checked "
"in order if the package ID that our profile defines is not available. Let's "
"see it with an example:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:190
msgid ""
"Lets say that we are building with a profile of ``gcc 4.9``. But for a given "
"package we want to fallback to binaries built with ``gcc 4.8`` or ``gcc "
"4.7`` if we cannot find a binary built with ``gcc 4.9``. That can be defined "
"as:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:194
msgid ""
"from conans import ConanFile\n"
"\n"
"class Pkg(ConanFile):\n"
"    settings = \"os\", \"compiler\", \"arch\", \"build_type\"\n"
"\n"
"    def package_id(self):\n"
"        if self.settings.compiler == \"gcc\" and self.settings.compiler."
"version == \"4.9\":\n"
"            for version in (\"4.8\", \"4.7\"):\n"
"                compatible_pkg = self.info.clone()\n"
"                compatible_pkg.settings.compiler.version = version\n"
"                self.compatible_packages.append(compatible_pkg)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:208
msgid ""
"Note that if the input configuration is ``gcc 4.8``, it will not try to "
"fallback to binaries of ``gcc 4.7`` as the condition is not met."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:211
msgid ""
"The ``self.info.clone()`` method copies the values of ``settings``, "
"``options`` and ``requires`` from the current instance of the recipe so they "
"can be modified to model the compatibility."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:214
msgid ""
"It is the responsibility of the developer to guarantee that such binaries "
"are indeed compatible. For example in:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:216
msgid ""
"from conans import ConanFile\n"
"class Pkg(ConanFile):\n"
"    options = {\"optimized\": [1, 2, 3]}\n"
"    default_options = {\"optimized\": 1}\n"
"    def package_id(self):\n"
"        for optimized in range(int(self.options.optimized), 0, -1):\n"
"            compatible_pkg = self.info.clone()\n"
"            compatible_pkg.options.optimized = optimized\n"
"            self.compatible_packages.append(compatible_pkg)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:228
msgid ""
"This recipe defines that the binaries are compatible with binaries of itself "
"built with a lower optimization value. It can have up to 3 different "
"binaries, one for each different value of ``optimized`` option. The "
"``package_id()`` defines that a binary built with ``optimized=1`` can be "
"perfectly linked and will run even if someone defines ``optimized=2``, or "
"``optimized=3`` in their configuration. But a binary built with "
"``optimized=2`` will not be considered if the requested one is "
"``optimized=1``."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:233
msgid ""
"**The binary should be interchangeable at all effects**. This also applies "
"to other usages of that configuration. If this example used the "
"``optimized`` option to conditionally require different dependencies, that "
"will not be taken into account. The ``package_id()`` step is processed after "
"the whole dependency graph has been built, so it is not possible to define "
"how dependencies are resolved based on this compatibility model, it only "
"applies to use-cases where the binaries can be *interchanged*."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:240
msgid ""
"Compatible packages are a match for a binary in the dependency graph. When a "
"compatible package is found, the :command:`--build=missing` build policy "
"will **not** build from sources that package."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:243
msgid ""
"Check the :ref:`Compatible Compilers<compatible_compilers>` section to see "
"another example of how to take benefit of compatible packages."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:245
msgid "**New conanfile.compatibility() method**"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:247
msgid ""
"The *conanfile.compatible_packages* will be substituted by the new :ref:"
"`method_compatibility` method in Conan 2.0. This method allows you to "
"declare compatibility in a similar way:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:251
msgid ""
"def compatibility(self):\n"
"    if self.settings.compiler == \"gcc\" and self.settings.compiler.version "
"== \"4.9\":\n"
"        return [{\"settings\": [(\"compiler.version\", v)]}\n"
"                for v in (\"4.8\", \"4.7\", \"4.6\")]"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:258
msgid ""
"Please, check the :ref:`method_compatibility` reference for more information."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:263
msgid "Compatible Compilers"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:265
msgid ""
"Some compilers make use of a base compiler to operate, for example, the "
"``intel`` compiler uses the ``Visual Studio`` compiler in Windows "
"environments and ``gcc`` in Linux environments."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:268
msgid ""
"The ``intel`` compiler is declared this way in the :ref:`settings."
"yml<settings_yml>`:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:270
msgid ""
"intel:\n"
"    version: [\"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", "
"\"18\", \"19\"]\n"
"    base:\n"
"        gcc:\n"
"            <<: *gcc\n"
"            threads: [None]\n"
"            exception: [None]\n"
"        Visual Studio:\n"
"            <<: *visual_studio"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:282
msgid ""
"Remember, you can :ref:`extend Conan<extending>` to support other compilers."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:285
msgid ""
"You can use the ``package_id()`` method to define the compatibility between "
"the packages generated by the ``base`` compiler and the ``parent`` one. You "
"can use the following helpers together with the :ref:`compatible "
"packages<compatible_packages>` feature to:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:288
msgid ""
"Consume native ``Visual Studio`` packages when the input compiler in the "
"profile is ``intel`` (if no ``intel`` package is available)."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:289
msgid ""
"The opposite, consume an ``intel`` compiler package when a consumer profile "
"specifies ``Visual Studio`` as the input compiler (if no ``Visual Studio`` "
"package is available)."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:292
msgid ""
"``base_compatible()``: This function will transform the settings used to "
"calculate the package ID into the \"base\" compiler."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:294
msgid ""
"def package_id(self):\n"
"\n"
"    if self.settings.compiler == \"intel\":\n"
"        p = self.info.clone()\n"
"        p.base_compatible()\n"
"        self.compatible_packages.append(p)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:303
msgid ""
"Using the above ``package_id()`` method, if a consumer specifies a profile "
"with a intel profile (**-s compiler==\"intel\"**) and there is no binary "
"available, it will resolve to a Visual Studio package ID corresponding to "
"the base compiler."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:307
msgid ""
"``parent_compatible(compiler=\"compiler\", version=\"version\")``: This "
"function transforms the settings of a compiler into the settings of a parent "
"one using the specified one as the base compiler. As the details of the "
"\"parent\" compatible cannot be guessed, you have to provide them as "
"**keyword args** to the function. The \"compiler\" argument is mandatory, "
"the rest of keyword arguments will be used to initialize the ``info.settings."
"compiler.XXX`` objects to calculate the correct package ID."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:312
msgid ""
"def package_id(self):\n"
"\n"
"   if self.settings.compiler == \"Visual Studio\":\n"
"      compatible_pkg = self.info.clone()\n"
"      compatible_pkg.parent_compatible(compiler=\"intel\", version=16)\n"
"      self.compatible_packages.append(compatible_pkg)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:321
msgid ""
"In this case, for a consumer specifying Visual Studio compiler, if no "
"package is found, it will search for an \"intel\" package for the version 16."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:324
msgid ""
"Take into account that you can use also these helpers without the "
"\"compatible packages\" feature:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:326
msgid ""
"def package_id(self):\n"
"\n"
"   if self.settings.compiler == \"Visual Studio\":\n"
"      self.info.parent_compatible(compiler=\"intel\", version=16)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:333
msgid ""
"In the above example, we will transform the package ID of the ``Visual "
"Studio`` package to be the same as the ``intel 16``, but you won't be able "
"to differentiate the packages built with ``intel`` with the ones built by "
"``Visual Studio`` because both will have the same package ID, and that is "
"not always desirable."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:340
msgid "Dependency Issues"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:342
msgid ""
"Let's define a simple scenario whereby there are two packages: "
"``my_other_lib/2.0`` and ``my_lib/1.0`` which depends on "
"``my_other_lib/2.0``. Let's assume that their recipes and binaries have "
"already been created and uploaded to a Conan remote."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:345
msgid ""
"Now, a new release for ``my_other_lib/2.1`` is released with an improved "
"recipe and new binaries. The ``my_lib/1.0`` is modified and is required to "
"be upgraded to ``my_other_lib/2.1``."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:349
msgid ""
"This scenario will be the same in the case that a consuming project of "
"``my_lib/1.0`` defines a dependency to ``my_other_lib/2.1``, which takes "
"precedence over the existing project in ``my_lib/1.0``."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:352
msgid ""
"The question is: **Is it necessary to build new** ``my_lib/1.0`` **binary "
"packages?** or are the existing packages still valid?"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:354
msgid "The answer: **It depends**."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:356
msgid ""
"Let's assume that both packages are compiled as static libraries and that "
"the API exposed by ``my_other_lib`` to ``my_lib/1.0`` through the public "
"headers, has not changed at all. In this case, it is not required to build "
"new binaries for ``my_lib/1.0`` because the final consumer will link against "
"both ``my_lib/1.0`` and ``my_other_lib/2.1``."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:360
msgid ""
"On the other hand, it could happen that the API exposed by **my_other_lib** "
"in the public headers has changed, but without affecting the ``my_lib/1.0`` "
"binary for any reason (like changes consisting on new functions not used by "
"**my_lib**). The same reasoning would apply if **MyOtherLib** was only the "
"header."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:363
msgid ""
"But what if a header file of ``my_other_lib`` -named *myadd.h*- has changed "
"from ``2.0`` to ``2.1``:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:365
msgid "*myadd.h* header file in version 2.0"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:365
msgid " int addition (int a, int b) { return a - b; }"
msgstr " int addition (int a, int b) { return a - b; }"

#: ../../../creating_packages/define_abi_compatibility.rst:370
msgid "*myadd.h* header file in version 2.1"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:370
msgid " int addition (int a, int b) { return a + b; }"
msgstr " int addition (int a, int b) { return a + b; }"

#: ../../../creating_packages/define_abi_compatibility.rst:375
msgid ""
"And the ``addition()`` function is called from the compiled *.cpp* files of "
"``my_lib/1.0``?"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:377
msgid ""
"Then, **a new binary for my_lib/1.0 is required to be built for the new "
"dependency version**. Otherwise it will maintain the old, buggy "
"``addition()`` version. Even in the case that ``my_lib/1.0`` doesn't have "
"any change in its code lines neither in the recipe, the resulting binary "
"rebuilding ``my_lib`` requires ``my_other_lib/2.1`` and the package to be "
"different."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:385
msgid "Using package_id() for Package Dependencies"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:387
msgid ""
"The ``self.info`` object has also a ``requires`` object. It is a dictionary "
"containing the necessary information for each requirement, all direct and "
"transitive dependencies. For example, ``self.info."
"requires[\"my_other_lib\"]`` is a ``RequirementInfo`` object."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:390
msgid ""
"Each ``RequirementInfo`` has the following `read only` reference fields:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:392
msgid "``full_name``: Full require's name, e.g., **my_other_lib**"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:393
msgid "``full_version``: Full require's version, e.g., **1.2**"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:394
msgid "``full_user``: Full require's user, e.g., **my_user**"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:395
msgid "``full_channel``: Full require's channel, e.g., **stable**"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:396
msgid "``full_package_id``: Full require's package ID, e.g., **c6d75a...**"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:398
msgid "The following fields are used in the ``package_id()`` evaluation:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:400
msgid "``name``: By default same value as full_name, e.g., **my_other_lib**."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:401
msgid ""
"``version``: By default the major version representation of the "
"``full_version``. E.g., **1.Y** for a **1.2** ``full_version`` field and **1."
"Y.Z** for a **1.2.3** ``full_version`` field."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:404
msgid "``user``: By default ``None`` (doesn't affect the package ID)."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:405
msgid "``channel``: By default ``None`` (doesn't affect the package ID)."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:406
msgid "``package_id``: By default ``None`` (doesn't affect the package ID)."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:408
msgid ""
"When defining a package ID for model dependencies, it is necessary to take "
"into account two factors:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:410
msgid "The versioning schema followed by our requirements (semver?, custom?)."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:411
msgid ""
"The type of library being built or reused (shared (*.so*, *.dll*, *.dylib*), "
"static)."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:414
msgid "Versioning Schema"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:416
msgid ""
"By default Conan assumes `semver <https://semver.org>`_ compatibility. For "
"example, if a version changes from minor **2.0** to **2.1**, Conan will "
"assume that the API is compatible (headers not changing), and that it is not "
"necessary to build a new binary for it. This also applies to patches, "
"whereby changing from **2.1.10** to **2.1.11** doesn't require a re-build."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:420
msgid ""
"If it is necessary to change the default behavior, the applied versioning "
"schema can be customized within the ``package_id()`` method:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:422
msgid ""
"from conans import ConanFile, CMake, tools\n"
"from conans.model.version import Version\n"
"\n"
"class PkgConan(ConanFile):\n"
"    name = \"my_lib\"\n"
"    version = \"1.0\"\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"    requires = \"my_other_lib/2.0@lasote/stable\"\n"
"\n"
"    def package_id(self):\n"
"        myotherlib = self.info.requires[\"my_other_lib\"]\n"
"\n"
"        # Any change in the MyOtherLib version will change current Package "
"ID\n"
"        myotherlib.version = myotherlib.full_version\n"
"\n"
"        # Changes in major and minor versions will change the Package ID "
"but\n"
"        # only a MyOtherLib patch won't. E.g., from 1.2.3 to 1.2.89 won't "
"change.\n"
"        myotherlib.version = myotherlib.full_version.minor()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:443
msgid ""
"Besides ``version``, there are additional helpers that can be used to "
"determine whether the **channel** and **user** of one dependency also "
"affects the binary package, or even the required package ID can change your "
"own package ID."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:446
msgid ""
"You can determine if the following variables within any requirement change "
"the ID of your binary package using the following modes:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:449
msgid "**Modes / Variables**"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:449
msgid "``name``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:449
msgid "``version``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:449
msgid "``user``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:449
msgid "``channel``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:449
msgid "``package_id``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:449
msgid "RREV"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:449
msgid "PREV"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:451
msgid "``semver_direct_mode()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:451
#: ../../../creating_packages/define_abi_compatibility.rst:453
#: ../../../creating_packages/define_abi_compatibility.rst:455
#: ../../../creating_packages/define_abi_compatibility.rst:457
#: ../../../creating_packages/define_abi_compatibility.rst:459
#: ../../../creating_packages/define_abi_compatibility.rst:461
#: ../../../creating_packages/define_abi_compatibility.rst:463
#: ../../../creating_packages/define_abi_compatibility.rst:465
#: ../../../creating_packages/define_abi_compatibility.rst:467
#: ../../../creating_packages/define_abi_compatibility.rst:471
#: ../../../creating_packages/define_abi_compatibility.rst:473
msgid "Yes"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:451
#: ../../../creating_packages/define_abi_compatibility.rst:453
msgid "Yes, only > 1.0.0 (e.g., **1**.2.Z+b102)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:451
#: ../../../creating_packages/define_abi_compatibility.rst:453
#: ../../../creating_packages/define_abi_compatibility.rst:455
#: ../../../creating_packages/define_abi_compatibility.rst:457
#: ../../../creating_packages/define_abi_compatibility.rst:459
#: ../../../creating_packages/define_abi_compatibility.rst:461
#: ../../../creating_packages/define_abi_compatibility.rst:463
#: ../../../creating_packages/define_abi_compatibility.rst:465
#: ../../../creating_packages/define_abi_compatibility.rst:467
#: ../../../creating_packages/define_abi_compatibility.rst:469
#: ../../../creating_packages/define_abi_compatibility.rst:471
msgid "No"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:453
msgid "``semver_mode()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:455
msgid "``major_mode()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:455
msgid "Yes (e.g., **1**.2.Z+b102)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:457
msgid "``minor_mode()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:457
msgid "Yes (e.g., **1.2**.Z+b102)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:459
msgid "``patch_mode()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:459
msgid "Yes (e.g., **1.2.3**\\+b102)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:461
msgid "``base_mode()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:461
msgid "Yes (e.g., **1.7**\\+b102)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:463
msgid "``full_version_mode()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:463
#: ../../../creating_packages/define_abi_compatibility.rst:465
#: ../../../creating_packages/define_abi_compatibility.rst:467
msgid "Yes (e.g., **1.2.3+b102**)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:465
msgid "``full_recipe_mode()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:467
msgid "``full_package_mode()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:469
msgid "``unrelated_mode()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:471
msgid "``recipe_revision_mode()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:473
msgid "``package_revision_mode()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:476
msgid ""
"All the modes can be applied to all dependencies, or to individual ones:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:478
msgid ""
"def package_id(self):\n"
"    # apply semver_mode for all the dependencies of the package\n"
"    self.info.requires.semver_mode()\n"
"    # use semver_mode just for MyOtherLib\n"
"    self.info.requires[\"MyOtherLib\"].semver_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:487
msgid ""
"``semver_direct_mode()``: This is the default mode. It uses "
"``semver_mode()`` for direct dependencies (first level dependencies, "
"directly declared by the package) and ``unrelated_mode()`` for indirect, "
"transitive dependencies of the package. It assumes that the binary will be "
"affected by the direct dependencies, which they will already encode how "
"their transitive dependencies affect them. This might not always be true, as "
"explained above, and that is the reason it is possible to customize it."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:493
msgid ""
"In this mode, if the package depends on \"MyLib\", which transitively "
"depends on \"MyOtherLib\", the mode means:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:495
msgid ""
"my_lib/1.2.3@user/testing       => my_lib/1.Y.Z\n"
"my_other_lib/2.3.4@user/testing  =>"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:500
msgid ""
"So the direct dependencies are mapped to the major version only. Changing "
"its channel, or using version ``my_lib/1.4.5`` will still produce ``my_lib/1."
"Y.Z`` and thus the same package-id. The indirect, transitive dependency "
"doesn't affect the package-id at all."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:506
msgid ""
"**Known-bug**: Package ID mode ``semver_direct_mode`` takes into account the "
"options of transitive requirements. It means that modifying the options of "
"any transitive requirement will modify the computed package ID, and also "
"adding/removing a transitive requirement will modify the computed package ID "
"(this happens even if the added/removed requirement doesn't have any option)."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:512
msgid ""
"``semver_mode()``: In this mode, only a major release version (starting from "
"**1.0.0**) changes the package ID. Every version change prior to 1.0.0 "
"changes the package ID, but only major changes after 1.0.0 will be applied."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:515
msgid ""
"def package_id(self):\n"
"  self.info.requires[\"my_other_lib\"].semver_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:520
msgid "This results in:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:522
msgid ""
"my_lib/1.2.3@user/testing       => my_lib/1.Y.Z\n"
"my_other_lib/2.3.4@user/testing  => my_other_lib/2.Y.Z"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:527
msgid ""
"In this mode, versions starting with ``0`` are considered unstable and "
"mapped to the full version:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:529
msgid ""
"my_lib/0.2.3@user/testing       => my_lib/0.2.3\n"
"my_other_lib/0.3.4@user/testing  => my_other_lib/0.3.4"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:534
msgid ""
"``major_mode()``: Any change in the major release version (starting from "
"**0.0.0**) changes the package ID."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:536
msgid ""
"def package_id(self):\n"
"  self.info.requires[\"MyOtherLib\"].major_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:541
msgid ""
"This mode is basically the same as ``semver_mode``, but the only difference "
"is that major versions ``0.Y.Z``, which are considered unstable by semver, "
"are still mapped to only the major, dropping the minor and patch parts."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:544
msgid ""
"``minor_mode()``: Any change in major or minor (not patch nor build) version "
"of the required dependency changes the package ID."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:546
msgid ""
"def package_id(self):\n"
"    self.info.requires[\"my_other_lib\"].minor_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:551
msgid ""
"``patch_mode()``: Any changes to major, minor or patch (not build) versions "
"of the required dependency change the package ID."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:553
msgid ""
"def package_id(self):\n"
"    self.info.requires[\"my_other_lib\"].patch_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:558
msgid ""
"``base_mode()``: Any changes to the base of the version (not build) of the "
"required dependency changes the package ID. Note that in the case of semver "
"notation this may produce the same result as ``patch_mode()``, but it is "
"actually intended to dismiss the build part of the version even without "
"strict semver."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:562
msgid ""
"def package_id(self):\n"
"    self.info.requires[\"my_other_lib\"].base_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:567
msgid ""
"``full_version_mode()``: Any changes to the version of the required "
"dependency changes the package ID."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:569
msgid ""
"def package_id(self):\n"
"  self.info.requires[\"my_other_lib\"].full_version_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:574
msgid "my_other_lib/1.3.4-a4+b3@user/testing  => my_other_lib/1.3.4-a4+b3"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:578
msgid ""
"``full_recipe_mode()``: Any change in the reference of the requirement (user "
"& channel too) changes the package ID."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:580
msgid ""
"def package_id(self):\n"
"    self.info.requires[\"my_other_lib\"].full_recipe_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:585
msgid ""
"This keeps the whole dependency reference, except the package-id of the "
"dependency."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:587
msgid ""
"my_other_lib/1.3.4-a4+b3@user/testing  => my_other_lib/1.3.4-a4+b3@user/"
"testing"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:591
msgid ""
"``full_package_mode()``: Any change in the required version, user, channel "
"or package ID changes the package ID."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:593
msgid ""
"def package_id(self):\n"
"    self.info.requires[\"my_other_lib\"].full_package_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:598
msgid ""
"Any change to the dependency, including its binary package-id, will in turn "
"produce a new package-id for the consumer package."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:601
msgid ""
"MyOtherLib/1.3.4-a4+b3@user/testing:73b..fa56  => MyOtherLib/1.3.4-"
"a4+b3@user/testing:73b..fa56"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:605
msgid "``unrelated_mode()``: Requirements do not change the package ID."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:607
msgid ""
"def package_id(self):\n"
"    self.info.requires[\"MyOtherLib\"].unrelated_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:612
msgid ""
"``recipe_revision_mode()``: The full reference and the package ID of the "
"dependencies, `pkg/version@user/channel#RREV:pkg_id` (including the recipe "
"revision), will be taken into account to compute the consumer package ID"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:616
msgid ""
"mypkg/1.3.4@user/testing#RREV1:73b..fa56#PREV1  => mypkg/1.3.4-a4+b3@user/"
"testing#RREV1"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:620
msgid ""
"def package_id(self):\n"
"    self.info.requires[\"mypkg\"].recipe_revision_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:625
msgid ""
"``package_revision_mode()``: The full package reference `pkg/version@user/"
"channel#RREV:ID#PREV` of the dependencies, including the recipe revision, "
"the binary package ID and the package revision will be taken into account to "
"compute the consumer package ID"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:629
msgid ""
"This is the most strict mode. Any change in the upstream will produce new "
"consumers package IDs, becoming a fully deterministic binary model."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:632
msgid ""
"# The full reference of the dependency package binary will be used as-is\n"
"mypkg/1.3.4@user/testing#RREV1:73b..fa56#PREV1  => mypkg/1.3.4@user/"
"testing#RREV1:73b..fa56#PREV1"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:637
msgid ""
"def package_id(self):\n"
"    self.info.requires[\"mypkg\"].package_revision_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:645
msgid ""
"Version ranges are not used to calculate the ``package_id`` only the "
"resolved version in the graph is used"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:648
msgid "You can also adjust the individual properties manually:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:650
msgid ""
"def package_id(self):\n"
"    myotherlib = self.info.requires[\"MyOtherLib\"]\n"
"\n"
"    # Same as myotherlib.semver_mode()\n"
"    myotherlib.name = myotherlib.full_name\n"
"    myotherlib.version = myotherlib.full_version.stable()  # major(), "
"minor(), patch(), base, build\n"
"    myotherlib.user = myotherlib.channel = myotherlib.package_id = None\n"
"\n"
"    # Only the channel (and the name) matters\n"
"    myotherlib.name = myotherlib.full_name\n"
"    myotherlib.user = myotherlib.package_id = myotherlib.version = None\n"
"    myotherlib.channel = myotherlib.full_channel"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:665
msgid ""
"The result of the ``package_id()`` is the package ID hash, but the details "
"can be checked in the generated *conaninfo.txt* file. The ``[requires]``, "
"``[options]`` and ``[settings]`` are taken into account when generating the "
"SHA1 hash for the package ID, while the ``[full_xxxx]`` fields show the "
"complete reference information."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:670
msgid "The default behavior produces a *conaninfo.txt* that looks like:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:672
msgid ""
"[requires]\n"
"MyOtherLib/2.Y.Z\n"
"\n"
"[full_requires]\n"
"MyOtherLib/2.2@demo/testing:73bce3fd7eb82b2eabc19fe11317d37da81afa56"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:683
msgid "Changing the default package-id mode"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:685
msgid ""
"It is possible to change the default ``semver_direct_mode`` package-id mode, "
"in the *conan.conf* file:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:688
msgid "*conan.conf* configuration file"
msgstr "*conan.conf* 組態檔"

#: ../../../creating_packages/define_abi_compatibility.rst:688
msgid ""
"[general]\n"
"default_package_id_mode=full_package_mode"
msgstr ""
"[general]\n"
"default_package_id_mode=full_package_mode"

#: ../../../creating_packages/define_abi_compatibility.rst:694
msgid ""
"Possible values are the names of the above methods: ``full_recipe_mode``, "
"``semver_mode``, etc."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:698
msgid ""
"The ``default_package_id_mode`` is a global configuration. It will change "
"how all the package-ids are computed, for all packages. It is impossible to "
"mix different ``default_package_id_mode`` values. The same "
"``default_package_id_mode`` must be used in all clients, servers, CI, etc., "
"and it cannot be changed without rebuilding all packages."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:704
msgid ""
"Note that the default package-id mode is the mode that is used when the "
"package is initialized and **before** ``package_id()`` method is called. You "
"can still define ``full_package_mode`` as default in *conan.conf*, but if a "
"recipe declare that it is header-only, with:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:708
msgid ""
"def package_id(self):\n"
"  self.info.clear() # clears requires, but also settings if existing\n"
"  # or if there are no settings/options, this would be equivalent\n"
"  self.info.requires.clear() # or self.info.requires.unrelated_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:715
msgid ""
"That would still be executed, changing the \"default\" behavior, and leading "
"to a package that only generates 1 package-id for all possible "
"configurations and versions of dependencies."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:718
msgid ""
"Remember that *conan.conf* can be shared and installed with :ref:"
"`conan_config_install`."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:720
msgid ""
"Take into account that you can combine the :ref:`compatible "
"packages<compatible_packages>` with the package-id modes."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:722
msgid ""
"For example, if you are generating binary packages with the default "
"``recipe_revision_mode``, but you want these packages to be consumed from a "
"client with a different mode activated, you can create a compatible package "
"transforming the mode to ``recipe_revision_mode`` so the package generated "
"with the ``recipe_revision_mode`` can be resolved if no package for the "
"default mode is found:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:727
msgid ""
"from conans import ConanFile\n"
"\n"
"class Pkg(ConanFile):\n"
"    ...\n"
"\n"
"    def package_id(self):\n"
"        p = self.info.clone()\n"
"        p.requires.recipe_revision_mode()\n"
"        self.compatible_packages.append(p)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:743
msgid "Enabling full transitivity in package_id modes"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:747
msgid ""
"This will become the default behavior in the future (Conan 2.0). It is "
"recommended to activate it when possible (it might require rebuilding some "
"packages, as their package IDs will change)"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:751
msgid ""
"When a package declares in its ``package_id()`` method that it is not "
"affected by its dependencies, that will propagate down to the indirect "
"consumers of that package. There are several ways this can be done, ``self."
"info.clear()``, ``self.info.requires.clear()``, ``self.info.requires."
"remove[\"dep\"]`` and ``self.info.requires.unrelated_mode()``, for example."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:755
msgid ""
"Let's assume for the discussion that it is a header only library, using the "
"``self.info.clear()`` helper. This header only package has a single "
"dependency, which is a static library. Then, downstream consumers of the "
"header only library that uses a package mode different from the default, "
"should be also affected by the upstream transitivity dependency. Lets say "
"that we have the following scenario:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:760
msgid "``app/1.0`` depends on ``pkgc/1.0`` and ``pkga/1.0``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:761
msgid "``pkgc/1.0`` depends only on ``pkgb/1.0``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:762
msgid ""
"``pkgb/1.0`` depends on ``pkga/1.0``, and defines ``self.info.clear()`` in "
"its ``package_id()``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:763
msgid "We are using ``full_version_mode``"
msgstr "我們正在使用 ``full_version_mode``"

#: ../../../creating_packages/define_abi_compatibility.rst:764
msgid ""
"Now we create a new ``pkga/2.0`` that has some changes in its header, that "
"would require to rebuild ``pkgc/1.0`` against it."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:765
msgid "``app/1.0`` now depends on ```pkgc/1.0`` and ``pkga/2.0``"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:771
msgid ""
"With the default behavior, the header only ``pkgb`` is isolating ``pkgc`` "
"from the upstream changes effects. The package-id ``PIDC1`` we get for "
"``pkgc/1.0`` is exactly the same when depending on ``pkga/1.0`` and "
"``pkga/2.0``."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:774
msgid ""
"If we want to have the ``full_version_mode`` to be fully transitive, "
"irrespective of the local package-id modes of the packages, we can configure "
"it in the :ref:`conan_conf` section. To summarize, you can activate the "
"``general.full_transitive_package_id`` configuration (``$ conan config set "
"general.full_transitive_package_id=1``)."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:778
msgid ""
"If we do this, then ``pkgc/1.0`` will compute 2 different package-ids, one "
"for ``pkga/1.0`` (``PIDC1``) and the other to link with ``pkga/2.0`` "
"(``PIDC2``)."
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:783
msgid "Library Types: Shared, Static, Header-only"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:785
msgid "Let's see some examples, corresponding to common scenarios:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:787
msgid ""
"``my_lib/1.0`` is a shared library that links with a static library "
"``my_other_lib/2.0`` package. When a new ``my_other_lib/2.1`` version is "
"released: Do I need to create a new binary for ``my_lib/1.0`` to link with "
"it?"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:791
msgid ""
"Yes, always, as the implementation is embedded in the ``my_lib/1.0`` shared "
"library. If we always want to rebuild our library, even if the channel "
"changes (we assume a channel change could mean a source code change):"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:795
msgid ""
"def package_id(self):\n"
"    # Any change in the my_other_lib version, user or\n"
"    # channel or Package ID will affect our package ID\n"
"    self.info.requires[\"my_other_lib\"].full_package_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:802
msgid ""
"``my_lib/1.0`` is a shared library, requiring another shared library "
"``my_other_lib/2.0`` package. When a new ``my_other_lib/2.1`` version is "
"released: Do I need to create a new binary for ``my_lib/1.0`` to link with "
"it?"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:806
msgid ""
"It depends. If the public headers have not changed at all, it is not "
"necessary. Actually it might be necessary to consider transitive "
"dependencies that are shared among the public headers, how they are linked "
"and if they cross the frontiers of the API, it might also lead to "
"incompatibilities. If the public headers have changed, it would depend on "
"what changes and how are they used in ``my_lib/1.0``. Adding new methods to "
"the public headers will have no impact, but changing the implementation of "
"some functions that will be inlined when compiled from ``my_lib/1.0`` will "
"definitely require re-building. For this case, it could make sense to have "
"this configuration:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:814
msgid ""
"def package_id(self):\n"
"    # Any change in the my_other_lib version, user or channel\n"
"    # or Package ID will affect our package ID\n"
"    self.info.requires[\"my_other_lib\"].full_package_mode()\n"
"\n"
"    # Or any change in the my_other_lib version, user or\n"
"    # channel will affect our package ID\n"
"    self.info.requires[\"my_other_lib\"].full_recipe_mode()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:825
msgid ""
"``my_lib/1.0`` is a header-only library, linking with any kind (header, "
"static, shared) of library in ``my_other_lib/2.0`` package. When a new "
"``my_other_lib/2.1`` version is released: Do I need to create a new binary "
"for ``my_lib/1.0`` to link with it?"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:829
msgid ""
"Never. The package should always be the same as there are no settings, no "
"options, and in any way a dependency can affect a binary, because there is "
"no such binary. The default behavior should be changed to:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:833
msgid ""
"def package_id(self):\n"
"    self.info.requires.clear()"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:838
msgid ""
"``my_lib/1.0`` is a static library linking to a header only library in "
"``my_other_lib/2.0`` package. When a new ``my_other_lib/2.1`` version is "
"released: Do I need to create a new binary for ``my_lib/1.0`` to link with "
"it? It could happen that the ``my_other_lib`` headers are strictly used in "
"some ``my_lib`` headers, which are not compiled, but transitively included. "
"But in general, it is more likely that ``my_other_lib`` headers are used in "
"``MyLib`` implementation files, so every change in them should imply a new "
"binary to be built. If we know that changes in the channel never imply a "
"source code change, as set in our workflow/lifecycle, we could write:"
msgstr ""

#: ../../../creating_packages/define_abi_compatibility.rst:847
msgid ""
"def package_id(self):\n"
"    self.info.requires[\"my_other_lib\"].full_package()\n"
"    self.info.requires[\"my_other_lib\"].channel = None # Channel doesn't "
"change out package ID"
msgstr ""
