# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2024, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:10+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../creating_packages/package_information.rst:4
msgid "Define the package information"
msgstr ""

#: ../../../creating_packages/package_information.rst:8
msgid ""
"We are actively working to finalize the *Conan 2.0 Release*. Some of the "
"information on this page references **deprecated** features which will not "
"be carried forward with the new release. It's important to check the :ref:"
"`Migration Guidelines<conan2_migration_guide>` to ensure you are using the "
"most up to date features."
msgstr ""

#: ../../../creating_packages/package_information.rst:12
msgid ""
"When creating a recipe to package a library, it is important to define the "
"information about the package so consumers can get the information "
"correctly. Conan achieves this by decoupling the information of the package "
"from the format needed using :ref:`generators_reference`, that translate the "
"generic information into the appropriate format file."
msgstr ""

#: ../../../creating_packages/package_information.rst:16
msgid ""
"This generic information is defined inside the recipe, using the :ref:"
"`method_package_info` method. There you can declare package information like "
"the location of the header files, library names, defines, flags..."
msgstr ""

#: ../../../creating_packages/package_information.rst:19
msgid ""
"from conans import ConanFile\n"
"\n"
"class MyConan(ConanFile):\n"
"    name = \"cool_library\"\n"
"    ...\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.includedirs = [\"include/cool\"]\n"
"        self.cpp_info.libs = [\"libcool\"]\n"
"        self.cpp_info.defines = [\"DEFINE_COOL=1\"]"
msgstr ""

#: ../../../creating_packages/package_information.rst:32
msgid ""
"The package information is done using the attributes of the :ref:"
"`cpp_info_attributes_reference` object. This information will be aggregated "
"by Conan and exposed via ``self.deps_cpp_info`` to consumers and generators."
msgstr ""

#: ../../../creating_packages/package_information.rst:37
msgid ""
"This information is important as it describes the package contents in a "
"generic way with a pretty straightforward syntax that can later be "
"translated to a suitable format. The advantage of having this information "
"here, is that the package could be consumed from a different build system "
"that the one used to compile the library. For example, a library that builds "
"using Autotools can be consumed later in CMake with this information using "
"any of the CMake generators."
msgstr ""

#: ../../../creating_packages/package_information.rst:44
msgid "Read :ref:`method_package_info` to learn more about this method."
msgstr ""

#: ../../../creating_packages/package_information.rst:49
msgid "Using Components"
msgstr ""

#: ../../../creating_packages/package_information.rst:51
msgid ""
"If your package contains more than one library or you want to define "
"separated components so consumers can have more granular information, you "
"can use components in your :ref:`method_package_info` method."
msgstr ""

#: ../../../creating_packages/package_information.rst:54
msgid ""
"When you are creating a Conan package, it is recommended to have only one "
"library (*.lib*, *.a*, *.so*, *.dll*...) per package. However, especially "
"with third-party projects like Boost, Poco or OpenSSL, they would contain "
"several libraries inside."
msgstr ""

#: ../../../creating_packages/package_information.rst:57
msgid ""
"Usually those libraries inside the same package depend on each other and "
"modelling the relationship among them is required."
msgstr ""

#: ../../../creating_packages/package_information.rst:59
msgid ""
"With **components**, you can model libraries and executables inside the same "
"package and how one depends on the other. Each library or executable will be "
"one component inside ``cpp_info`` like this:"
msgstr ""

#: ../../../creating_packages/package_information.rst:62
msgid ""
"def package_info(self):\n"
"    self.cpp_info.names[\"cmake_find_package\"] = \"OpenSSL\"\n"
"    self.cpp_info.names[\"cmake_find_package_multi\"] = \"OpenSSL\"\n"
"    self.cpp_info.components[\"crypto\"].names[\"cmake_find_package\"] = "
"\"Crypto\"\n"
"    self.cpp_info.components[\"crypto\"].libs = [\"libcrypto\"]\n"
"    self.cpp_info.components[\"crypto\"].defines = [\"DEFINE_CRYPTO=1\"]\n"
"    self.cpp_info.components[\"ssl\"].names[\"cmake\"] = \"SSL\"\n"
"    self.cpp_info.components[\"ssl\"].includedirs = [\"include/"
"headers_ssl\"]\n"
"    self.cpp_info.components[\"ssl\"].libs = [\"libssl\"]\n"
"    self.cpp_info.components[\"ssl\"].requires = [\"crypto\"]"
msgstr ""

#: ../../../creating_packages/package_information.rst:75
msgid ""
"You can define dependencies among different components using the "
"``requires`` attribute and the name of the component. The dependency graph "
"for components will be calculated and values will be aggregated in the "
"correct order for each field."
msgstr ""

#: ../../../creating_packages/package_information.rst:78
msgid ""
"def package_info(self):\n"
"    self.cpp_info.components[\"LibA\"].libs = [\"liba\"]      # Name of the "
"library for the 'LibA' component\n"
"    self.cpp_info.components[\"LibA\"].requires = [\"LibB\"]  # Requires "
"point to the name of the component\n"
"\n"
"    self.cpp_info.components[\"LibB\"].libs = [\"libb\"]\n"
"\n"
"    self.cpp_info.components[\"LibC\"].libs = [\"libc\"]\n"
"    self.cpp_info.components[\"LibC\"].requires = [\"LibA\"]\n"
"\n"
"    self.cpp_info.components[\"LibD\"].libs = [\"libd\"]\n"
"    self.cpp_info.components[\"LibD\"].requires = [\"LibA\"]\n"
"\n"
"    self.cpp_info.components[\"LibE\"].libs = [\"libe\"]\n"
"    self.cpp_info.components[\"LibE\"].requires = [\"LibB\"]\n"
"\n"
"    self.cpp_info.components[\"LibF\"].libs = [\"libf\"]\n"
"    self.cpp_info.components[\"LibF\"].requires = [\"LibD\", \"LibE\"]"
msgstr ""

#: ../../../creating_packages/package_information.rst:98
msgid ""
"For consumers and generators, the order of the libraries from this "
"components graph will be:"
msgstr ""

#: ../../../creating_packages/package_information.rst:100
msgid ""
"self.deps_cpp_info.libs == [\"libf\", \"libe\", \"libd\", \"libc\", "
"\"liba\", \"libb\"]"
msgstr ""

#: ../../../creating_packages/package_information.rst:104
msgid "Declaration of requires from other packages is also allowed:"
msgstr ""

#: ../../../creating_packages/package_information.rst:106
msgid ""
"class MyConan(ConanFile):\n"
"    ...\n"
"    requires = \"zlib/1.2.11\", \"openssl/1.1.1g\"\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.components[\"comp1\"].requires = [\"zlib::zlib\"]  # "
"Depends on all components in zlib package\n"
"        self.cpp_info.components[\"comp2\"].requires = [\"comp1\", "
"\"openssl::ssl\"]  # Depends on ssl component in openssl package"
msgstr ""

#: ../../../creating_packages/package_information.rst:116
msgid ""
"By default, components **won't link against any other package required by "
"the recipe**. The requires list has to be **populated explicitly** with the "
"list of components from other packages to use: it can be the full "
"requirement (``zlib::zlib``) or a single component (``openssl::ssl``)."
msgstr ""

#: ../../../creating_packages/package_information.rst:122
msgid ""
"The information of components is aggregated to the *global* ``cpp_info`` "
"scope and the usage of components should be transparent."
msgstr ""

#: ../../../creating_packages/package_information.rst:124
msgid ""
"Consumers can get this information via ``self.deps_cpp_info`` as usual and "
"use it in the ``build()`` method of any dependent recipe:"
msgstr ""

#: ../../../creating_packages/package_information.rst:126
msgid ""
"class PocoTimerConan(ConanFile):\n"
"    ...\n"
"    requires = \"zlib/1.2.11\", \"openssl/1.0.2u\"\n"
"    ...\n"
"\n"
"    def build(self):\n"
"        # Get the include directories of the SSL component of openssl "
"package\n"
"        self.deps_cpp_info[\"openssl\"].components[\"ssl\"].include_paths"
msgstr ""

#: ../../../creating_packages/package_information.rst:138
msgid ""
"Recipes that require packages that declare components can also take "
"advantage of this granularity, they can declare in the ``cpp_info.requires`` "
"attribute the list of components from the requirements they want to link "
"with:"
msgstr ""

#: ../../../creating_packages/package_information.rst:141
msgid ""
"class Library(ConanFile):\n"
"    name = 'library'\n"
"    requires = \"openssl/1.0.2u\"\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.requires = ['openssl::ssl']"
msgstr ""

#: ../../../creating_packages/package_information.rst:150
msgid ""
"In the previous example, the 'library' package and transitively all its "
"consumers will link only with the component ``ssl`` from the ``openssl`` "
"package."
msgstr ""

#: ../../../creating_packages/package_information.rst:155
msgid ""
"Read :ref:`components reference <cpp_info_attributes_reference>` for more "
"information."
msgstr ""
