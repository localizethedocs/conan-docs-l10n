# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2024, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 2.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 14:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:4
msgid "Capturing Git scm information"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:6
msgid "There are 2 main strategies to handle source code in recipes:"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:8
msgid ""
"**Third-party code**: When the ``conanfile.py`` recipe is packaging third "
"party code, like an open source library, it is typically better to use the "
"``source()`` method to download or clone the sources of that library. This "
"is the approach followed by the ``conan-center-index`` repository for "
"ConanCenter."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:9
msgid ""
"**Your own code**: When the ``conanfile.py`` recipe is packaging your own "
"code, it is typically better to have the ``conanfile.py`` in the same "
"repository as the sources. Then, there are 2 alternatives for achieving "
"reproducibility:"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:11
msgid ""
"Using the ``exports_sources`` (or ``export_source()`` method) to capture a "
"copy of the sources together with the recipe in the Conan package. This is "
"very simple and pragmatic and would be recommended for the majority of cases."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:12
msgid ""
"For cases when it is not possible to store the sources beside the Conan "
"recipe, for example when the package is to be consumed for someone that "
"shouldn't have access to the source code at all, then the current **scm "
"capture** method would be the way."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:15
msgid ""
"In the **scm capture** method, instead of capturing a copy of the code "
"itself, the \"coordinates\" for that code are captured instead, in the "
"``Git`` case, the ``url`` of the repository and the ``commit``. If the "
"recipe needs to build from source, it will use that information to get a "
"clone, and if the user who tries that is not authorized, the process will "
"fail. They will still be able to use the pre-compiled binaries that we "
"distribute, but not build from source or have access to the code."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:17
msgid ""
"Let's see how it works with an example. Please, first clone the sources to "
"recreate this project. You can find them in the `examples2 repository "
"<https://github.com/conan-io/examples2>`_ on GitHub:"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:20
msgid ""
"$ git clone https://github.com/conan-io/examples2.git\n"
"$ cd examples2/examples/tools/scm/git/capture_scm"
msgstr ""
"$ git clone https://github.com/conan-io/examples2.git\n"
"$ cd examples2/examples/tools/scm/git/capture_scm"

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:26
msgid ""
"There we will find a small \"hello\" project, containing this ``conanfile."
"py``:"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:28
msgid ""
"from conan import ConanFile\n"
"from conan.tools.cmake import CMake, cmake_layout\n"
"from conan.tools.scm import Git\n"
"\n"
"\n"
"class helloRecipe(ConanFile):\n"
"    name = \"hello\"\n"
"    version = \"0.1\"\n"
"\n"
"    # Binary configuration\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"    options = {\"shared\": [True, False], \"fPIC\": [True, False]}\n"
"    default_options = {\"shared\": False, \"fPIC\": True}\n"
"    generators = \"CMakeDeps\", \"CMakeToolchain\"\n"
"\n"
"    def export(self):\n"
"        git = Git(self, self.recipe_folder)\n"
"        # save the url and commit in conandata.yml\n"
"        git.coordinates_to_conandata()\n"
"\n"
"    def source(self):\n"
"        # we recover the saved url and commit from conandata.yml and use "
"them to get sources\n"
"        git = Git(self)\n"
"        git.checkout_from_conandata_coordinates()\n"
"\n"
"    ..."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:58
msgid ""
"We need this code to be in its own Git repository, to see how it works in "
"the real case, so please create a folder outside of the ``examples2`` "
"repository, and copy the contents of the current folder there, then:"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:61
msgid ""
"$ mkdir /home/myuser/myfolder # or equivalent in other OS\n"
"$ cp -R . /home/myuser/myfolder # or equivalent in other OS\n"
"$ cd /home/myuser/myfolder # or equivalent in other OS\n"
"\n"
"# Initialize the git repo\n"
"$ git init .\n"
"$ git add .\n"
"$ git commit . -m wip\n"
"# Finally create the package\n"
"$ conan create .\n"
"...\n"
"======== Exporting recipe to the cache ========\n"
"hello/0.1: Exporting package recipe: /myfolder/conanfile.py\n"
"hello/0.1: Calling export()\n"
"hello/0.1: RUN: git status . --short --no-branch --untracked-files\n"
"hello/0.1: RUN: git rev-list HEAD -n 1 --full-history -- \".\"\n"
"hello/0.1: RUN: git remote -v\n"
"hello/0.1: RUN: git branch -r --contains "
"cb7815a58529130b49da952362ce8b28117dee53\n"
"hello/0.1: RUN: git fetch origin --dry-run --depth=1 "
"cb7815a58529130b49da952362ce8b28117dee53\n"
"hello/0.1: WARN: Current commit cb7815a58529130b49da952362ce8b28117dee53 "
"doesn't exist in remote origin\n"
"This revision will not be buildable in other computer\n"
"hello/0.1: RUN: git rev-parse --show-toplevel\n"
"hello/0.1: Copied 1 '.py' file: conanfile.py\n"
"hello/0.1: Copied 1 '.yml' file: conandata.yml\n"
"hello/0.1: Exported to cache folder: /.conan2/p/hello237d6f9f65bba/e\n"
"...\n"
"======== Installing packages ========\n"
"hello/0.1: Calling source() in /.conan2/p/hello237d6f9f65bba/s\n"
"hello/0.1: Cloning git repo\n"
"hello/0.1: RUN: git clone \"<hidden>\"  \".\"\n"
"hello/0.1: Checkout: cb7815a58529130b49da952362ce8b28117dee53\n"
"hello/0.1: RUN: git checkout cb7815a58529130b49da952362ce8b28117dee53"
msgstr ""
"$ mkdir /home/myuser/myfolder  # 或其他作業系統中的等效命令\n"
"$ cp -R . /home/myuser/myfolder # 或其他作業系統中的等效命令\n"
"$ cd /home/myuser/myfolder # 或其他作業系統中的等效命令\n"
"\n"
"# 初始化 git 儲存庫\n"
"$ git init .\n"
"$ git add .\n"
"$ git commit . -m wip\n"
"# 最後建立軟體包\n"
"$ conan create .\n"
"...\n"
"======== Exporting recipe to the cache ========\n"
"hello/0.1: Exporting package recipe: /myfolder/conanfile.py\n"
"hello/0.1: Calling export()\n"
"hello/0.1: RUN: git status . --short --no-branch --untracked-files\n"
"hello/0.1: RUN: git rev-list HEAD -n 1 --full-history -- \".\"\n"
"hello/0.1: RUN: git remote -v\n"
"hello/0.1: RUN: git branch -r --contains "
"cb7815a58529130b49da952362ce8b28117dee53\n"
"hello/0.1: RUN: git fetch origin --dry-run --depth=1 "
"cb7815a58529130b49da952362ce8b28117dee53\n"
"hello/0.1: WARN: Current commit cb7815a58529130b49da952362ce8b28117dee53 "
"doesn't exist in remote origin\n"
"This revision will not be buildable in other computer\n"
"hello/0.1: RUN: git rev-parse --show-toplevel\n"
"hello/0.1: Copied 1 '.py' file: conanfile.py\n"
"hello/0.1: Copied 1 '.yml' file: conandata.yml\n"
"hello/0.1: Exported to cache folder: /.conan2/p/hello237d6f9f65bba/e\n"
"...\n"
"======== Installing packages ========\n"
"hello/0.1: Calling source() in /.conan2/p/hello237d6f9f65bba/s\n"
"hello/0.1: Cloning git repo\n"
"hello/0.1: RUN: git clone \"<hidden>\"  \".\"\n"
"hello/0.1: Checkout: cb7815a58529130b49da952362ce8b28117dee53\n"
"hello/0.1: RUN: git checkout cb7815a58529130b49da952362ce8b28117dee53"

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:96
msgid "Let's explain step by step what is happening:"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:98
msgid ""
"When the recipe is exported to the Conan cache, the ``export()`` method "
"executes, ``git.coordinates_to_conandata()``, which stores the Git URL and "
"commit in the ``conandata.yml`` file by internally calling ``git."
"get_url_and_commit()``. See the :ref:`Git reference<conan_tools_scm_git>` "
"for more information about these methods."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:101
msgid ""
"This obtains the URL of the repo pointing to the local ``<local-path>/"
"capture_scm`` and the commit ``8e8764c40bebabbe3ec57f9a0816a2c8e691f559``"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:102
msgid ""
"It warns that this information will **not** be enough to re-build from "
"source this recipe once the package is uploaded to the server and is tried "
"to be built from source in other computer, which will not contain the path "
"pointed by ``<local-path>/capture_scm``. This is expected, as the repository "
"that we created doesn't have any remote defined. If our local clone had a "
"remote defined and that remote contained the ``commit`` that we are "
"building, the ``scm_url`` would point to the remote repository instead, "
"making the build from source fully reproducible."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:103
msgid ""
"The ``export()`` method stores the ``url`` and ``commit`` information in the "
"``conandata.yml`` for future reproducibility."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:104
msgid ""
"When the package needs to be built from sources and it calls the "
"``source()`` method, it recovers the information from the ``conandata.yml`` "
"file inside the ``git.checkout_from_conandata_coordinates()`` method, which "
"internally calls ``git.clone()`` with it to retrieve the sources. In this "
"case, it will be cloning from the local checkout in ``<local-path>/"
"capture_scm``, but if it had a remote defined, it will clone from it."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:112
msgid ""
"To achieve reproducibility, it is very important for this **scm capture** "
"technique that the current checkout is not dirty If it was dirty, it would "
"be impossible to guarantee future reproducibility of the build, so ``git."
"get_url_and_commit()`` can raise errors, and require to commit changes. If "
"more than 1 commit is necessary, it would be recommended to squash those "
"commits before pushing changes to upstream repositories."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:116
msgid ""
"If we do now a second ``conan create .``, as the repo is dirty we would get:"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:118
msgid ""
"$ conan create .\n"
"hello/0.1: Calling export()\n"
"ERROR: hello/0.1: Error in export() method, line 19\n"
"    scm_url, scm_commit = git.get_url_and_commit()\n"
"    ConanException: Repo is dirty, cannot capture url and commit: .../"
"capture_scm"
msgstr ""
"$ conan create .\n"
"hello/0.1: Calling export()\n"
"ERROR: hello/0.1: Error in export() method, line 19\n"
"    scm_url, scm_commit = git.get_url_and_commit()\n"
"    ConanException: Repo is dirty, cannot capture url and commit: .../"
"capture_scm"

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:126
msgid ""
"This could be solved by cleaning the repo with ``git clean -xdf``, or by "
"adding a ``.gitignore`` file to the repo with the following contents (which "
"might be a good practice anyway for source control):"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:129
msgid ".gitignore"
msgstr ".gitignore"

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:129
msgid ""
"test_package/build\n"
"test_package/CMakeUserPresets.json"
msgstr ""
"test_package/build\n"
"test_package/CMakeUserPresets.json"

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:136
msgid ""
"The capture of coordinates uses the ``Git.get_url_and_commit()`` method, "
"that by default does:"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:138
msgid "If the repository is dirty, it will raise an exception"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:139
msgid ""
"If the repository is not dirty, but the commit doesn't exist in the remote, "
"it will warn, but it will return the local folder as repo ``url``. This way, "
"local commits can be tested without needing to push them to the server. The "
"``core.scm:local_url=allow`` can silence the warning and the ``core.scm:"
"local_url=block`` will immediately raise an error: This last value can be "
"useful for CI scenarios, to fail fast and save a build that would have been "
"blocked later in the ``conan upload``."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:143
msgid ""
"Packages built with local commit will fail if trying to upload them to the "
"server with ``conan upload`` as those local commits are not in the server "
"and then the package might not be reproducible. This upload error can be "
"avoided by setting ``core.scm:local_url=allow``."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:145
msgid ""
"If the repository is not dirty, and the commit exists in the server, it will "
"return the remote URL and the commit."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:149
msgid "Credentials management"
msgstr "憑證管理"

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:151
msgid ""
"In the example above, credentials were not necessary, because our local repo "
"didn't require them. But in real world scenarios, the credentials can be "
"required."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:153
msgid ""
"The first important bit is that ``git.get_url_and_commit()`` will capture "
"the url of the ``origin`` remote. This url must not encode tokens, users or "
"passwords, for several reasons. First because that will make the process not "
"repeatable, and different builds, different users would get different urls, "
"and consequently different recipe revisions. The ``url`` should always be "
"the same. The recommended approach is to manage the credentials in an "
"orthogonal way, for example using ssh keys. The provided example contains a "
"Github action that does this:"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:155
msgid ".github/workflows/hello-demo.yml"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:155
msgid ""
"name: Build \"hello\" package capturing SCM in Github actions\n"
"run-name: ${{ github.actor }} checking hello-ci Git scm capture\n"
"on: [push]\n"
"jobs:\n"
"Build:\n"
"    runs-on: ubuntu-latest\n"
"    steps:\n"
"    - name: Check out repository code\n"
"        uses: actions/checkout@v3\n"
"        with:\n"
"        ssh-key: ${{ secrets.SSH_PRIVATE_KEY }}\n"
"    - uses: actions/setup-python@v4\n"
"        with:\n"
"        python-version: '3.10'\n"
"    - uses: webfactory/ssh-agent@v0.7.0\n"
"        with:\n"
"        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}\n"
"    - run: pip install conan\n"
"    - run: conan profile detect\n"
"    - run: conan create ."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:179
msgid "This ``hello-demo.yml`` takes care of the following:"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:181
msgid ""
"The checkout ``actions/checkout@v3`` action receives the ``ssh-key`` to "
"checkout as ``git@`` instead of ``https``"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:182
msgid ""
"The ``webfactory/ssh-agent@v0.7.0`` action takes care that the ssh key is "
"also activated during the execution of the following tasks, not only during "
"the checkout."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:183
msgid ""
"It is necessary to setup the ``SSH_PRIVATE_KEY`` secret in the Github "
"interface, as well as the ``deploy key`` for the repo (with the private and "
"public parts of the ssh-key)"
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:185
msgid ""
"In this way, it is possible to keep completely separated the authentication "
"and credentials from the recipe functionality, without any risk to leaking "
"credentials."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:190
msgid "**Best practices**"
msgstr "**最佳實踐**"

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:192
msgid ""
"Do not use an authentication mechanism that encodes information in the urls. "
"This is risky, can easily disclose credentials in logs. It is recommended to "
"use system mechanisms like ssh keys."
msgstr ""

#: ../../../examples/tools/scm/git/capture_scm/git_capture_scm.rst:193
msgid ""
"Doing ``conan create`` is not recommended for local development, but instead "
"running ``conan install`` and building locally, to avoid too many "
"unnecessary commits. Only when everything works locally, it is time to start "
"checking the ``conan create`` flow."
msgstr ""
