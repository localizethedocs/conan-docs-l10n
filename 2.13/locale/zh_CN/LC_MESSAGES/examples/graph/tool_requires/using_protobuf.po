# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2024, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 2.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 14:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../examples/graph/tool_requires/using_protobuf.rst:4
msgid "Using the same requirement as a requires and as a tool_requires"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:6
msgid ""
"There are libraries which could behave as a library and as a tool "
"requirement, e.g., `protobuf <https://github.com/conan-io/conan-center-index/"
"tree/master/recipes/protobuf>`__ Those libraries normally contains headers/"
"sources of the library itself, and, perhaps, some extra tools (compilers, "
"shell scripts, etc.). Both parts are used in different contexts, let's think "
"of this scenario using *protobuf* for instance:"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:11
msgid ""
"I want to create a library which includes a compiled protobuf message. The "
"protobuf compiler (build context) needs to be invoked at build time, and the "
"library with the compiled *.pb.cc* file needs to be linked against the "
"protobuf library (host context)."
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:16
msgid ""
"Given that, we should be able to use protobuf in build/host context in the "
"same Conan recipe. Basically, your package recipe should look like:"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:19
msgid ""
"def requirements(self):\n"
"    self.requires(\"protobuf/3.18.1\")\n"
"\n"
"def build_requirements(self):\n"
"    self.tool_requires(\"protobuf/<host_version>\")"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:29
msgid ""
"The ``protobuf/<host_version>`` expression ensures that the same version of "
"the library is used in both contexts. You can read more about it :ref:"
"`here<reference_conanfile_build_requirements_host_version>`."
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:33
msgid ""
"This is the way to proceed with any other library used in both contexts. "
"Nonetheless, let's see a detailed example to see how the example looks like."
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:36
msgid ""
"Please, first clone the sources to recreate this project. You can find them "
"in the `examples2 repository <https://github.com/conan-io/examples2>`_ on "
"GitHub:"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:39
msgid ""
"git clone https://github.com/conan-io/examples2.git\n"
"cd examples2/examples/graph/tool_requires/using_protobuf/myaddresser"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:45
msgid "The structure of the project is the following:"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:47
msgid ""
"./\n"
"├── conanfile.py\n"
"├── CMakeLists.txt\n"
"├── addressbook.proto\n"
"├── apple-arch-armv8\n"
"├── apple-arch-x86_64\n"
"└── src\n"
"   └── myaddresser.cpp\n"
"└── include\n"
"   └── myaddresser.h\n"
"└── test_package\n"
"   ├── conanfile.py\n"
"   ├── CMakeLists.txt\n"
"   └── src\n"
"       └── example.cpp"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:66
msgid "The ``conanfile.py`` looks like:"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:68
msgid "./conanfile.py"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:68
msgid ""
"from conan import ConanFile\n"
"from conan.tools.cmake import CMake, cmake_layout\n"
"\n"
"\n"
"class myaddresserRecipe(ConanFile):\n"
"    name = \"myaddresser\"\n"
"    version = \"1.0\"\n"
"    package_type = \"library\"\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"    options = {\"shared\": [True, False], \"fPIC\": [True, False]}\n"
"    default_options = {\"shared\": False, \"fPIC\": True}\n"
"    generators = \"CMakeDeps\", \"CMakeToolchain\"\n"
"    # Sources are located in the same place as this recipe, copy them to the "
"recipe\n"
"    exports_sources = \"CMakeLists.txt\", \"src/*\", \"include/*\", "
"\"addressbook.proto\"\n"
"\n"
"    def config_options(self):\n"
"        if self.settings.os == \"Windows\":\n"
"            self.options.rm_safe(\"fPIC\")\n"
"\n"
"    def configure(self):\n"
"        if self.options.shared:\n"
"            self.options.rm_safe(\"fPIC\")\n"
"\n"
"    def requirements(self):\n"
"        self.requires(\"protobuf/3.18.1\")\n"
"\n"
"    def build_requirements(self):\n"
"        self.tool_requires(\"protobuf/<host_version>\")\n"
"\n"
"    def layout(self):\n"
"        cmake_layout(self)\n"
"\n"
"    def build(self):\n"
"        cmake = CMake(self)\n"
"        cmake.configure()\n"
"        cmake.build()\n"
"\n"
"    def package(self):\n"
"        cmake = CMake(self)\n"
"        cmake.install()\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.libs = [\"myaddresser\"]\n"
"        self.cpp_info.requires = [\"protobuf::libprotobuf\"]"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:116
msgid ""
"As you can see, we're using *protobuf* at the same time but in different "
"contexts."
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:118
msgid ""
"The ``CMakeLists.txt`` shows how this example uses protobuf compiler and "
"library:"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:120
msgid "./CMakeLists.txt"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:120
msgid ""
"cmake_minimum_required(VERSION 3.15)\n"
"project(myaddresser LANGUAGES CXX)\n"
"\n"
"find_package(protobuf CONFIG REQUIRED)\n"
"\n"
"protobuf_generate_cpp(PROTO_SRCS PROTO_HDRS addressbook.proto)\n"
"\n"
"add_library(myaddresser src/myaddresser.cpp ${PROTO_SRCS})\n"
"target_include_directories(myaddresser PUBLIC include)\n"
"\n"
"target_include_directories(myaddresser PUBLIC\n"
"  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>\n"
"  $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}>\n"
"  $<INSTALL_INTERFACE:include>\n"
")\n"
"\n"
"target_link_libraries(myaddresser PUBLIC protobuf::libprotobuf)\n"
"\n"
"set_target_properties(myaddresser PROPERTIES PUBLIC_HEADER \"include/"
"myaddresser.h;${PROTO_HDRS}\")\n"
"install(TARGETS myaddresser)"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:145
msgid ""
"Where the library itself defines a simple *myaddresser.cpp* which uses the "
"generated *addressbook.pb.h* header:"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:147
msgid "./src/myaddresser.cpp"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:147
msgid ""
"#include <iostream>\n"
"#include <fstream>\n"
"#include <string>\n"
"#include \"addressbook.pb.h\"\n"
"#include \"myaddresser.h\"\n"
"\n"
"void myaddresser(){\n"
"  // Testing header generated by protobuf\n"
"  GOOGLE_PROTOBUF_VERIFY_VERSION;\n"
"\n"
"  tutorial::AddressBook address_book;\n"
"  auto * person = address_book.add_people();\n"
"  person->set_id(1337);\n"
"  std::cout << \"myaddresser(): created a person with id 1337\\n\";\n"
"  // Optional:  Delete all global objects allocated by libprotobuf.\n"
"  google::protobuf::ShutdownProtobufLibrary();\n"
"}"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:168
msgid ""
"Finally, the *test_package* example simply calls the ``myaddresser()`` "
"function to check that everything works correctly:"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:170
msgid "./test_package/src/example.cpp"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:170
msgid ""
"#include <iostream>\n"
"#include <fstream>\n"
"#include <string>\n"
"#include \"myaddresser.h\"\n"
"\n"
"\n"
"int main(int argc, char* argv[]) {\n"
"  myaddresser();\n"
"  return 0;\n"
"}"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:185
msgid "So, let's see if it works fine:"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:187
msgid ""
"$ conan create . --build missing\n"
"...\n"
"\n"
"Requirements\n"
"    myaddresser/1.0#71305099cc4dc0b08bb532d4f9196ac1:"
"c4e35584cc696eb5dd8370a2a6d920fb2a156438 - Build\n"
"    protobuf/3.18.1#ac69396cd9fbb796b5b1fc16473ca354:"
"e60fa1e7fc3000cc7be2a50a507800815e3f45e0#0af7d905b0df3225a3a56243841e041b - "
"Cache\n"
"    zlib/1.2.13#13c96f538b52e1600c40b88994de240f:"
"d0599452a426a161e02a297c6e0c5070f99b4909#69b9ece1cce8bc302b69159b4d437acd - "
"Cache\n"
"Build requirements\n"
"    protobuf/3.18.1#ac69396cd9fbb796b5b1fc16473ca354:"
"e60fa1e7fc3000cc7be2a50a507800815e3f45e0#0af7d905b0df3225a3a56243841e041b - "
"Cache\n"
"...\n"
"\n"
"-- Install configuration: \"Release\"\n"
"-- Installing: /Users/myuser/.conan2/p/b/myser03f790a5a5533/p/lib/"
"libmyaddresser.a\n"
"-- Installing: /Users/myuser/.conan2/p/b/myser03f790a5a5533/p/include/"
"myaddresser.h\n"
"-- Installing: /Users/myuser/.conan2/p/b/myser03f790a5a5533/p/include/"
"addressbook.pb.h\n"
"\n"
"myaddresser/1.0: package(): Packaged 2 '.h' files: myaddresser.h, "
"addressbook.pb.h\n"
"myaddresser/1.0: package(): Packaged 1 '.a' file: libmyaddresser.a\n"
"....\n"
"\n"
"======== Testing the package: Executing test ========\n"
"myaddresser/1.0 (test package): Running test()\n"
"myaddresser/1.0 (test package): RUN: ./example\n"
"myaddresser(): created a person with id 1337"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:215
msgid ""
"After seeing it's running OK, let's try to use cross-building. Notice that "
"this part is based on MacOS Intel systems, and cross-compiling for MacOS ARM "
"ones, but you could use your own profiles depending on your needs for sure."
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:220
msgid "MacOS system is required to run this part of the example."
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:223
msgid ""
"$ conan create . --build missing -pr:b apple-arch-x86_64 -pr:h apple-arch-"
"armv8\n"
"...\n"
"\n"
"-- Install configuration: \"Release\"\n"
"-- Installing: /Users/myuser/.conan2/p/b/myser03f790a5a5533/p/lib/"
"libmyaddresser.a\n"
"-- Installing: /Users/myuser/.conan2/p/b/myser03f790a5a5533/p/include/"
"myaddresser.h\n"
"-- Installing: /Users/myuser/.conan2/p/b/myser03f790a5a5533/p/include/"
"addressbook.pb.h\n"
"\n"
"myaddresser/1.0: package(): Packaged 2 '.h' files: myaddresser.h, "
"addressbook.pb.h\n"
"myaddresser/1.0: package(): Packaged 1 '.a' file: libmyaddresser.a\n"
"....\n"
"\n"
"======== Testing the package: Executing test ========\n"
"myaddresser/1.0 (test package): Running test()"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:241
msgid ""
"Now, we cannot see the example running because of the host architecture. If "
"we want to check that the *example* executable is built for the correct one:"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:244
msgid ""
"$ file test_package/build/apple-clang-13.0-armv8-gnu17-release/example\n"
"test_package/build/apple-clang-13.0-armv8-gnu17-release/example: Mach-O 64-"
"bit executable arm64"
msgstr ""

#: ../../../examples/graph/tool_requires/using_protobuf.rst:249
msgid ""
"Everything works as expected, and the executable was built for 64-bit "
"executable arm64 architectures."
msgstr ""
