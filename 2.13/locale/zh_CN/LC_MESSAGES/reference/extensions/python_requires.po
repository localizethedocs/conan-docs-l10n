# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2024, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 2.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 14:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../reference/extensions/python_requires.rst:4
msgid "Python requires"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:8
msgid "Introduction"
msgstr "简介"

#: ../../../reference/extensions/python_requires.rst:10
msgid ""
"The ``python_requires`` feature is a very convenient way to share files and "
"code between different recipes. A python require is a special recipe that "
"does not create packages and it is just intended to be reused by other "
"recipes."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:14
msgid "A very simple recipe that we want to reuse could be:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:16
msgid ""
"from conan import ConanFile\n"
"\n"
"myvar = 123\n"
"\n"
"def myfunct():\n"
"    return 234\n"
"\n"
"class Pkg(ConanFile):\n"
"    name = \"pyreq\"\n"
"    version = \"0.1\"\n"
"    package_type = \"python-require\""
msgstr ""

#: ../../../reference/extensions/python_requires.rst:31
msgid ""
"And then we will make it available to other packages with ``conan create ."
"``. Note that a ``python-require`` package does not create binaries, it is "
"just the recipe part."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:34
msgid ""
"$ conan create .\n"
"# It will only export the recipe, but will NOT create binaries\n"
"# python-requires do NOT have binaries"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:41
msgid ""
"We can reuse the above recipe functionality declaring the dependency in the "
"``python_requires`` attribute and we can access its members using ``self."
"python_requires[\"<name>\"].module``:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:44
msgid ""
"from conan import ConanFile\n"
"\n"
"class Pkg(ConanFile):\n"
"    name = \"pkg\"\n"
"    version = \"0.1\"\n"
"    python_requires = \"pyreq/0.1\"\n"
"\n"
"    def build(self):\n"
"        v = self.python_requires[\"pyreq\"].module.myvar  # v will be 123\n"
"        f = self.python_requires[\"pyreq\"].module.myfunct()  # f will be "
"234\n"
"        self.output.info(f\"{v}, {f}\")"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:59
msgid ""
"$ conan create .\n"
"...\n"
"pkg/0.1: 123, 234"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:66
msgid ""
"Python requires can also use version ranges, and this can be recommended in "
"many cases if those ``python-requires`` need to evolve over time:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:69
msgid ""
"from conan import ConanFile\n"
"\n"
"class Pkg(ConanFile):\n"
"    python_requires = \"pyreq/[>=1.0 <2]\""
msgstr ""

#: ../../../reference/extensions/python_requires.rst:77
msgid ""
"It is also possible to require more than 1 ``python-requires`` with "
"``python_requires = \"pyreq/0.1\", \"other/1.2\"``"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:80
msgid "Extending base classes"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:82
msgid ""
"A common use case would be to declare a base class with methods we want to "
"reuse in several recipes via inheritance. We'd write this base class in a "
"python-requires package:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:85
msgid ""
"from conan import ConanFile\n"
"\n"
"class MyBase:\n"
"    def source(self):\n"
"        self.output.info(\"My cool source!\")\n"
"    def build(self):\n"
"        self.output.info(\"My cool build!\")\n"
"    def package(self):\n"
"        self.output.info(\"My cool package!\")\n"
"    def package_info(self):\n"
"        self.output.info(\"My cool package_info!\")\n"
"\n"
"class PyReq(ConanFile):\n"
"    name = \"pyreq\"\n"
"    version = \"0.1\"\n"
"    package_type = \"python-require\""
msgstr ""

#: ../../../reference/extensions/python_requires.rst:105
msgid "And make it available for reuse with:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:107
msgid "$ conan create ."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:112
msgid "Note that there are two classes in the recipe file:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:114
msgid ""
"``MyBase`` is the one intended for inheritance and doesn't extend "
"``ConanFile``."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:115
msgid ""
"``PyReq`` is the one that defines the current package being exported, it is "
"the recipe for the reference ``pyreq/0.1``."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:119
msgid ""
"Once the package with the base class we want to reuse is available we can "
"use it in other recipes to inherit the functionality from that base class. "
"We'd need to declare the ``python_requires`` as we did before and we'd need "
"to tell Conan the base classes to use in the attribute "
"``python_requires_extend``. Here our recipe will inherit from the class "
"``MyBase``:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:126
msgid ""
"from conan import ConanFile\n"
"\n"
"class Pkg(ConanFile):\n"
"    name = \"pkg\"\n"
"    version = \"0.1\"\n"
"    python_requires = \"pyreq/0.1\"\n"
"    python_requires_extend = \"pyreq.MyBase\""
msgstr ""

#: ../../../reference/extensions/python_requires.rst:137
msgid ""
"The resulting inheritance is equivalent to declare our ``Pkg`` class as "
"``class Pkg(pyreq.MyBase, ConanFile)``. So creating the package we can see "
"how the methods from the base class are reused:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:140
msgid ""
"$ conan create .\n"
"...\n"
"pkg/0.1: My cool source!\n"
"pkg/0.1: My cool build!\n"
"pkg/0.1: My cool package!\n"
"pkg/0.1: My cool package_info!\n"
"..."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:151
msgid ""
"In general, base class attributes are not inherited, and should be avoided "
"as much as possible. There are method alternatives to some of them like "
"``export()`` or ``set_version()``. For exceptional situations, see the "
"``init()`` method documentation for more information to extend inherited "
"attributes."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:155
msgid ""
"It is possible to re-implement some of the base class methods, and also to "
"call the base class method explicitly, with the Python ``super()`` syntax:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:158
msgid ""
"from conan import ConanFile\n"
"\n"
"class Pkg(ConanFile):\n"
"    name = \"pkg\"\n"
"    version = \"0.1\"\n"
"    python_requires = \"pyreq/0.1\"\n"
"    python_requires_extend = \"pyreq.MyBase\"\n"
"\n"
"    def source(self):\n"
"        super().source()  # call the base class method\n"
"        self.output.info(\"MY OWN SOURCE\") # Your own implementation"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:172
msgid ""
"It is not mandatory to call the base class method, a full overwrite without "
"calling ``super()`` is possible. Also the call order can be changed, and "
"calling your own code, then ``super()`` is possible."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:176
msgid "Reusing files"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:178
msgid ""
"It is possible to access the files exported by a recipe that is used with "
"``python_requires``. We could have this recipe, together with a *myfile.txt* "
"file containing the \"Hello\" text."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:181
msgid ""
"from conan import ConanFile\n"
"\n"
"class PyReq(ConanFile):\n"
"    name = \"pyreq\"\n"
"    version = \"1.0\"\n"
"    package_type = \"python-require\"\n"
"    exports = \"*\""
msgstr ""

#: ../../../reference/extensions/python_requires.rst:192
msgid ""
"$ echo \"Hello\" > myfile.txt\n"
"$ conan create ."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:198
msgid ""
"Now that the python-require has been created, we can access its path (the "
"place where *myfile.txt* is) with the ``path`` attribute:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:201
msgid ""
"import os\n"
"\n"
"from conan import ConanFile\n"
"from conan.tools.files import load\n"
"\n"
"class Pkg(ConanFile):\n"
"    python_requires = \"pyreq/0.1\"\n"
"\n"
"    def build(self):\n"
"        pyreq_path = self.python_requires[\"pyreq\"].path\n"
"        myfile_path = os.path.join(pyreq_path, \"myfile.txt\")\n"
"        content = load(self, myfile_path)  # content = \"Hello\"\n"
"        self.output.info(content)\n"
"        # we could also copy the file, instead of reading it"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:219
msgid ""
"Note that only ``exports`` works for this case, but not ``exports_sources``."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:223
msgid "Testing python-requires"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:225
msgid ""
"It is possible to test with ``test_package`` a ``python_require``, by adding "
"a ``test_package/conanfile.py``:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:227
msgid "conanfile.py"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:227
msgid ""
"from conan import ConanFile\n"
"\n"
"def mynumber():\n"
"    return 42\n"
"\n"
"class PyReq(ConanFile):\n"
"    name = \"pyreq\"\n"
"    version = \"1.0\"\n"
"    package_type = \"python-require\""
msgstr ""

#: ../../../reference/extensions/python_requires.rst:241
msgid "test_package/conanfile.py"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:241
msgid ""
"from conan import ConanFile\n"
"\n"
"class Tool(ConanFile):\n"
"\n"
"    # Literal \"tested_reference_str\", Conan will dynamically replace it\n"
"    python_requires = \"tested_reference_str\"\n"
"\n"
"    def test(self):\n"
"        pyreq = self.python_requires[\"pyreq\"].module\n"
"        mynumber = pyreq.mynumber()\n"
"        self.output.info(\"{}!!!\".format(mynumber))"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:257
msgid ""
"The ``python_requires = \"tested_reference_str\"`` is mandatory from Conan "
"2.1. Automatic injection of ``python_requires`` without this declaration is "
"deprecated and it will be removed in future versions."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:260
msgid ""
"Note that the ``test_package/conanfile.py`` does not need any type of "
"declaration of the ``python_requires``, this is done automatically and "
"implicitly. We can now create and test it with:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:263
msgid ""
"$ conan create .\n"
"...\n"
"pyreq/0.1 (test package): 42!!!"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:271
msgid "Effect in package_id"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:273
msgid ""
"The ``python_requires`` will affect the ``package_id`` of the **consumer "
"packages** using those dependencies. By default, the policy is "
"``minor_mode``, which means:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:276
msgid ""
"Changes to the **patch** version of the **revision** of a python-require "
"will not affect the package ID. So depending on ``\"pyreq/1.2.3\"`` or "
"``\"pyreq/1.2.4\"`` will result in identical package ID (both will be mapped "
"to ``\"pyreq/1.2.Z\"`` in the hash computation). Bump the patch version if "
"you want to change your common code, but you don't want the consumers to be "
"affected or to fire a re-build of the dependants."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:280
msgid ""
"Changes to the **minor** version will produce a different package ID. So if "
"you depend on ``\"pyreq/1.2.3\"``, and you bump the version to "
"``\"pyreq/1.3.0\"``, then, you will need to build new binaries that are "
"using that new python-require. Bump the minor or major version if you want "
"to make sure that packages requiring this python-require will be built using "
"these changes in the code."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:285
msgid ""
"In most cases using a version-range ``python_requires = \"pyreq/[>=1.0 "
"<2.0]\"`` is the right approach, because that means the **major** version "
"bumps are not included because they would require changes in the consumers "
"themselves. It is then possible to release a new major version of the "
"``pyreq/2.0``, and have consumers gradually change their requirements to "
"``python_requires = \"pyreq/[>=2.0 <3.0]\"``, fix the recipes, and move "
"forward without breaking the whole project."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:290
msgid ""
"As with the regular ``requires``, this default can be customized with the "
"``core.package_id:default_python_mode`` configuration."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:292
msgid ""
"It is also possible to customize the effect of ``python_requires`` per "
"package, using the ``package_id()`` method:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:295
msgid ""
"from conan import ConanFile\n"
"\n"
"class Pkg(ConanFile):\n"
"    python_requires =\"pyreq/[>=1.0]\"\n"
"    def package_id(self):\n"
"        self.info.python_requires.patch_mode()"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:307
msgid "Resolution of python_requires"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:309
msgid ""
"There are few important things that should be taken into account when using "
"``python_requires``:"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:311
msgid ""
"Python requires recipes are loaded by the interpreter just once, and they "
"are common to all consumers. Do not use any global state in the "
"``python_requires`` recipes."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:313
msgid ""
"Python requires are private to the consumers. They are not transitive. "
"Different consumers can require different versions of the same ``python-"
"require``. Being private, they cannot be overridden from downstream in any "
"way."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:316
msgid ""
"``python_requires`` cannot use regular ``requires`` or ``tool_requires`` "
"themselves. Having a ``requirements()`` (and similar) methods to be "
"inherited by recipes is possible and allowed, but the ``python_requires`` "
"class itself cannot use them."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:318
msgid "``python_requires`` cannot be \"aliased\"."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:319
msgid ""
"``python_requires`` can use native python ``import`` to other python files, "
"as long as these are exported together with the recipe."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:321
msgid "``python_requires`` can be used as editable packages too."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:322
msgid ""
"``python_requires`` are locked in lockfiles, to guarantee reproducibility, "
"in the same way that other ``requires`` and ``tool_requires`` are locked."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:327
msgid "**Best practices**"
msgstr ""

#: ../../../reference/extensions/python_requires.rst:329
msgid ""
"Even if ``python-requires`` can ``python_requires`` transitively other "
"``python-requires`` recipes, this is discouraged. Multiple level inheritance "
"and reuse can become quite complex and difficult to manage, it is "
"recommended to keep the hierarchy flat."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:330
msgid ""
"Do not try to mix Python inheritance with ``python_requires_extend`` "
"inheritance mechanisms, they are incompatible and can break."
msgstr ""

#: ../../../reference/extensions/python_requires.rst:331
msgid "Do not use multiple inheritance for ``python-requires``"
msgstr ""
