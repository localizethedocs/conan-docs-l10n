# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2024, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 2.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 14:33+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../reference/tools/cmake/cmakedeps.rst:4
msgid "CMakeDeps"
msgstr "CMakeDeps"

#: ../../../reference/tools/cmake/cmakedeps.rst:7
msgid ""
"The ``CMakeDeps`` generator produces the necessary files for each dependency "
"to be able to use the cmake ``find_package()`` function to locate the "
"dependencies. It can be used like:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:11
msgid ""
"from conan import ConanFile\n"
"\n"
"class App(ConanFile):\n"
"    settings = \"os\", \"arch\", \"compiler\", \"build_type\"\n"
"    requires = \"hello/0.1\"\n"
"    generators = \"CMakeDeps\""
msgstr ""
"from conan import ConanFile\n"
"\n"
"class App(ConanFile):\n"
"    settings = \"os\", \"arch\", \"compiler\", \"build_type\"\n"
"    requires = \"hello/0.1\"\n"
"    generators = \"CMakeDeps\""

#: ../../../reference/tools/cmake/cmakedeps.rst:21
msgid ""
"The full instantiation, that allows custom configuration can be done in the "
"``generate()`` method:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:24
msgid ""
"from conan import ConanFile\n"
"from conan.tools.cmake import CMakeDeps\n"
"\n"
"class App(ConanFile):\n"
"    settings = \"os\", \"arch\", \"compiler\", \"build_type\"\n"
"    requires = \"hello/0.1\"\n"
"\n"
"    def generate(self):\n"
"        cmake = CMakeDeps(self)\n"
"        cmake.generate()"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:38
msgid "**CMakeLists.txt**"
msgstr "**CMakeLists.txt**"

#: ../../../reference/tools/cmake/cmakedeps.rst:38
msgid ""
"cmake_minimum_required(VERSION 3.15)\n"
"project(compressor C)\n"
"\n"
"find_package(hello REQUIRED)\n"
"\n"
"add_executable(${PROJECT_NAME} src/main.c)\n"
"target_link_libraries(${PROJECT_NAME} hello::hello)"
msgstr ""
"cmake_minimum_required(VERSION 3.15)\n"
"project(compressor C)\n"
"\n"
"find_package(hello REQUIRED)\n"
"\n"
"add_executable(${PROJECT_NAME} src/main.c)\n"
"target_link_libraries(${PROJECT_NAME} hello::hello)"

#: ../../../reference/tools/cmake/cmakedeps.rst:51
msgid ""
"By default, for a ``hello`` requires, you need to use "
"``find_package(hello)`` and link with the target ``hello::hello``. Check :"
"ref:`the properties affecting CMakeDeps<CMakeDeps Properties>` like "
"``cmake_target_name`` to customize the file and the target names in the "
"conanfile.py of the dependencies and their components."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:58
msgid ""
"The ``CMakeDeps`` is intended to run with the ``CMakeToolchain`` generator. "
"It will set ``CMAKE_PREFIX_PATH`` and ``CMAKE_MODULE_PATH`` to the right "
"folder (``conanfile.generators_folder``) so CMake can locate the generated "
"config/module files."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:63
msgid "Generated files"
msgstr "生成的檔案"

#: ../../../reference/tools/cmake/cmakedeps.rst:65
msgid ""
"**XXX-config.cmake**: By default, the CMakeDeps generator will create config "
"files declaring the targets for the dependencies and their components (if "
"declared)."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:68
msgid ""
"**FindXXX.cmake**: Only when the property ``cmake_find_mode`` is set by the "
"dependency with \"module\" or \"both\". See :ref:`The properties affecting "
"CMakeDeps<CMakeDeps Properties>` is set in the dependency."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:70
msgid ""
"**Other necessary *.cmake**:  files like version, flags and directory data "
"or configuration."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:73
msgid ""
"Note that it will also generate a **conandeps_legacy.cmake** file. This is a "
"file that provides a behavior similar to the Conan 1 ``cmake`` generator, "
"allowing to include this file with ``include(${CMAKE_BINARY_DIR}/generators/"
"conandeps_legacy.cmake)``, and providing a single CMake ``CONANDEPS_LEGACY`` "
"variable that allows to link with all the direct and transitive dependencies "
"without explicitly enumerating them like: ``target_link_libraries(app "
"${CONANDEPS_LEGACY})``. This is a convenience provided for Conan 1.X users "
"to upgrade to Conan 2 without changing their overall developer flow, but it "
"is not recommended otherwise, and using the CMake canonical flow of "
"explicitly using ``find_package()`` and ``target_link_libraries(... pkg1::"
"pkg1 pkg2::pkg2)`` with targets is the correct approach."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:77
msgid "Customization"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:79
msgid ""
"There are some attributes you can adjust in the created ``CMakeDeps`` object "
"to change the default behavior:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:82
msgid "configuration"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:84
msgid ""
"Allows to define custom user CMake configuration besides the standard "
"Release, Debug, etc ones."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:86
msgid ""
"def generate(self):\n"
"    deps = CMakeDeps(self)\n"
"    # By default, ``deps.configuration`` will be ``self.settings."
"build_type``\n"
"    if self.options[\"hello\"].shared:\n"
"        # Assuming the current project ``CMakeLists.txt`` defines the "
"ReleasedShared configuration.\n"
"        deps.configuration = \"ReleaseShared\"\n"
"    deps.generate()"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:97
msgid ""
"The ``CMakeDeps`` is a *multi-configuration* generator, it can correctly "
"create files for Release/Debug configurations to be simultaneously used by "
"IDEs like Visual Studio. In single configuration environments, it is "
"necessary to have a configuration defined, which must be provided via the "
"``cmake ... -DCMAKE_BUILD_TYPE=<build-type>`` argument in command line "
"(Conan will do it automatically when necessary, in the ``CMake.configure()`` "
"helper)."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:104
msgid "build_context_activated"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:106
msgid ""
"When you have a **build-require**, by default, the config files (`xxx-config."
"cmake`) files are not generated. But you can activate it using the "
"**build_context_activated** attribute:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:109
msgid ""
"tool_requires = [\"my_tool/0.0.1\"]\n"
"\n"
"def generate(self):\n"
"    cmake = CMakeDeps(self)\n"
"    # generate the config files for the tool require\n"
"    cmake.build_context_activated = [\"my_tool\"]\n"
"    cmake.generate()"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:121
msgid "build_context_suffix"
msgstr "build_context_suffix"

#: ../../../reference/tools/cmake/cmakedeps.rst:123
msgid ""
"When you have the same package as a **build-require** and as a **regular "
"require** it will cause a conflict in the generator because the file names "
"of the config files will collide as well as the targets names, variables "
"names etc."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:126
msgid ""
"For example, this is a typical situation with some requirements (capnproto, "
"protobuf...) that contain a tool used to generate source code at build time "
"(so it is a **build_require**), but also providing a library to link to the "
"final application, so you also have a **regular require**. Solving this "
"conflict is specially important when we are cross-building because the tool "
"(that will run in the building machine) belongs to a different binary "
"package than the library, that will \"run\" in the host machine."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:133
msgid ""
"You can use the **build_context_suffix** attribute to specify a suffix for a "
"requirement, so the files/targets/variables of the requirement in the build "
"context (tool require) will be renamed:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:136
msgid ""
"tool_requires = [\"my_tool/0.0.1\"]\n"
"requires = [\"my_tool/0.0.1\"]\n"
"\n"
"def generate(self):\n"
"    cmake = CMakeDeps(self)\n"
"    # generate the config files for the tool require\n"
"    cmake.build_context_activated = [\"my_tool\"]\n"
"    # disambiguate the files, targets, etc\n"
"    cmake.build_context_suffix = {\"my_tool\": \"_BUILD\"}\n"
"    cmake.generate()"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:152
msgid "build_context_build_modules"
msgstr "build_context_build_modules"

#: ../../../reference/tools/cmake/cmakedeps.rst:154
msgid ""
"Also there is another issue with the **build_modules**. As you may know, the "
"recipes of the requirements can declare a `cppinfo.build_modules` entry "
"containing one or more **.cmake** files. When the requirement is found by "
"the cmake ``find_package()`` function, Conan will include automatically "
"these files."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:159
msgid ""
"By default, Conan will include only the build modules from the ``host`` "
"context (regular requires) to avoid the collision, but you can change the "
"default behavior."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:162
msgid ""
"Use the **build_context_build_modules** attribute to specify require names "
"to include the **build_modules** from **tool_requires**:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:165
msgid ""
"tool_requires = [\"my_tool/0.0.1\"]\n"
"\n"
"def generate(self):\n"
"    cmake = CMakeDeps(self)\n"
"    # generate the config files for the tool require\n"
"    cmake.build_context_activated = [\"my_tool\"]\n"
"    # Choose the build modules from \"build\" context\n"
"    cmake.build_context_build_modules = [\"my_tool\"]\n"
"    cmake.generate()"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:180
msgid "check_components_exist"
msgstr "check_components_exist"

#: ../../../reference/tools/cmake/cmakedeps.rst:184
msgid ""
"The ``check_components_exist`` attribute is **experimental** and subject to "
"change."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:187
msgid ""
"This property is ``False`` by default. Use this property if you want to add "
"a check when you require specifying components in the consumers' "
"``find_package()``. For example, if we are consuming a Conan package like "
"Boost that declares several components. If we set the attribute to ``True``, "
"the ``find_package()`` call of the consumer, will check that the required "
"components exist and raise an error otherwise. You can set this attribute in "
"the ``generate()`` method:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:194
msgid ""
"requires = \"boost/1.81.0\"\n"
"\n"
"...\n"
"\n"
"def generate(self):\n"
"    deps = CMakeDeps(self)\n"
"    deps.check_components_exist = True\n"
"    deps.generate()"
msgstr ""
"requires = \"boost/1.81.0\"\n"
"\n"
"...\n"
"\n"
"def generate(self):\n"
"    deps = CMakeDeps(self)\n"
"    deps.check_components_exist = True\n"
"    deps.generate()"

#: ../../../reference/tools/cmake/cmakedeps.rst:205
msgid ""
"Then, when consuming Boost the ``find_package()`` will raise an error as "
"`fakecomp` does not exist:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:208
msgid ""
"cmake_minimum_required(VERSION 3.15)\n"
"...\n"
"find_package(Boost COMPONENTS random regex fakecomp REQUIRED)\n"
"..."
msgstr ""
"cmake_minimum_required(VERSION 3.15)\n"
"...\n"
"find_package(Boost COMPONENTS random regex fakecomp REQUIRED)\n"
"..."

#: ../../../reference/tools/cmake/cmakedeps.rst:217
msgid "Reference"
msgstr ""

#: ../../../conan_sources/conan/tools/cmake/cmakedeps/cmakedeps.py:docstring of
#: conan.tools.cmake.cmakedeps.cmakedeps.CMakeDeps.generate:1
msgid ""
"This method will save the generated files to the conanfile.generators_folder"
msgstr ""

#: ../../../conan_sources/conan/tools/cmake/cmakedeps/cmakedeps.py:docstring of
#: conan.tools.cmake.cmakedeps.cmakedeps.CMakeDeps.set_property:1
msgid ""
"Using this method you can overwrite the :ref:`property<CMakeDeps "
"Properties>` values set by the Conan recipes from the consumer. This can be "
"done for `cmake_file_name`, `cmake_target_name`, `cmake_find_mode`, "
"`cmake_module_file_name` and `cmake_module_target_name` properties."
msgstr ""

#: ../../../conan_sources/conan/tools/cmake/cmakedeps/cmakedeps.py:docstring of
#: conan.tools.cmake.cmakedeps.cmakedeps.CMakeDeps.get_find_mode:0
#: conan.tools.cmake.cmakedeps.cmakedeps.CMakeDeps.set_property:0
msgid "Parameters"
msgstr "參數"

#: ../../../conan_sources/conan/tools/cmake/cmakedeps/cmakedeps.py:docstring of
#: conan.tools.cmake.cmakedeps.cmakedeps.CMakeDeps.set_property:5
msgid ""
"Name of the dependency to set the :ref:`property<CMakeDeps Properties>`. For "
"components use the syntax: ``dep_name::component_name``."
msgstr ""

#: ../../../conan_sources/conan/tools/cmake/cmakedeps/cmakedeps.py:docstring of
#: conan.tools.cmake.cmakedeps.cmakedeps.CMakeDeps.set_property:7
msgid "Name of the :ref:`property<CMakeDeps Properties>`."
msgstr ""

#: ../../../conan_sources/conan/tools/cmake/cmakedeps/cmakedeps.py:docstring of
#: conan.tools.cmake.cmakedeps.cmakedeps.CMakeDeps.set_property:8
msgid ""
"Value of the property. Use ``None`` to invalidate any value set by the "
"upstream recipe."
msgstr ""

#: ../../../conan_sources/conan/tools/cmake/cmakedeps/cmakedeps.py:docstring of
#: conan.tools.cmake.cmakedeps.cmakedeps.CMakeDeps.set_property:10
msgid ""
"Set to ``True`` if you want to set the property for a dependency that "
"belongs to the build context (``False`` by default)."
msgstr ""

#: ../../../conan_sources/conan/tools/cmake/cmakedeps/cmakedeps.py:docstring of
#: conan.tools.cmake.cmakedeps.cmakedeps.CMakeDeps.get_cmake_package_name:1
msgid "Get the name of the file for the find_package(XXX)"
msgstr ""

#: ../../../conan_sources/conan/tools/cmake/cmakedeps/cmakedeps.py:docstring of
#: conan.tools.cmake.cmakedeps.cmakedeps.CMakeDeps.get_find_mode:1
msgid "requirement"
msgstr ""

#: ../../../conan_sources/conan/tools/cmake/cmakedeps/cmakedeps.py:docstring of
#: conan.tools.cmake.cmakedeps.cmakedeps.CMakeDeps.get_find_mode:0
msgid "Returns"
msgstr ""

#: ../../../conan_sources/conan/tools/cmake/cmakedeps/cmakedeps.py:docstring of
#: conan.tools.cmake.cmakedeps.cmakedeps.CMakeDeps.get_find_mode:2
msgid ""
"\"none\" or \"config\" or \"module\" or \"both\" or \"config\" when not set"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:229
msgid "Properties"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:231
msgid "The following properties affect the CMakeDeps generator:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:233
msgid ""
"**cmake_file_name**: The config file generated for the current package will "
"follow the ``<VALUE>-config.cmake`` pattern, so to find the package you "
"write ``find_package(<VALUE>)``."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:235
msgid "**cmake_target_name**: Name of the target to be consumed."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:236
msgid ""
"**cmake_target_aliases**: List of aliases that Conan will create for an "
"already existing target."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:237
msgid "**cmake_find_mode**: Defaulted to ``config``. Possible values are:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:239
msgid ""
"``config``: The CMakeDeps generator will create config scripts for the "
"dependency."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:240
msgid ""
"``module``: Will create module config (FindXXX.cmake) scripts for the "
"dependency."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:241
msgid "``both``: Will generate both config and modules."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:242
msgid ""
"``none``: Won't generate any file. It can be used, for instance, to create a "
"system wrapper package so the consumers find the config files in the CMake "
"installation config path and not in the generated by Conan (because it has "
"been skipped)."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:244
msgid ""
"**cmake_module_file_name**: Same as **cmake_file_name** but when generating "
"modules with ``cmake_find_mode=module/both``. If not specified it will "
"default to **cmake_file_name**."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:245
msgid ""
"**cmake_module_target_name**: Same as **cmake_target_name**  but when "
"generating modules with ``cmake_find_mode=module/both``.  If not specified "
"it will default to **cmake_target_name**."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:246
msgid ""
"**cmake_build_modules**: List of ``.cmake`` files (route relative to root "
"package folder) that are automatically included when the consumer run the "
"``find_package()``. This property cannot be set in the components, only in "
"the root ``self.cpp_info``."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:248
msgid ""
"**cmake_set_interface_link_directories**: boolean value that should be only "
"used by dependencies that don't declare `self.cpp_info.libs` but have "
"``#pragma comment(lib, \"foo\")`` (automatic link) declared at the public "
"headers. Those dependencies should add this property to their *conanfile.py* "
"files at root ``cpp_info`` level (components not supported for now)."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:250
msgid ""
"**nosoname**: boolean value that should be used only by dependencies that "
"are defined as ``SHARED`` and represent a library built without the "
"``soname`` flag option."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:251
msgid ""
"**cmake_config_version_compat**: (preview) By default ``SameMajorVersion``, "
"it can take the values ``\"AnyNewerVersion\", \"SameMajorVersion\", "
"\"SameMinorVersion\", \"ExactVersion\"``. It will use that policy in the "
"generated ``<PackageName>ConfigVersion.cmake`` file"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:252
msgid ""
"**system_package_version**: version of the package used to generate the "
"``<PackageName>ConfigVersion.cmake`` file. Can be useful when creating "
"system packages or other wrapper packages, where the conan package version "
"is different to the eventually referenced package version to keep "
"compatibility to ``find_package(<PackageName> <Version>)`` calls."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:253
msgid ""
"**cmake_additional_variables_prefixes**: List of prefixes to be used when "
"creating CMake variables in the config files. These variables are created "
"with ``file_name`` as prefix by default, but setting this property will "
"create additional variables with the specified prefixes."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:257
#: ../../../reference/tools/cmake/cmakedeps.rst:379
msgid "Example:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:259
msgid ""
"def package_info(self):\n"
"    ...\n"
"    # MyFileName-config.cmake\n"
"    self.cpp_info.set_property(\"cmake_file_name\", \"MyFileName\")\n"
"    # Names for targets are absolute, Conan won't add any namespace to the "
"target names automatically\n"
"    self.cpp_info.set_property(\"cmake_target_name\", \"Foo::Foo\")\n"
"    # Automatically include the lib/mypkg.cmake file when calling "
"find_package()\n"
"    # This property cannot be set in a component.\n"
"    self.cpp_info.set_property(\"cmake_build_modules\", [os.path."
"join(\"lib\", \"mypkg.cmake\")])\n"
"\n"
"    # Create a new target \"MyFooAlias\" that is an alias to the \"Foo::"
"Foo\" target\n"
"    self.cpp_info.set_property(\"cmake_target_aliases\", [\"MyFooAlias\"])\n"
"\n"
"    self.cpp_info.components[\"mycomponent\"]."
"set_property(\"cmake_target_name\", \"Foo::Var\")\n"
"\n"
"    # Create a new target \"VarComponent\" that is an alias to the \"Foo::"
"Var\" component target\n"
"    self.cpp_info.components[\"mycomponent\"]."
"set_property(\"cmake_target_aliases\", [\"VarComponent\"])\n"
"\n"
"    # Skip this package when generating the files for the whole dependency "
"tree in the consumer\n"
"    # note: it will make useless the previous adjustements.\n"
"    # self.cpp_info.set_property(\"cmake_find_mode\", \"none\")\n"
"\n"
"    # Generate both MyFileNameConfig.cmake and FindMyFileName.cmake\n"
"    self.cpp_info.set_property(\"cmake_find_mode\", \"both\")"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:288
msgid ""
"Overwrite properties from the consumer side using CMakeDeps.set_property()"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:290
msgid ""
"Using ``CMakeDeps.set_property()`` method you can overwrite the property "
"values set by the Conan recipes from the consumer. This can be done for "
"`cmake_file_name`, `cmake_target_name`, `cmake_find_mode`, "
"`cmake_module_file_name` and `cmake_module_target_name` properties. Let's "
"see an example of how this works:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:295
msgid ""
"Imagine we have a *compressor/1.0* package that depends on *zlib/1.2.11*. "
"The *zlib* recipe defines some properties:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:299
msgid "Zlib conanfile.py"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:299
msgid ""
"class ZlibConan(ConanFile):\n"
"    name = \"zlib\"\n"
"\n"
"    ...\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.set_property(\"cmake_find_mode\", \"both\")\n"
"        self.cpp_info.set_property(\"cmake_file_name\", \"ZLIB\")\n"
"        self.cpp_info.set_property(\"cmake_target_name\", \"ZLIB::ZLIB\")\n"
"        ..."
msgstr ""
"class ZlibConan(ConanFile):\n"
"    name = \"zlib\"\n"
"\n"
"    ...\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.set_property(\"cmake_find_mode\", \"both\")\n"
"        self.cpp_info.set_property(\"cmake_file_name\", \"ZLIB\")\n"
"        self.cpp_info.set_property(\"cmake_target_name\", \"ZLIB::ZLIB\")\n"
"        ..."

#: ../../../reference/tools/cmake/cmakedeps.rst:313
msgid ""
"This recipe defines several properties. For example the ``cmake_find_mode`` "
"property is set to ``both``. That means that module and config files are "
"generated for Zlib. Maybe we need to alter this behaviour and just generate "
"config files. You could do that in the compressor recipe using the "
"``CMakeDeps.set_property()`` method:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:319
#: ../../../reference/tools/cmake/cmakedeps.rst:338
msgid "compressor conanfile.py"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:319
msgid ""
"class Compressor(ConanFile):\n"
"    name = \"compressor\"\n"
"\n"
"    requires = \"zlib/1.2.11\"\n"
"    ...\n"
"\n"
"    def generate(self):\n"
"        deps = CMakeDeps(self)\n"
"        deps.set_property(\"zlib\", \"cmake_find_mode\", \"config\")\n"
"        deps.generate()\n"
"        ..."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:334
msgid ""
"You can also use the ``set_property()`` method to invalidate the property "
"values set by the upstream recipe and use the values that Conan assigns by "
"default. To do so, set the value ``None`` to the property like this:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:338
msgid ""
"class Compressor(ConanFile):\n"
"    name = \"compressor\"\n"
"\n"
"    requires = \"zlib/1.2.11\"\n"
"    ...\n"
"\n"
"    def generate(self):\n"
"        deps = CMakeDeps(self)\n"
"        deps.set_property(\"zlib\", \"cmake_target_name\", None)\n"
"        deps.generate()\n"
"        ..."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:353
msgid ""
"After doing this the generated target name for the Zlib library will be "
"``zlib::zlib`` instead of ``ZLIB::ZLIB``"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:356
msgid ""
"Additionally, `CMakeDeps.set_property()` can also be used for packages that "
"have components. In this case, you will need to provide the package name "
"along with its component separated by a double colon (`::`). Here's an "
"example:"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:360
msgid ""
"def generate(self):\n"
"    deps = CMakeDeps(self)\n"
"    deps.set_property(\"pkg::component\", \"cmake_target_name\", "
"<new_component_target_name>)\n"
"    deps.generate()\n"
"    ..."
msgstr ""
"def generate(self):\n"
"    deps = CMakeDeps(self)\n"
"    deps.set_property(\"pkg::component\", \"cmake_target_name\", "
"<new_component_target_name>)\n"
"    deps.generate()\n"
"    ..."

#: ../../../reference/tools/cmake/cmakedeps.rst:372
msgid "Disable CMakeDeps For Installed CMake configuration files"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:374
msgid ""
"Some projects may want to disable the ``CMakeDeps`` generator for downstream "
"consumers. This can be done by settings ``cmake_find_mode`` to ``none``. If "
"the project wants to provide its own configuration targets, it should append "
"them to the ``buildirs`` attribute of ``cpp_info``."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:377
msgid ""
"This method is intended to work with downstream consumers using the "
"``CMakeToolchain`` generator, which will be populated with the ``builddirs`` "
"attribute."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:381
msgid ""
"def package(self):\n"
"    ...\n"
"    cmake.install()\n"
"\n"
"def package_info(self):\n"
"    self.cpp_info.set_property(\"cmake_find_mode\", \"none\") # Do NOT "
"generate any files\n"
"    self.cpp_info.builddirs.append(os.path.join(\"lib\", \"cmake\", \"foo\"))"
msgstr ""
"def package(self):\n"
"    ...\n"
"    cmake.install()\n"
"\n"
"def package_info(self):\n"
"    self.cpp_info.set_property(\"cmake_find_mode\", \"none\") # 不要生成任何"
"檔案。\n"
"    self.cpp_info.builddirs.append(os.path.join(\"lib\", \"cmake\", \"foo\"))"

#: ../../../reference/tools/cmake/cmakedeps.rst:393
msgid "Map from project configuration to imported target's configuration"
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:395
msgid ""
"As mentioned above, ``CMakeDeps`` provides support for multiple "
"configuration environments (Debug, Release, etc.) This is achieved by "
"populating properties on the imported targets according to the "
"``build_type`` setting when installing dependencies. When a consumer project "
"is configured with a single-configuration CMake generator, however, it is "
"necessary to define the ``CMAKE_BUILD_TYPE`` with a value that matches that "
"of the installed dependencies."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:400
msgid ""
"If the consumer CMake project is configured with a different build type than "
"the dependencies, it is necessary to tell CMake how to map the "
"configurations from the current project to the imported targets by setting "
"the ``CMAKE_MAP_IMPORTED_CONFIG_<CONFIG>`` CMake variable."
msgstr ""

#: ../../../reference/tools/cmake/cmakedeps.rst:404
msgid ""
"cd build-coverage/\n"
"conan install .. -s build_type=Debug\n"
"cmake .. -DCMAKE_BUILD_TYPE=Coverage -DCMAKE_TOOLCHAIN_FILE=conan_toolchain."
"cmake -DCMAKE_MAP_IMPORTED_CONFIG_COVERAGE=Debug"
msgstr ""
"cd build-coverage/\n"
"conan install .. -s build_type=Debug\n"
"cmake .. -DCMAKE_BUILD_TYPE=Coverage -DCMAKE_TOOLCHAIN_FILE=conan_toolchain."
"cmake -DCMAKE_MAP_IMPORTED_CONFIG_COVERAGE=Debug"
