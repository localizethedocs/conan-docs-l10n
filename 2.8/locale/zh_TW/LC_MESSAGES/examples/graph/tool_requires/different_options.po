# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2024, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 2.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 14:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../examples/graph/tool_requires/different_options.rst:2
msgid "Depending on same version of a tool-require with different options"
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:6
msgid ""
"This is an **advanced** use case. It shouldn't be necessary in the vast "
"majority of cases."
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:9
msgid "In the general case, trying to do something like this:"
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:11
msgid ""
"def build_requirements(self):\n"
"    self.tool_requires(\"gcc/1.0\")\n"
"    self.tool_requires(\"gcc/1.0\")"
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:17
msgid ""
"Will generate a \"conflict\", showing an error like ``Duplicated "
"requirement``."
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:19
msgid ""
"However there are some exceptional situations that we could need to depend "
"on the same ``tool_requires`` version, but using different binaries of that "
"``tool_requires``. This can be achieved by passing different ``options`` to "
"those ``tool_requires``. Please, first clone the sources to recreate this "
"project. You can find them in the `examples2 repository <https://github.com/"
"conan-io/examples2>`_ on GitHub:"
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:24
msgid ""
"git clone https://github.com/conan-io/examples2.git\n"
"cd examples2/examples/graph/tool_requires/different_options"
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:29
msgid "There we have a ``gcc`` fake recipe with:"
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:31
msgid ""
"class Pkg(ConanFile):\n"
"    name = \"gcc\"\n"
"    version = \"1.0\"\n"
"    options = {\"myoption\": [1, 2]}\n"
"\n"
"    def package(self):\n"
"        # This fake compiler will print something different based on the "
"option\n"
"        echo = f\"@echo off\\necho MYGCC={self.options.myoption}!!\"\n"
"        save(self, os.path.join(self.package_folder, \"bin\", f\"mygcc{self."
"options.myoption}.bat\"), echo)\n"
"        save(self, os.path.join(self.package_folder, \"bin\", f\"mygcc{self."
"options.myoption}.sh\"), echo)\n"
"        os.chmod(os.path.join(self.package_folder, \"bin\", f\"mygcc{self."
"options.myoption}.sh\"), 0o777)"
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:46
msgid ""
"This is not an actual compiler, it fakes it with a shell or bat script that "
"prints ``MYGCC=current-option`` when executed. Note the binary itself is "
"called ``mygcc1`` and ``mygcc2``, that is, it contains the option in the "
"executable name itself."
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:49
msgid "We can create 2 different binaries for ``gcc/1.0`` with:"
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:52
msgid ""
"$ conan create gcc -o myoption=1\n"
"$ conan create gcc -o myoption=2"
msgstr ""
"$ conan create gcc -o myoption=1\n"
"$ conan create gcc -o myoption=2"

#: ../../../examples/graph/tool_requires/different_options.rst:57
msgid "Now, in the ``wine`` folder there is a ``conanfile.py`` like this:"
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:59
msgid ""
"class Pkg(ConanFile):\n"
"    name = \"wine\"\n"
"    version = \"1.0\"\n"
"\n"
"    def build_requirements(self):\n"
"        self.tool_requires(\"gcc/1.0\", run=False, options={\"myoption\": "
"1})\n"
"        self.tool_requires(\"gcc/1.0\", run=False, options={\"myoption\": "
"2})\n"
"\n"
"    def generate(self):\n"
"        gcc1 = self.dependencies.build.get(\"gcc\", options={\"myoption\": "
"1})\n"
"        assert gcc1.options.myoption == \"1\"\n"
"        gcc2 = self.dependencies.build.get(\"gcc\", options={\"myoption\": "
"2})\n"
"        assert gcc2.options.myoption == \"2\"\n"
"\n"
"    def build(self):\n"
"        ext = \"bat\" if platform.system() == \"Windows\" else \"sh\"\n"
"        self.run(f\"mygcc1.{ext}\")\n"
"        self.run(f\"mygcc2.{ext}\")"
msgstr ""
"class Pkg(ConanFile):\n"
"    name = \"wine\"\n"
"    version = \"1.0\"\n"
"\n"
"    def build_requirements(self):\n"
"        self.tool_requires(\"gcc/1.0\", run=False, options={\"myoption\": "
"1})\n"
"        self.tool_requires(\"gcc/1.0\", run=False, options={\"myoption\": "
"2})\n"
"\n"
"    def generate(self):\n"
"        gcc1 = self.dependencies.build.get(\"gcc\", options={\"myoption\": "
"1})\n"
"        assert gcc1.options.myoption == \"1\"\n"
"        gcc2 = self.dependencies.build.get(\"gcc\", options={\"myoption\": "
"2})\n"
"        assert gcc2.options.myoption == \"2\"\n"
"\n"
"    def build(self):\n"
"        ext = \"bat\" if platform.system() == \"Windows\" else \"sh\"\n"
"        self.run(f\"mygcc1.{ext}\")\n"
"        self.run(f\"mygcc2.{ext}\")"

#: ../../../examples/graph/tool_requires/different_options.rst:81
msgid ""
"The first important point is the ``build_requirements()`` method, that does "
"a ``tool_requires()`` to both binaries, but defining ``run=False`` and "
"``options={\"myoption\": value}`` traits. **This is very important**: we are "
"telling Conan that we actually don't need to run anything from those "
"packages. As ``tool_requires`` are not visible, they don't define headers or "
"libraries and they define different ``options``, there is nothing that makes "
"Conan identify those 2 ``tool_requires`` as conflicting. So the dependency "
"graph can be constructed without errors, and the ``wine/1.0`` package will "
"contain 2 different tool-requires to both ``gcc/1.0`` with ``myoption=1`` "
"and with ``myoption=2``."
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:88
msgid ""
"Of course, it is not true that we won't run anything from those "
"``tool_requires``, but now Conan is not aware of it, and it is completely "
"the responsibility of the user to manage it."
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:93
msgid ""
"Using ``run=False`` makes the ``tool_requires()`` completely invisible, that "
"means that profile ``[tool_requires]`` will not be able to override its "
"version, but it would create an extra tool-require dependency with the "
"version injected from the profile. You might want to exclude specific "
"packages with something like ``!wine/*: gcc/3.0``."
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:97
msgid ""
"The recipe still has access in the ``generate()`` method to each different "
"``tool_require`` version, just by providing the options values for the "
"dependency that we want ``self.dependencies.build.get(\"gcc\", "
"options={\"myoption\": 1})``."
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:100
msgid ""
"Finally, the most important part is that the usage of those tools is "
"completely the responsibility of the user. The ``bin`` folder of both "
"``tool_requires`` containing the executables will be in the path thanks to "
"the ``VirtualBuildEnv`` generator that by default updates the PATH env-var. "
"In this case the executables are different like ``mygcc1.sh```and ``mygcc2."
"sh``, so it is not an issue, and each one will be found inside its package."
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:105
msgid ""
"But if the executable file was exactly the same like ``gcc.exe``, then it "
"would be necessary to obtain the full folder (typically in the "
"``generate()`` method) with something like ``self.dependencies.build."
"get(\"gcc\", options={\"myoption\": 1}).cpp_info.bindir`` and use the full "
"path to disambiguate."
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:110
msgid "Let's see it working. If we execute:"
msgstr ""

#: ../../../examples/graph/tool_requires/different_options.rst:113
msgid ""
"$ conan create wine\n"
"...\n"
"wine/1.0: RUN: mygcc1.bat\n"
"MYGCC=1!!\n"
"\n"
"wine/1.0: RUN: mygcc2.bat\n"
"MYGCC=2!!"
msgstr ""
