# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2024, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-23 08:30+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorial/versioning/conflicts.rst:4
msgid "Dependencies conflicts"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:6
msgid ""
"In a dependency graph, when different packages depends on different versions "
"of the same package, this is called a dependency version conflict. It is "
"relatively easy to produce one. Let's see it with a practical example, start "
"cloning the `examples2 repository <https://github.com/conan-io/examples2>`_:"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:11
msgid ""
"$ git clone https://github.com/conan-io/examples2.git\n"
"$ cd examples2/tutorial/versioning/conflicts/versions"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:16
msgid ""
"In this folder we have a small project, consisting in several packages: "
"``matrix`` (a math library), ``engine/1.0`` video game engine that depends "
"on ``matrix/1.0``, ``intro/1.0``, a package implementing the intro credits "
"and functionality for the videogame that depends on ``matrix/1.1`` and "
"finally the ``game`` recipe that depends simultaneously on ``engine/1.0`` "
"and ``intro/1.0``. All these packages are actually empty, but they are "
"enough to produce the conflicts."
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:36
msgid "Let's create the dependencies:"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:38
msgid ""
"$ conan create matrix --version=1.0\n"
"$ conan create matrix --version=1.1  # note this is 1.1!\n"
"$ conan create engine --version=1.0 # depends on matrix/1.0\n"
"$ conan create intro --version=1.0 # depends on matrix/1.1"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:45
msgid "And when we try to install ``game``, we will get the error:"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:47
msgid ""
"$ conan install game\n"
"Requirements\n"
"    engine/1.0#0fe4e6890766f7b8e21f764f0049aec7 - Cache\n"
"    intro/1.0#d639998c2e55cf36d261ab319801c322 - Cache\n"
"    matrix/1.0#905c3f0babc520684c84127378fefdd0 - Cache\n"
"Graph error\n"
"    Version conflict: intro/1.0->matrix/1.1, game/1.0->matrix/1.0.\n"
"ERROR: Version conflict: intro/1.0->matrix/1.1, game/1.0->matrix/1.0."
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:58
msgid ""
"This is a version conflict, and Conan will not decide automatically how to "
"resolve the conflict, but the user should explicitly resolve such conflict."
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:63
msgid "Resolving conflicts"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:65
msgid ""
"Of course, the most direct and straightforward way to solve such a conflict "
"is going to the dependencies ``conanfile.py`` and upgrading their "
"``requirements()`` so they point now to the same version. However this might "
"not be practical in some cases, or it might be even impossible to fix the "
"dependencies conanfiles."
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:70
msgid ""
"For that case, it should be the consuming ``conanfile.py`` the one that can "
"resolve the conflict (in this case, ``game``) by explicitly defining which "
"version of the dependency should be used, with the following syntax:"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:74
#: ../../../tutorial/versioning/conflicts.rst:138
#: ../../../tutorial/versioning/conflicts.rst:185
#: ../../../tutorial/versioning/conflicts.rst:307
msgid "game/conanfile.py"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:74
msgid ""
"class Game(ConanFile):\n"
"    name = \"game\"\n"
"    version = \"1.0\"\n"
"\n"
"    def requirements(self):\n"
"        self.requires(\"engine/1.0\")\n"
"        self.requires(\"intro/1.0\")\n"
"        self.requires(\"matrix/1.1\", override=True)"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:87
msgid ""
"This is called an ``override``. The ``game`` package do not directly depend "
"on ``matrix``, this ``requires`` declaration will not introduce such a a "
"direct dependency. But the ``matrix/1.1`` version will be propagated "
"upstream in the dependency graph, overriding the ``requires`` of packages "
"that do depend on any ``matrix`` version, forcing the consistency of the "
"graph, as all upstream packages will now depend on ``matrix/1.1``:"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:93
msgid ""
"$ conan install game\n"
"...\n"
"Requirements\n"
"    engine/1.0#0fe4e6890766f7b8e21f764f0049aec7 - Cache\n"
"    intro/1.0#d639998c2e55cf36d261ab319801c322 - Cache\n"
"    matrix/1.1#905c3f0babc520684c84127378fefdd0 - Cache"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:122
msgid ""
"In this case, a new binary for ``engine/1.0`` was not necessary, but in some "
"situations the above could fail with a ``engine/1.0`` \"binary missing "
"error\". Because previously ``engine/1.0`` binaries were built against "
"``matrix/1.0``. If the ``package_id`` rules and configuration define that "
"``engine`` should be rebuilt when minor versions of the dependencies change, "
"then it will be necessary to build a new binary for ``engine/1.0`` that "
"builds and links against the new ``matrix/1.1`` dependency."
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:129
msgid ""
"What happens if ``game`` had a direct dependency to ``matrix/1.2``? Lets "
"create the version:"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:132
msgid "$ conan create matrix --version=1.2"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:136
msgid ""
"Now let's modify ``game/conanfile.py`` to introduce this as a direct "
"dependency:"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:138
msgid ""
"class Game(ConanFile):\n"
"    name = \"game\"\n"
"    version = \"1.0\"\n"
"\n"
"    def requirements(self):\n"
"        self.requires(\"engine/1.0\")\n"
"        self.requires(\"intro/1.0\")\n"
"        self.requires(\"matrix/1.2\")"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:173
msgid "So installing it will raise a conflict error again:"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:175
msgid ""
"$ conan install game\n"
"...\n"
"ERROR: Version conflict: engine/1.0->matrix/1.0, game/1.0->matrix/1.2."
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:181
msgid ""
"As this time, we want to respect the direct dependency between ``game`` and "
"``matrix``, we will define the ``force=True`` requirement trait, to indicate "
"that this dependency version will also be forcing the overrides upstream:"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:185
msgid ""
"class Game(ConanFile):\n"
"    name = \"game\"\n"
"    version = \"1.0\"\n"
"\n"
"    def requirements(self):\n"
"        self.requires(\"engine/1.0\")\n"
"        self.requires(\"intro/1.0\")\n"
"        self.requires(\"matrix/1.2\", force=True)"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:198
msgid ""
"And that will now solve again the conflict (as commented above, note that in "
"real applications this could mean that binaries for ``engine/1.0`` and "
"``intro/1.0`` would be missing, and need to be built to link against the new "
"forced ``matrix/1.2`` version):"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:202
msgid ""
"$ conan install game\n"
"Requirements\n"
"    engine/1.0#0fe4e6890766f7b8e21f764f0049aec7 - Cache\n"
"    intro/1.0#d639998c2e55cf36d261ab319801c322 - Cache\n"
"    matrix/1.2#905c3f0babc520684c84127378fefdd0 - Cache"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:231
#: ../../../tutorial/versioning/conflicts.rst:335
msgid "**Best practices**"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:233
msgid ""
"Resolving version conflicts by overrides/forces should in general be the "
"exception and avoided when possible, applied as a temporary workaround. The "
"real solution is to move forward the dependencies ``requires`` so they "
"naturally converge to the same versions of upstream dependencies."
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:234
msgid ""
"A key takeaway is that the ``force`` trait will create a direct dependency "
"between the consumer and the required package, while the ``override`` won't, "
"it will only instruct Conan to prefer the required version if the package is "
"already in the dependency graph."
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:235
msgid ""
"Version-ranges can also produce some version conflicts, even if Conan tries "
"to reduce them. This :ref:`FAQ about version "
"conflicts<faq_version_conflicts_version_ranges>` discusses the graph "
"resolution algorithm and strategies to minimize the conflicts."
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:240
msgid "Overriding options"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:242
msgid ""
"It is possible that when there are diamond structures in a dependency graph, "
"like the one seen above, different recipes might be defining different "
"values for the upstream ``options``. In this case, this is not directly "
"causing a conflict, but instead the first value to be defined is the one "
"that will be prioritized and will prevail."
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:247
msgid ""
"In the above example, if ``matrix/1.0`` can be both a static and a shared "
"library, and ``engine`` decides to define that it should be a static library "
"(not really necessary, because that is already the default):"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:250
msgid "engine/conanfile.py"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:250
msgid ""
"class Engine(ConanFile):\n"
"    name = \"engine\"\n"
"    version = \"1.0\"\n"
"    # Not strictly necessary because this is already the matrix default\n"
"    default_options = {\"matrix*:shared\": False}"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:262
msgid ""
"Defining options values in recipes does not have strong guarantees, please "
"check :ref:`this FAQ about options values for "
"dependencies<faq_different_options_values>`. The recommended way to define "
"options values is in profile files."
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:266
msgid ""
"And also ``intro`` recipe would do the same, but instead define that it "
"wants a shared library, and adds a ``validate()`` method, because for some "
"reason the ``intro`` package can only be built against shared libraries and "
"otherwise crashes:"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:270
msgid "intro/conanfile.py"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:270
msgid ""
"class Intro(ConanFile):\n"
"    name = \"intro\"\n"
"    version = \"1.0\"\n"
"    default_options = {\"matrix*:shared\": True}\n"
"\n"
"    def requirements(self):\n"
"        self.requires(\"matrix/1.0\")\n"
"\n"
"    def validate(self):\n"
"        if not self.dependencies[\"matrix\"].options.shared:\n"
"            raise ConanInvalidConfiguration(\"Intro package doesn't work "
"with static matrix library\")"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:285
msgid ""
"Then, this will cause an error, because as the first one to define the "
"option value is ``engine`` (it is declared first in the ``game`` conanfile "
"``requirements()`` method). In the examples2 repository, go to the "
"\"options\" folder, and create the different packages:"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:290
msgid ""
"$ cd ../options\n"
"$ conan create matrix\n"
"$ conan create matrix -o matrix/*:shared=True\n"
"$ conan create engine\n"
"$ conan create intro\n"
"$ conan install game  # FAILS!\n"
"...\n"
"-------- Installing (downloading, building) binaries... --------\n"
"ERROR: There are invalid packages (packages that cannot exist for this "
"configuration):\n"
"intro/1.0: Invalid: Intro package doesn't work with static matrix library"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:304
msgid ""
"Following the same principle, the downstream consumer recipe, in this case "
"``game`` conanfile.py can define the options values, and those will be "
"prioritized:"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:307
msgid ""
"class Game(ConanFile):\n"
"    name = \"game\"\n"
"    version = \"1.0\"\n"
"    default_options = {\"matrix*:shared\": True}\n"
"\n"
"    def requirements(self):\n"
"        self.requires(\"engine/1.0\")\n"
"        self.requires(\"intro/1.0\")"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:320
msgid ""
"And that will force now ``matrix`` being a shared library, no matter if "
"``engine`` defined ``shared=False``, because the downstream consumers always "
"have priority over the upstream dependencies."
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:323
msgid ""
"$ conan install game\n"
"...\n"
"-------- Installing (downloading, building) binaries... --------\n"
"matrix/1.0: Already installed!\n"
"matrix/1.0: I am a shared-library library!!!\n"
"engine/1.0: Already installed!\n"
"intro/1.0: Already installed!"
msgstr ""

#: ../../../tutorial/versioning/conflicts.rst:337
msgid ""
"As a general rule, avoid modifying or defining values for dependencies "
"``options`` in consumers ``conanfile.py``. The declared ``options`` defaults "
"should be good for the majority of cases, and variations from those defaults "
"can be defined better in profiles better."
msgstr ""
