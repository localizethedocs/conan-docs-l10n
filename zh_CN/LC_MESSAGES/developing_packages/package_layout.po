# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2022, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.62\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:05+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../developing_packages/package_layout.rst:4
msgid "Package layout"
msgstr ""

#: ../../../developing_packages/package_layout.rst:8
msgid ""
"Some of the features used in this section are still **under development**, "
"while they are recommended and usable and we will try not to break them in "
"future releases, some breaking changes might still happen if necessary to "
"prepare for the *Conan 2.0 release*."
msgstr ""

#: ../../../developing_packages/package_layout.rst:14
msgid ""
"The ``layout()`` feature will be fully functional only in the new build "
"system integrations (:ref:`in the conan.tools space <conan_tools>`). If you "
"are using other integrations, they might not fully support this feature."
msgstr ""

#: ../../../developing_packages/package_layout.rst:19
msgid ""
"Available since: `1.37.0 <https://github.com/conan-io/conan/releases/"
"tag/1.37.0>`_"
msgstr ""

#: ../../../developing_packages/package_layout.rst:22
msgid "Before starting"
msgstr ""

#: ../../../developing_packages/package_layout.rst:24
msgid ""
"To understand correctly how the ``layout()`` method can help us we need to "
"recall first how Conan works."
msgstr ""

#: ../../../developing_packages/package_layout.rst:26
msgid "Let's say we are working in a project, using, for example, CMake:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:28
#: ../../../developing_packages/package_layout.rst:247
msgid ""
"<my_project_folder>\n"
"├── conanfile.py\n"
"└── src\n"
"    ├── CMakeLists.txt\n"
"    ├── hello.cpp\n"
"    ├── my_tool.cpp\n"
"    └── include\n"
"        └── hello.h"
msgstr ""

#: ../../../developing_packages/package_layout.rst:39
msgid ""
"When we call ``conan create``, this is a simplified description of what "
"happens:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:41
msgid ""
"Conan exports the recipe (conanfile.py) and the declared sources "
"(exports_sources) to the cache. The folders in the cache would be something "
"like:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:44
#: ../../../developing_packages/package_layout.rst:60
#: ../../../developing_packages/package_layout.rst:84
#: ../../../developing_packages/package_layout.rst:112
#: ../../../developing_packages/package_layout.rst:424
msgid ".conan/data/<some_cache_folder>"
msgstr ""

#: ../../../developing_packages/package_layout.rst:44
msgid ""
"├── export\n"
"│   └── conanfile.py\n"
"└── export_source\n"
"    └── src\n"
"        ├── CMakeLists.txt\n"
"        ├── hello.cpp\n"
"        ├── my_tool.cpp\n"
"        └── include\n"
"            └── hello.h"
msgstr ""

#: ../../../developing_packages/package_layout.rst:57
msgid ""
"If the method ``source()`` exists, it might retrieve sources from the "
"internet. Also, the ``export_source`` folder is copied to the ``source`` "
"folder."
msgstr ""

#: ../../../developing_packages/package_layout.rst:60
msgid ""
"├── export\n"
"│   └── conanfile.py\n"
"├── export_source\n"
"│   └── src\n"
"│       ├── CMakeLists.txt\n"
"│       ├── hello.cpp\n"
"│       ├── my_tool.cpp\n"
"│       └── include\n"
"│           └── hello.h\n"
"└── source\n"
"    └── src\n"
"        ├── CMakeLists.txt\n"
"        ├── hello.cpp\n"
"        ├── my_tool.cpp\n"
"        └── include\n"
"            └── hello.h"
msgstr ""

#: ../../../developing_packages/package_layout.rst:81
msgid ""
"Before calling the ``build()`` method, a build folder is created and the "
"**sources** are copied there. Later, we call the ``build()`` method so the "
"libraries and executables are built:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:84
msgid ""
"├── export\n"
"│   └── conanfile.py\n"
"├── export_source\n"
"│   └── src\n"
"│       ├── CMakeLists.txt\n"
"│       ├── hello.cpp\n"
"│       ├── my_tool.cpp\n"
"│       └── include\n"
"│           └── hello.h\n"
"├── source\n"
"│   └── src\n"
"│       ├── CMakeLists.txt\n"
"│       ├── hello.cpp\n"
"│       ├── my_tool.cpp\n"
"│       └── include\n"
"│           └── hello.h\n"
"└── build\n"
"    └── <build_id>\n"
"        ├── say.a\n"
"        └── bin\n"
"            └── my_app"
msgstr ""

#: ../../../developing_packages/package_layout.rst:109
msgid ""
"At last, Conan calls the ``package()`` method to copy the built artifacts "
"from the ``source`` (typically includes) and ``build`` folders (libraries "
"and executables) to a **package** folder."
msgstr ""

#: ../../../developing_packages/package_layout.rst:112
msgid ""
"├── export\n"
"│   └── conanfile.py\n"
"├── export_source\n"
"│   └── src\n"
"│       ├── CMakeLists.txt\n"
"│       ├── hello.cpp\n"
"│       ├── my_tool.cpp\n"
"│       └── include\n"
"│           └── hello.h\n"
"├── source\n"
"│   └── src\n"
"│       ├── CMakeLists.txt\n"
"│       ├── hello.cpp\n"
"│       ├── my_tool.cpp\n"
"│       └── include\n"
"│           └── hello.h\n"
"├── build\n"
"│   └── <build_id>\n"
"│       ├── say.a\n"
"│       └── bin\n"
"│           └── my_app\n"
"└── package\n"
"    └── <package_id>\n"
"        ├── lib\n"
"        │   └── say.a\n"
"        ├── bin\n"
"        │   └── my_app\n"
"        └── include\n"
"            └── hello.h"
msgstr ""

#: ../../../developing_packages/package_layout.rst:145
msgid ""
"The ``package_info(self)`` method will describe with the ``self.cpp_info`` "
"object the contents of the ``package`` folder, that is the one the consumers "
"use to link against it. If we call `conan create` with different "
"configurations the base folder in the cache is different and nothing gets "
"messed."
msgstr ""

#: ../../../developing_packages/package_layout.rst:150
#: ../../../developing_packages/package_layout.rst:277
#: ../../../developing_packages/package_layout.rst:348
msgid "conanfile.py"
msgstr ""

#: ../../../developing_packages/package_layout.rst:150
msgid ""
"import os\n"
"from conan import ConanFile\n"
"from conan.tools.cmake import CMake\n"
"\n"
"\n"
"class SayConan(ConanFile):\n"
"    name = \"say\"\n"
"    version = \"0.1\"\n"
"    exports_sources = \"src/*\"\n"
"    ...\n"
"    def package_info(self):\n"
"        # These are default values and doesn't need to be adjusted\n"
"        self.cpp_info.includedirs = [\"include\"]\n"
"        self.cpp_info.libdirs = [\"lib\"]\n"
"        self.cpp_info.bindirs = [\"bin\"]\n"
"\n"
"        # The library name\n"
"        self.cpp_info.libs = [\"say\"]"
msgstr ""

#: ../../../developing_packages/package_layout.rst:173
msgid "So, this workflow in the cache works flawlessly but:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:175
msgid ""
"What if I'm developing the recipe in my local project and want to use the "
"local methods (**conan source**, **conan build**) and later call **export-"
"pkg** to create the package?"
msgstr ""

#: ../../../developing_packages/package_layout.rst:178
msgid ""
"If you call **conan build** in your working directory, without specifying a "
"``--build-folder`` argument, you will end up with a bunch of files polluting "
"your project. Moreover, if you want to build more configurations you will "
"need to create several build folders by hand, this is inconvenient, error-"
"prone, and wouldn't be easy for Conan to locate the correct artifacts if you "
"want to call **export-pkg** later."
msgstr ""

#: ../../../developing_packages/package_layout.rst:183
msgid ""
"What if I don't even want to call **conan build** but use my CLion IDE to "
"build the project?"
msgstr ""

#: ../../../developing_packages/package_layout.rst:185
msgid ""
"By default, the CLion IDE will create the folders **cmake-build-release** "
"and **cmake-build-debug** to put the build files there, so maybe your "
"``package()`` method is not able to locate the files in there and the "
"**export-pkg** might fail."
msgstr ""

#: ../../../developing_packages/package_layout.rst:189
msgid ""
"What if I want to use my project as an :ref:`editable "
"package<editable_packages>`?"
msgstr ""

#: ../../../developing_packages/package_layout.rst:191
msgid ""
"If you want to keep developing your package but let the consumers link with "
"the artifacts in your project instead of the files in the Conan cache, this "
"will not work, because it only declares the location of headers and "
"libraries in the final packaged layout, but during development the files are "
"typically in other locations."
msgstr ""

#: ../../../developing_packages/package_layout.rst:196
msgid ""
"So, just as we describe the package folder in the ``package_info()`` method, "
"we can use ``layout()`` to describe the ``source`` and ``build`` folders "
"(both in a local project and in the cache):"
msgstr ""

#: ../../../developing_packages/package_layout.rst:199
msgid ""
"We can run the conan local commands (**conan source**, **conan build**, "
"**conan export-pkg**) without taking care of specifying directories, always "
"with the same syntax."
msgstr ""

#: ../../../developing_packages/package_layout.rst:201
msgid ""
"If you are using an IDE, you can describe the build folder naming in the "
"layout, so the libraries and executables are always in a known place."
msgstr ""

#: ../../../developing_packages/package_layout.rst:203
msgid ""
"In the cache, the layout (like a build subfolder) is kept, so we can always "
"know where the artifacts are before packaging them."
msgstr ""

#: ../../../developing_packages/package_layout.rst:205
msgid ""
"It enables tools like the :ref:"
"`AutoPackager<conan_tools_files_autopackager>` to automate the **package()** "
"method."
msgstr ""

#: ../../../developing_packages/package_layout.rst:206
msgid ""
"It out-of-the-box enables to use :ref:`editable "
"packages<editable_packages>`, because the recipe describes where the "
"contents will be, even for different configurations, so the consumers can "
"link with the correct built artifacts."
msgstr ""

#: ../../../developing_packages/package_layout.rst:212
msgid "Declaring the layout"
msgstr ""

#: ../../../developing_packages/package_layout.rst:214
msgid "In the ``layout()`` method, you can set:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:216
#: ../../../developing_packages/package_layout.rst:317
msgid "**self.folders**"
msgstr ""

#: ../../../developing_packages/package_layout.rst:218
msgid "**self.folders.source**: To specify a folder where your sources are."
msgstr ""

#: ../../../developing_packages/package_layout.rst:219
msgid ""
"**self.folders.build**: To specify a subfolder where the files from the "
"build are (or will be)."
msgstr ""

#: ../../../developing_packages/package_layout.rst:220
msgid ""
"**self.folders.generators**: To specify a subfolder where to write the files "
"from the generators and the toolchains (e.g. the `xx-config.cmake` files "
"from the ``CMakeDeps`` generator)."
msgstr ""

#: ../../../developing_packages/package_layout.rst:222
msgid ""
"**self.folders.imports**: To specify a subfolder where to write the files "
"copied when using the ``imports(self)`` method in a ``conanfile.py``."
msgstr ""

#: ../../../developing_packages/package_layout.rst:224
msgid ""
"**self.folders.root**: To specify the relative path from the ``conanfile."
"py`` to the root of the project, in case the ``conanfile.py`` is in a "
"subfolder and not in the project root. If defined, all the other paths will "
"be relative to the project root, not to the location of the ``conanfile.py``."
msgstr ""

#: ../../../developing_packages/package_layout.rst:228
msgid ""
"Check the :ref:`complete reference<layout_folders_reference>` of the **self."
"folders** attribute."
msgstr ""

#: ../../../developing_packages/package_layout.rst:230
msgid ""
"**self.cpp.source** and **self.cpp.build**: The same you set the ``self.cpp."
"package`` to describe the package folder after calling the ``package()`` "
"method, you can also describe the `source` and `build` folders."
msgstr ""

#: ../../../developing_packages/package_layout.rst:233
msgid ""
"**self.cpp.package**: You can use it as you use the **self.cpp_info** at the "
"``package_info(self)`` method. The **self.cpp_info** object will be "
"populated with the information declared in the ``self.cpp.package`` object, "
"so you can complete it or modify it later in the ``package_info(self)`` "
"method."
msgstr ""

#: ../../../developing_packages/package_layout.rst:237
msgid ""
"**self.layouts.source**, **self.layouts.build** and **self.layouts."
"package**, each one containing one instance of ``buildenv_info``, "
"``runenv_info`` and ``conf_info``. If the environment or configuration needs "
"to define values that depend on the current folders, it is necessary to "
"define them in the ``layout()`` method."
msgstr ""

#: ../../../developing_packages/package_layout.rst:243
msgid "Example: Everything together"
msgstr ""

#: ../../../developing_packages/package_layout.rst:245
msgid ""
"Let's say we are working in the project introduced in the section above:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:258
msgid "We are using the following **CMakeLists.txt**:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:260
msgid ""
"cmake_minimum_required(VERSION 3.15)\n"
"project(say CXX)\n"
"\n"
"add_library(say hello.cpp)\n"
"target_include_directories(say PUBLIC \"include\")\n"
"\n"
"add_executable(my_tool my_tool.cpp)\n"
"target_link_libraries(my_tool say)\n"
"\n"
"# The executables are generated at the \"bin\" folder\n"
"set_target_properties(my_tool PROPERTIES RUNTIME_OUTPUT_DIRECTORY "
"\"${CMAKE_BINARY_DIR}/bin\")"
msgstr ""

#: ../../../developing_packages/package_layout.rst:275
msgid "Let's see how we describe our project in the ``layout()`` method:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:277
msgid ""
"import os\n"
"from conan import ConanFile\n"
"from conan.tools.cmake import CMake\n"
"\n"
"\n"
"class SayConan(ConanFile):\n"
"    name = \"say\"\n"
"    version = \"0.1\"\n"
"    exports_sources = \"src/*\"\n"
"    ...\n"
"    def layout(self):\n"
"        self.folders.source = \"src\"\n"
"        build_type = str(self.settings.build_type).lower()\n"
"        self.folders.build = \"cmake-build-{}\".format(build_type)\n"
"        self.folders.generators = os.path.join(self.folders.build, "
"\"conan\")\n"
"\n"
"        self.cpp.package.libs = [\"say\"]\n"
"        self.cpp.package.includedirs = [\"include\"] # includedirs is "
"already set to this value by\n"
"                                                   # default, but declared "
"for completion\n"
"\n"
"        # this information is relative to the source folder\n"
"        self.cpp.source.includedirs = [\"include\"]  # maps to ./src/"
"include\n"
"\n"
"        # this information is relative to the build folder\n"
"        self.cpp.build.libdirs = [\".\"]             # maps to ./cmake-build-"
"<build_type>\n"
"        self.cpp.build.bindirs = [\"bin\"]           # maps to ./cmake-build-"
"<build_type>/bin\n"
"\n"
"    def build(self):\n"
"        cmake = CMake(self)\n"
"        cmake.configure()\n"
"        cmake.build()\n"
"        # we can also know where the executable we are building is\n"
"        self.run(os.path.join(self.build_folder, self.cpp.build.bindirs[0], "
"\"my_tool\"))"
msgstr ""

#: ../../../developing_packages/package_layout.rst:315
msgid "Let's review the ``layout()`` method changes:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:319
msgid ""
"As we have our sources in the ``src`` folder, ``self.folders.source`` is set "
"to \"**src**\"."
msgstr ""

#: ../../../developing_packages/package_layout.rst:320
msgid ""
"We set ``self.folders.build`` to be **cmake-build-release** or **cmake-build-"
"debug** depending on the build_type."
msgstr ""

#: ../../../developing_packages/package_layout.rst:321
msgid ""
"The ``self.folders.generators`` folder is where all files generated by Conan "
"will be stored so they don’t pollute the other folders."
msgstr ""

#: ../../../developing_packages/package_layout.rst:323
msgid ""
"Please, note that the values above are for a single-configuration CMake "
"generator. To support multi-configuration generators, such as Visual Studio, "
"you should make some changes to this layout. For a complete layout that "
"supports both single-config and multi-config, please check the :ref:"
"`cmake_layout()<conan_tools_layout_predefined_layouts>` in the Conan "
"documentation."
msgstr ""

#: ../../../developing_packages/package_layout.rst:327
msgid "**self.cpp**"
msgstr ""

#: ../../../developing_packages/package_layout.rst:329
msgid ""
"We can set the information about the package that the consumers need to use "
"by setting the conanfile’s ``cpp.package`` attributes values:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:331
msgid ""
"Declaring ``self.cpp.package.libs`` inside the ``layout()`` method is "
"equivalent to the “classic” ``self.cpp_info.libs`` declaration in the "
"``package_info()`` method."
msgstr ""

#: ../../../developing_packages/package_layout.rst:333
msgid ""
"Also, as you may know, ``self.cpp.package.includedirs`` is set to "
"``[\"include\"]`` by default, so there’s no need in declaring it but we are "
"leaving it here for completeness."
msgstr ""

#: ../../../developing_packages/package_layout.rst:336
msgid ""
"We can also describe the ``source`` and ``build`` folders with the ``cpp."
"source`` and ``cpp.build`` objects:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:338
msgid ""
"We are setting ``self.cpp.source.includedirs = [\"include\"]``. The ``self."
"folders.source`` information will be automatically prepended to that path "
"for consumers so, for example, when working with an editable package, Conan "
"will try to get the include files from the **./my_project_folder/src/"
"include** folder."
msgstr ""

#: ../../../developing_packages/package_layout.rst:341
msgid ""
"We set the ``self.cpp.build.libdirs`` to **[\".\"]**, so we are declaring "
"that, if we make the package ``editable``, the libraries will be at the **./"
"cmake-build-<build_type>** folder."
msgstr ""

#: ../../../developing_packages/package_layout.rst:343
msgid ""
"We set the ``self.cpp.build.bindirs`` to **[\"bin\"]**, because the "
"``CMakeLists.txt`` file is changing the ``RUNTIME_OUTPUT_DIRECTORY`` to that "
"directory."
msgstr ""

#: ../../../developing_packages/package_layout.rst:346
msgid "There is also an interesting line in the ``build(self)`` method:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:348
msgid ""
"  def build(self):\n"
"     ...\n"
"     # we can also know where is the executable we are building\n"
"     self.run(os.path.join(self.build_folder, self.cpp.build.bindirs[0], "
"\"my_tool\"))"
msgstr ""

#: ../../../developing_packages/package_layout.rst:356
msgid ""
"We are using the ``self.cpp.build.bindirs[0]`` folder to locate the "
"``my_tool``. This is a very recommended practice, especially when our layout "
"depends on the build system. For example, when using CMake with Visual "
"Studio, the binaries are typically built at **Release/** or **Debug/** "
"(multiconfiguration) but on Linux or macOS, the output folder will typically "
"be **\".\"**, so it is better to declare the layout ``self.cpp.build."
"bindirs`` following that logic and then just access the correct path if we "
"need to know where the resulting files of our build are. If you check the :"
"ref:`cmake_layout()<conan_tools_layout_predefined_layouts>`, you can see "
"that the predefined ``cmake_layout`` is doing exactly that when using a "
"multiconfiguration build system."
msgstr ""

#: ../../../developing_packages/package_layout.rst:364
msgid ""
"So, now we can run the conan local methods without taking much care of the "
"directories where the files are or the build files should be, because "
"everything is declared in the layout:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:377
msgid ""
"# This will write the toolchains and generator files from the dependencies "
"to cmake-build-debug/generators\n"
"$ conan install . -if=my_install -s build_type=Debug\n"
"\n"
"# In case we needed it (not the case as we don't have a source() method), "
"this would fetch the sources to the ./src folder\n"
"$ conan source . -if=my_install\n"
"\n"
"# This will build the project using the declared source folder and cmake-"
"build-debug as the build folder\n"
"$ conan build . -if=my_install"
msgstr ""

#: ../../../developing_packages/package_layout.rst:380
msgid ""
"Maybe you are wondering why the **install folder** is not parametrized and "
"has to be specified with the ``-if`` argument. Currently, Conan generates "
"several files like the ``graph_info.json`` and the ``conanbuildinfo.txt`` "
"that are read to restore the configuration saved (settings, options, etc) to "
"be applied in the local commands. That configuration is needed before "
"running the ``layout()`` method because the folders might depend on the "
"settings like in the previous example. It is a kind of a chicken-egg issue. "
"In Conan 2.0, likely, the configuration won't be stored, and the local "
"methods like :command:`conan build .` will compute the graph from arguments "
"(--profile, -s, -o...) and won't need the ``--if`` argument anymore, being "
"always trivial to run."
msgstr ""

#: ../../../developing_packages/package_layout.rst:390
msgid "Our current folder now looks like this:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:392
msgid ""
"<my_project_folder>\n"
"├── conanfile.py\n"
"├── src\n"
"│   ├── CMakeLists.txt\n"
"│   ├── hello.cpp\n"
"│   ├── my_tool.cpp\n"
"│   └── include\n"
"│       └── hello.h\n"
"└── cmake-build-debug\n"
"    ├── libsay.a\n"
"    └── bin\n"
"        └── my_tool"
msgstr ""

#: ../../../developing_packages/package_layout.rst:408
msgid ""
"We could put the package in editable mode and other packages that require it "
"would consume it in a completely transparent way, even locating the correct "
"**Release**/**Debug** artifacts."
msgstr ""

#: ../../../developing_packages/package_layout.rst:414
msgid "$ conan editable add . say/0.1"
msgstr ""

#: ../../../developing_packages/package_layout.rst:415
msgid ""
"When working with editable packages, the information set in ``self.cpp."
"source`` and ``self.cpp.build`` will be merged with the information set in "
"``self.cpp.package`` so that we don't have to declare again something like "
"``self.cpp.build.libs = [\"say\"]`` that is the same for the consumers, "
"independently of whether the package is in editable mode or not."
msgstr ""

#: ../../../developing_packages/package_layout.rst:420
msgid ""
"And of course, we can run also a ``conan create`` command. When the "
"``build(self)`` method is run in the conan cache, it is also able to locate "
"the ``my_tool`` correctly, because it is using the same ``folders.build``:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:424
msgid ""
"├── source\n"
"│   └── src\n"
"│       ├── CMakeLists.txt\n"
"│       ├── hello.cpp\n"
"│       ├── my_tool.cpp\n"
"│       └── include\n"
"│           └── hello.h\n"
"├── build\n"
"│   └── cmake-build-debug\n"
"│       ├── say.a\n"
"│       └── bin\n"
"│           └── my_app\n"
"└── package\n"
"    ├── lib\n"
"    │   └── say.a\n"
"    ├── bin\n"
"    │   └── my_app\n"
"    └── include\n"
"        └── hello.h"
msgstr ""

#: ../../../developing_packages/package_layout.rst:449
msgid ""
"The ``conan package`` local command has been disabled (will raise an "
"exception) when the ``layout()`` method is declared. If the package can be "
"consumed \"locally\" in a handy way, the use case for the ``conan package`` "
"method is only testing that the method is correctly coded, but that can also "
"be done with the ``conan export-pkg`` method. Thus, as part of the migration "
"to Conan 2.0, the ``conan package`` method will disappear."
msgstr ""

#: ../../../developing_packages/package_layout.rst:457
msgid "Example: export_sources_folder"
msgstr ""

#: ../../../developing_packages/package_layout.rst:459
msgid ""
"If we have this project, intended to create a package for a third-party "
"library which code is located externally:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:461
msgid ""
"├── conanfile.py\n"
"├── patches\n"
"│   └── mypatch\n"
"└── CMakeLists.txt"
msgstr ""

#: ../../../developing_packages/package_layout.rst:469
#: ../../../developing_packages/package_layout.rst:518
msgid "The ``conanfile.py`` would look like this:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:471
msgid ""
"import os\n"
"from conan import ConanFile\n"
"\n"
"\n"
"class Pkg(ConanFile):\n"
"    name = \"pkg\"\n"
"    version = \"0.1\"\n"
"    exports_sources = \"CMakeLists.txt\", \"patches*\"\n"
"\n"
"    def layout(self):\n"
"        self.folders.source = \"src\"\n"
"\n"
"    def source(self):\n"
"        # we are inside a \"src\" subfolder, as defined by layout\n"
"        # download something, that will be inside the \"src\" subfolder\n"
"        # access to patches and CMakeLists, to apply them, replace files is "
"done with:\n"
"        mypatch_path = os.path.join(self.export_sources_folder, \"patches/"
"mypatch\")\n"
"        cmake_path = os.path.join(self.export_sources_folder, \"CMakeLists."
"txt\")\n"
"        # patching, replacing, happens here\n"
"\n"
"    def build(self):\n"
"        # If necessary, the build() method also has access to the "
"export_sources_folder\n"
"        # for example if patching happens in build() instead of source()\n"
"        cmake_path = os.path.join(self.export_sources_folder, \"CMakeLists."
"txt\")"
msgstr ""

#: ../../../developing_packages/package_layout.rst:499
msgid ""
"We can see that the ``ConanFile.export_sources_folder`` can provide access "
"to the root folder of the sources:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:501
msgid "Locally it will be the folder where the ``conanfile.py`` lives"
msgstr ""

#: ../../../developing_packages/package_layout.rst:502
msgid ""
"In the cache it will be the \"source\" folder, that will contain a copy of "
"``CMakeLists.txt`` and ``patches``, while the \"source/src\" folder will "
"contain the actual downloaded sources."
msgstr ""

#: ../../../developing_packages/package_layout.rst:506
msgid "Example: conanfile in subfolder"
msgstr ""

#: ../../../developing_packages/package_layout.rst:508
msgid ""
"If we have this project, intended to package the code that is in the same "
"repo as the ``conanfile.py``, but the ``conanfile.py`` is not in the root of "
"the project:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:511
msgid ""
"├── CMakeLists.txt\n"
"└── conan\n"
"    └── conanfile.py"
msgstr ""

#: ../../../developing_packages/package_layout.rst:520
msgid ""
"import os\n"
"from conan import ConanFile\n"
"from conan.tools.files import load, copy\n"
"\n"
"\n"
"class Pkg(ConanFile):\n"
"    name = \"pkg\"\n"
"    version = \"0.1\"\n"
"\n"
"    def layout(self):\n"
"        # The root of the project is one level above\n"
"        self.folders.root = \"..\"\n"
"        # The source of the project (the root CMakeLists.txt) is the source "
"folder\n"
"        self.folders.source = \".\"\n"
"        self.folders.build = \"build\"\n"
"\n"
"    def export_sources(self):\n"
"        # The path of the CMakeLists.txt we want to export is one level "
"above\n"
"        folder = os.path.join(self.recipe_folder, \"..\")\n"
"        copy(self, \"*.txt\", folder, self.export_sources_folder)\n"
"\n"
"    def source(self):\n"
"        # we can see that the CMakeLists.txt is inside the source folder\n"
"        cmake = load(self, \"CMakeLists.txt\")\n"
"\n"
"    def build(self):\n"
"        # The build() method can also access the CMakeLists.txt in the "
"source folder\n"
"        path = os.path.join(self.source_folder, \"CMakeLists.txt\")\n"
"        cmake = load(self, path)"
msgstr ""

#: ../../../developing_packages/package_layout.rst:555
msgid "Example: Multiple subprojects"
msgstr ""

#: ../../../developing_packages/package_layout.rst:557
msgid ""
"Lets say that we have a project that contains multiple subprojects, and some "
"of these subprojects need to access some information that is at their same "
"level (sibling folders). Each subproject would be a Conan package."
msgstr ""

#: ../../../developing_packages/package_layout.rst:561
msgid "So we have the following folders and files:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:563
msgid ""
"├── pkg\n"
"│    ├── conanfile.py\n"
"│    ├── app.cpp  # contains an #include \"../common/myheader.h\"\n"
"│    └── CMakeLists.txt # contains include(../common/myutils.cmake)\n"
"├── common\n"
"│    ├── myutils.cmake\n"
"│    └── myheader.h\n"
"└── othersubproject"
msgstr ""

#: ../../../developing_packages/package_layout.rst:575
msgid ""
"The ``pkg`` subproject needs to use some of the files located inside the "
"``common`` folder (that might be used and shared by other subprojects too), "
"and it references them by their relative location. Note that ``common`` is "
"not intended to be a Conan package. It is just some common code that will be "
"copied into the different subproject packages."
msgstr ""

#: ../../../developing_packages/package_layout.rst:580
msgid ""
"We can use the ``self.folders.root = \"..\"`` layout specifier to locate the "
"root of the project, then use the ``self.folders.subproject = "
"\"subprojectfolder\"`` to relocate back most of the layout to the current "
"subproject folder, as it would be the one containing the build scripts, "
"sources code, etc., so other helpers like ``cmake_layout()`` keep working."
msgstr ""

#: ../../../developing_packages/package_layout.rst:586
msgid ""
"import os\n"
"from conan import ConanFile\n"
"from conan.tools.cmake import cmake_layout, CMake\n"
"from conan.tools.files import load, copy, save\n"
"\n"
"class Pkg(ConanFile):\n"
"    name = \"pkg\"\n"
"    version = \"0.1\"\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"    generators = \"CMakeToolchain\"\n"
"\n"
"    def layout(self):\n"
"        self.folders.root = \"..\"\n"
"        self.folders.subproject = \"pkg\"\n"
"        cmake_layout(self)\n"
"\n"
"    def export_sources(self):\n"
"        source_folder = os.path.join(self.recipe_folder, \"..\")\n"
"        copy(self, \"*\", source_folder, self.export_sources_folder)\n"
"\n"
"    def build(self):\n"
"        cmake = CMake(self)\n"
"        cmake.configure()\n"
"        cmake.build()\n"
"        self.run(os.path.join(self.cpp.build.bindirs[0], \"myapp\"))"
msgstr ""

#: ../../../developing_packages/package_layout.rst:615
msgid ""
"Note it is very important the ``export_sources()`` method, that is able to "
"maintain the same relative layout of the ``pkg`` and ``common`` folders, "
"both in the local developer flow in the current folder, but also when those "
"sources are copied to the Conan cache, to be built there with ``conan "
"create`` or ``conan install --build=pkg``. This is one of the design "
"principles of the ``layout()``, the relative location of things must be "
"consistent in the user folder and in the cache."
msgstr ""

#: ../../../developing_packages/package_layout.rst:623
msgid "Environment variables and configuration"
msgstr ""

#: ../../../developing_packages/package_layout.rst:625
msgid ""
"There are some packages that might define some environment variables in "
"their ``package_info()`` method via ``self.buildenv_info``, ``self."
"runenv_info``. Other packages can also use ``self.conf_info`` to pass "
"configuration to their consumers."
msgstr ""

#: ../../../developing_packages/package_layout.rst:629
msgid ""
"This is not an issue as long as the value of those environment variables or "
"configuration do not require using the ``self.package_folder``. If they do, "
"then their values will not be correct for the \"source\" and \"build\" "
"layouts. Something like this will be **broken** when used in ``editable`` "
"mode:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:634
msgid ""
"import os\n"
"from conan import ConanFile\n"
"\n"
"class SayConan(ConanFile):\n"
"    ...\n"
"    def package_info(self):\n"
"        # This is BROKEN if we put this package in editable mode\n"
"        self.runenv_info.define_path(\"MYDATA_PATH\",\n"
"                                     os.path.join(self.package_folder, \"my/"
"data/path\"))"
msgstr ""

#: ../../../developing_packages/package_layout.rst:646
msgid ""
"When the package is in editable mode, for example, ``self.package_folder`` "
"is ``None``, as obviously there is no package yet. The solution is to define "
"it in the ``layout()`` method, in the same way the ``cpp_info`` can be "
"defined there:"
msgstr ""

#: ../../../developing_packages/package_layout.rst:651
msgid ""
"from conan import ConanFile\n"
"\n"
"class SayConan(ConanFile):\n"
"    ...\n"
"    def layout(self):\n"
"        # The final path will be relative to the self.source_folder\n"
"        self.layouts.source.buildenv_info.define_path(\"MYDATA_PATH\", \"my/"
"source/data/path\")\n"
"        # The final path will be relative to the self.build_folder\n"
"        self.layouts.build.buildenv_info.define_path(\"MYDATA_PATH2\", \"my/"
"build/data/path\")\n"
"        # The final path will be relative to the self.build_folder\n"
"        self.layouts.build.conf_info.define_path(\"MYCONF\", "
"\"my_conf_folder\")"
msgstr ""

#: ../../../developing_packages/package_layout.rst:666
msgid ""
"The ``layouts`` object contains ``source``, ``build`` and ``package`` "
"scopes, and each one contains one instance of ``buildenv_info``, "
"``runenv_info`` and ``conf_info``."
msgstr ""
