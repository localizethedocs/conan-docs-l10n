# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2022, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.48\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:4
msgid "``cmake_paths`` generator"
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:6
msgid ""
"This generator is especially useful if you are using ``CMake`` based only on "
"the ``find_package`` feature to locate the dependencies."
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:9
msgid ""
"The ``cmake_paths`` generator creates a file named ``conan_paths.cmake`` "
"declaring:"
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:11
msgid ""
"``CMAKE_MODULE_PATH`` with the folders of the required packages, to allow "
"CMake to locate the included cmake scripts and ``FindXXX.cmake`` files. The "
"folder containing the *conan_paths.cmake* (`self.install_folder` when used "
"in a recipe) is also included, so any custom file will be located too. "
"Check :ref:`cmake_find_package_generator` generator."
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:14
msgid ""
"``CMAKE_PREFIX_PATH`` used by ``find_library()`` to locate library files (*."
"a*, *.lib*, *.so*, *.dll*) in your packages and ``find_dependency()`` to "
"locate the transitive dependencies."
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:17
msgid "conanfile.txt"
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:17
msgid ""
" [requires]\n"
" zlib/1.2.11\n"
" ...\n"
"\n"
" [generators]\n"
" cmake_paths"
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:27
#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:77
msgid "CMakeList.txt"
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:27
msgid ""
" cmake_minimum_required(VERSION 3.0)\n"
" project(helloworld)\n"
" add_executable(helloworld hello.c)\n"
" find_package(Zlib)\n"
" if(ZLIB_FOUND)\n"
"    include_directories(${ZLIB_INCLUDE_DIRS})\n"
"    target_link_libraries (helloworld ${ZLIB_LIBRARIES})\n"
" endif()"
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:40
msgid ""
"In the example above, the ``zlib/1.2.11`` package is not packaging a custom "
"``FindZLIB.cmake`` file, but the ``FindZLIB.cmake`` included in the CMake "
"installation directory (`/Modules`) will locate the zlib library from the "
"Conan package because of the ``CMAKE_PREFIX_PATH`` used by the "
"``find_library()``."
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:44
msgid ""
"If the ``zlib/1.2.11`` would have included a custom ``FindZLIB.cmake`` in "
"the package root folder or any declared :ref:`self.cpp_info.builddirs "
"<cpp_info_attributes_reference>`, it would have been located because of the "
"``CMAKE_MODULE_PATH`` variable."
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:48
msgid "Included as a toolchain"
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:50
msgid ""
"You can use the *conan_paths.cmake* as a toolchain without modifying your "
"*CMakeLists.txt* file:"
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:52
msgid ""
" $ mkdir build && cd build\n"
" $ conan install ..\n"
" $ cmake .. -DCMAKE_TOOLCHAIN_FILE=conan_paths.cmake -G \"Unix Makefiles\" -"
"DCMAKE_BUILD_TYPE=Release\n"
" $ cmake --build ."
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:61
msgid "Included using the ``CMAKE_PROJECT_<PROJECT-NAME>_INCLUDE``"
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:63
msgid ""
"With ``CMAKE_PROJECT_<PROJECT-NAME>_INCLUDE`` you can specify a file to be "
"included by the ``project()`` command. If you already have a toolchain file "
"you can use this variable to include the ``conan_paths.cmake`` and insert "
"your toolchain with the ``CMAKE_TOOLCHAIN_FILE``."
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:67
msgid ""
"$ mkdir build && cd build\n"
"$ conan install ..\n"
"$ cmake .. -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release -"
"DCMAKE_PROJECT_helloworld_INCLUDE=build/conan_paths.cmake\n"
"$ cmake --build ."
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:75
msgid "Included in your *CMakeLists.txt*"
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:77
msgid ""
" cmake_minimum_required(VERSION 3.0)\n"
" project(helloworld)\n"
"\n"
" include(${CMAKE_BINARY_DIR}/conan_paths.cmake)\n"
"\n"
" add_executable(helloworld hello.c)\n"
"\n"
" find_package(zlib)\n"
"\n"
" if(ZLIB_FOUND)\n"
"    include_directories(${ZLIB_INCLUDE_DIRS})\n"
"    target_link_libraries (helloworld ${ZLIB_LIBRARIES})\n"
" endif()"
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:95
msgid ""
"$ mkdir build && cd build\n"
"$ conan install ..\n"
"$ cmake .. -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release\n"
"$ cmake --build ."
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:104
msgid ""
"Check the section :ref:`cmake_paths_generator_reference` to read more about "
"this generator."
msgstr ""

#: ../../../integrations/build_system/cmake/cmake_paths_generator.rst:108
msgid ""
"The ``CMAKE_MODULE_PATH`` and ``CMAKE_PREFIX_PATH`` contain the paths to the "
"``builddirs`` of every required package. By default the root package folder "
"is the only declared ``builddirs`` directory. Check :ref:"
"`cpp_info_attributes_reference`."
msgstr ""
