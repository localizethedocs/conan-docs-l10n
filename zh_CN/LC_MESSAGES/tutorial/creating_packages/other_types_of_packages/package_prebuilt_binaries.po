# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2024, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 2.22\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-09 17:34+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:4
msgid "Package prebuilt binaries"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:6
msgid ""
"There are specific scenarios in which it is necessary to create packages "
"from existing binaries, for example from 3rd parties or binaries previously "
"built by another process or team that is not using Conan. Under these "
"circumstances, building from sources is not what you want."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:10
msgid "You can package the local files in the following scenarios:"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:12
msgid ""
"When you are developing your package locally and you want to quickly create "
"a package with the built artifacts, but as you don't want to rebuild again "
"(clean copy) your artifacts, you don't want to call :command:`conan create`. "
"This method will keep your local project build if you are using an IDE."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:14
msgid ""
"When you cannot build the packages from sources (when only pre-built "
"binaries are available) and you have them in a local directory."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:16
msgid ""
"Same as 2 but you have the precompiled libraries in a remote repository."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:20
msgid "Locally building binaries"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:22
msgid ""
"Use the :command:`conan new` command to create a \"Hello World\" C++ library "
"example project:"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:24
msgid "$ conan new cmake_lib -d name=hello -d version=0.1"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:29
msgid "This will create a Conan package project with the following structure."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:31
msgid ""
".\n"
"├── CMakeLists.txt\n"
"├── conanfile.py\n"
"├── include\n"
"│   └── hello.h\n"
"├── src\n"
"│   └── hello.cpp\n"
"└── test_package\n"
"    ├── CMakeLists.txt\n"
"    ├── conanfile.py\n"
"    └── src\n"
"        └── example.cpp"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:47
msgid ""
"We have a ``CMakeLists.txt`` file in the root, a ``src`` folder with the "
"``cpp`` files, and an ``include`` folder for the headers. There's also a "
"``test_package/`` folder to test that the exported package is working "
"correctly."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:51
msgid ""
"Now, for every different configuration (different compilers, architectures, "
"build_type, ...):"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:53
msgid ""
"We call :command:`conan install` to generate the ``conan_toolchain.cmake`` "
"file and the ``CMakeUserPresets.json`` that can be used in our IDE or when "
"calling CMake (only >= 3.23)."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:56
msgid "$ conan install . -s build_type=Release"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:60
msgid "We build our project calling CMake, our IDE, etc.:"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:62
msgid "Linux, macOS"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:62
msgid ""
"$ mkdir -p build/Release\n"
"$ cd build/Release\n"
"$ cmake ../.. -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=../Release/"
"generators/conan_toolchain.cmake\n"
"$ cmake --build ."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:71
msgid "Windows"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:71
msgid ""
"$ mkdir -p build\n"
"$ cd build\n"
"$ cmake ..  -DCMAKE_TOOLCHAIN_FILE=generators/conan_toolchain.cmake\n"
"$ cmake --build . --config Release"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:82
msgid ""
"As we are directly using our IDE or CMake to build the library, the "
"``build()`` method of the recipe is never called and could be removed."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:85
msgid "We call :command:`conan export-pkg` to package the built artifacts."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:87
msgid ""
"$ cd ../..\n"
"$ conan export-pkg . -s build_type=Release\n"
"...\n"
"hello/0.1: Calling package()\n"
"hello/0.1 package(): Packaged 1 '.h' file: hello.h\n"
"hello/0.1 package(): Packaged 1 '.a' file: libhello.a\n"
"...\n"
"hello/0.1: Package '54a3ab9b777a90a13e500dd311d9cd70316e9d55' created"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:99
msgid ""
"Let's look more closely at the package method. The generated ``package()`` "
"method is using ``cmake.install()`` to copy the artifacts from our local "
"folders to the Conan package."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:102
msgid ""
"There is an alternative and generic ``package()`` method that could be used "
"for any build system:"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:104
msgid ""
"def package(self):\n"
"    local_include_folder = os.path.join(self.source_folder, self.cpp.source."
"includedirs[0])\n"
"    local_lib_folder = os.path.join(self.build_folder, self.cpp.build."
"libdirs[0])\n"
"    copy(self, \"*.h\", local_include_folder, os.path.join(self."
"package_folder, \"include\"), keep_path=False)\n"
"    copy(self, \"*.lib\", local_lib_folder, os.path.join(self."
"package_folder, \"lib\"), keep_path=False)\n"
"    copy(self, \"*.a\", local_lib_folder, os.path.join(self.package_folder, "
"\"lib\"), keep_path=False)"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:113
msgid ""
"This  ``package()`` method is copying artifacts from the following "
"directories that, thanks to the ``layout()`` method, will always point to "
"the correct places:"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:116
msgid ""
"**os.path.join(self.source_folder, self.cpp.source.includedirs[0])** will "
"always point to our local include folder."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:117
msgid ""
"**os.path.join(self.build_folder, self.cpp.build.libdirs[0])** will always "
"point to the location of the libraries when they are built, no matter if "
"using a single-config CMake Generator or a multi-config one."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:120
msgid "We can test the built package calling :command:`conan test`:"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:122
msgid ""
"$ conan test test_package/conanfile.py hello/0.1 -s build_type=Release\n"
"\n"
"-------- Testing the package: Running test() ----------\n"
"hello/0.1 (test package): Running test()\n"
"hello/0.1 (test package): RUN: ./example\n"
"hello/0.1: Hello World Release!\n"
"  hello/0.1: __x86_64__ defined\n"
"  hello/0.1: __cplusplus199711\n"
"  hello/0.1: __GNUC__4\n"
"  hello/0.1: __GNUC_MINOR__2\n"
"  hello/0.1: __clang_major__13\n"
"  hello/0.1: __clang_minor__1\n"
"  hello/0.1: __apple_build_version__13160021"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:139
msgid ""
"Now you can try to generate a binary package for ``build_type=Debug`` "
"running the same steps but changing the ``build_type``. You can repeat this "
"process any number of times for different configurations."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:144
msgid "Packaging already pre-built Binaries"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:146
#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:304
msgid ""
"Please, first clone the sources to recreate this project. You can find them "
"in the `examples2 repository <https://github.com/conan-io/examples2>`_ on "
"GitHub:"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:149
msgid ""
"$ git clone https://github.com/conan-io/examples2.git\n"
"$ cd examples2/tutorial/creating_packages/other_packages/prebuilt_binaries"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:154
msgid ""
"This is an example of scenario 2 explained in the introduction. If you have "
"a local folder containing the binaries for different configurations, you can "
"package them using the following approach."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:158
msgid ""
"These are the files of our example, (be aware that the library files are "
"only empty files so not valid libraries):"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:160
msgid ""
".\n"
"├── conanfile.py\n"
"└── vendor_hello_library\n"
"    ├── linux\n"
"    │   ├── armv8\n"
"    │   │   ├── include\n"
"    │   │   │   └── hello.h\n"
"    │   │   └── libhello.a\n"
"    │   └── x86_64\n"
"    │       ├── include\n"
"    │       │   └── hello.h\n"
"    │       └── libhello.a\n"
"    ├── macos\n"
"    │   ├── armv8\n"
"    │   │   ├── include\n"
"    │   │   │   └── hello.h\n"
"    │   │   └── libhello.a\n"
"    │   └── x86_64\n"
"    │       ├── include\n"
"    │       │   └── hello.h\n"
"    │       └── libhello.a\n"
"    └── windows\n"
"        ├── armv8\n"
"        │   ├── hello.lib\n"
"        │   └── include\n"
"        │       └── hello.h\n"
"        └── x86_64\n"
"            ├── hello.lib\n"
"            └── include\n"
"                └── hello.h"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:194
msgid ""
"We have folders and subfolders corresponding to the settings ``os`` and "
"``arch``. This the recipe of our example:"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:197
msgid ""
"import os\n"
"from conan import ConanFile\n"
"from conan.tools.files import copy\n"
"\n"
"\n"
"class helloRecipe(ConanFile):\n"
"    name = \"hello\"\n"
"    version = \"0.1\"\n"
"    settings = \"os\", \"arch\"\n"
"\n"
"    def layout(self):\n"
"        _os = str(self.settings.os).lower()\n"
"        _arch = str(self.settings.arch).lower()\n"
"        self.folders.build = os.path.join(\"vendor_hello_library\", _os, "
"_arch)\n"
"        self.folders.source = self.folders.build\n"
"        self.cpp.source.includedirs = [\"include\"]\n"
"        self.cpp.build.libdirs = [\".\"]\n"
"\n"
"    def package(self):\n"
"        local_include_folder = os.path.join(self.source_folder, self.cpp."
"source.includedirs[0])\n"
"        local_lib_folder = os.path.join(self.build_folder, self.cpp.build."
"libdirs[0])\n"
"        copy(self, \"*.h\", local_include_folder, os.path.join(self."
"package_folder, \"include\"), keep_path=False)\n"
"        copy(self, \"*.lib\", local_lib_folder, os.path.join(self."
"package_folder, \"lib\"), keep_path=False)\n"
"        copy(self, \"*.a\", local_lib_folder, os.path.join(self."
"package_folder, \"lib\"), keep_path=False)\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.libs = [\"hello\"]"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:229
msgid ""
"We are not building anything, so the ``build`` method is not useful here."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:230
msgid ""
"We can keep the same ``package`` method from the previous example because "
"the location of the artifacts is declared by the ``layout()``."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:232
msgid ""
"Both the source folder (with headers) and the build folder (with libraries) "
"are in the same location, in a path that follows:"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:234
msgid "``vendor_hello_library/{os}/{arch}``"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:236
msgid ""
"The headers are in the ``include`` subfolder of the ``self.source_folder`` "
"(we declare it in ``self.cpp.source.includedirs``)."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:237
msgid ""
"The libraries are in the root of the ``self.build_folder`` folder (we "
"declare ``self.cpp.build.libdirs = [\".\"]``)."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:238
msgid ""
"We removed the ``compiler`` and the ``build_type`` because we only have "
"different libraries depending on the operating system and the architecture "
"(it might be a pure C library)."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:242
msgid ""
"Now, for each different configuration, we run the :command:`conan export-"
"pkg` command. Later, we can list the binaries so we can check we have one "
"package for each precompiled library:"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:245
msgid ""
"$ conan export-pkg . -s os=\"Linux\" -s arch=\"x86_64\"\n"
"$ conan export-pkg . -s os=\"Linux\" -s arch=\"armv8\"\n"
"$ conan export-pkg . -s os=\"Macos\" -s arch=\"x86_64\"\n"
"$ conan export-pkg . -s os=\"Macos\" -s arch=\"armv8\"\n"
"$ conan export-pkg . -s os=\"Windows\" -s arch=\"x86_64\"\n"
"$ conan export-pkg . -s os=\"Windows\" -s arch=\"armv8\"\n"
"\n"
"$ conan list \"hello/0.1#:*\"\n"
"Local Cache\n"
"  hello\n"
"    hello/0.1\n"
"      revisions\n"
"        9c7634dfe0369907f569c4e583f9bc50 (2024-05-10 08:28:31 UTC)\n"
"          packages\n"
"            522dcea5982a3f8a5b624c16477e47195da2f84f\n"
"              info\n"
"                settings\n"
"                  arch: x86_64\n"
"                  os: Windows\n"
"            63fead0844576fc02943e16909f08fcdddd6f44b\n"
"              info\n"
"                settings\n"
"                  arch: x86_64\n"
"                  os: Linux\n"
"            82339cc4d6db7990c1830d274cd12e7c91ab18a1\n"
"              info\n"
"                settings\n"
"                  arch: x86_64\n"
"                  os: Macos\n"
"            a0cd51c51fe9010370187244af885b0efcc5b69b\n"
"              info\n"
"                settings\n"
"                  arch: armv8\n"
"                  os: Windows\n"
"            c93719558cf197f1df5a7f1d071093e26f0e44a0\n"
"              info\n"
"                settings\n"
"                  arch: armv8\n"
"                  os: Linux\n"
"            dcf68e932572755309a5f69f3cee1bede410e907\n"
"              info\n"
"                settings\n"
"                  arch: armv8\n"
"                  os: Macos"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:293
msgid ""
"In this example, we don't have a ``test_package/`` folder but you can "
"provide one to test the packages like in the previous example."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:298
msgid "Downloading and Packaging Pre-built Binaries"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:300
msgid ""
"This is an example of scenario 3 explained in the introduction. If we are "
"not building the libraries, we likely have them somewhere in a remote "
"repository. In this case, creating a complete Conan recipe with the detailed "
"retrieval of the binaries could be the preferred method, because it is "
"reproducible, and the original binaries might be traced."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:307
msgid ""
"$ git clone https://github.com/conan-io/examples2.git\n"
"$ cd examples2/tutorial/creating_packages/other_packages/"
"prebuilt_remote_binaries"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:313
msgid "conanfile.py"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:313
msgid ""
"import os\n"
"from conan.tools.files import get, copy\n"
"from conan import ConanFile\n"
"\n"
"\n"
"class HelloConan(ConanFile):\n"
"    name = \"hello\"\n"
"    version = \"0.1\"\n"
"    settings = \"os\", \"arch\"\n"
"\n"
"    def build(self):\n"
"        base_url = \"https://github.com/conan-io/libhello/releases/"
"download/0.0.1/\"\n"
"\n"
"        _os = {\"Windows\": \"win\", \"Linux\": \"linux\", \"Macos\": "
"\"macos\"}.get(str(self.settings.os))\n"
"        _arch = str(self.settings.arch).lower()\n"
"        url = \"{}/{}_{}.tgz\".format(base_url, _os, _arch)\n"
"        get(self, url)\n"
"\n"
"    def package(self):\n"
"        copy(self, \"*.h\", self.build_folder, os.path.join(self."
"package_folder, \"include\"))\n"
"        copy(self, \"*.lib\", self.build_folder, os.path.join(self."
"package_folder, \"lib\"))\n"
"        copy(self, \"*.a\", self.build_folder, os.path.join(self."
"package_folder, \"lib\"))\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.libs = [\"hello\"]"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:344
msgid ""
"Typically, pre-compiled binaries come for different configurations, so the "
"only task that the ``build()`` method has to implement is to map the "
"``settings`` to the different URLs."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:347
msgid ""
"We only need to call :command:`conan create` with different settings to "
"generate the needed packages:"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:350
msgid ""
"$ conan create . -s os=\"Linux\" -s arch=\"x86_64\"\n"
"$ conan create . -s os=\"Linux\" -s arch=\"armv8\"\n"
"$ conan create . -s os=\"Macos\" -s arch=\"x86_64\"\n"
"$ conan create . -s os=\"Macos\" -s arch=\"armv8\"\n"
"$ conan create . -s os=\"Windows\" -s arch=\"x86_64\"\n"
"$ conan create . -s os=\"Windows\" -s arch=\"armv8\"\n"
"\n"
"$ conan list \"hello/0.1#:*\"\n"
"Local Cache\n"
"  hello\n"
"    hello/0.1\n"
"      revisions\n"
"        d8e4debf31f0b7b5ec7ff910f76f1e2a (2024-05-10 09:13:16 UTC)\n"
"          packages\n"
"            522dcea5982a3f8a5b624c16477e47195da2f84f\n"
"              info\n"
"                settings\n"
"                  arch: x86_64\n"
"                  os: Windows\n"
"            63fead0844576fc02943e16909f08fcdddd6f44b\n"
"              info\n"
"                settings\n"
"                  arch: x86_64\n"
"                  os: Linux\n"
"            82339cc4d6db7990c1830d274cd12e7c91ab18a1\n"
"              info\n"
"                settings\n"
"                  arch: x86_64\n"
"                  os: Macos\n"
"            a0cd51c51fe9010370187244af885b0efcc5b69b\n"
"              info\n"
"                settings\n"
"                  arch: armv8\n"
"                  os: Windows\n"
"            c93719558cf197f1df5a7f1d071093e26f0e44a0\n"
"              info\n"
"                settings\n"
"                  arch: armv8\n"
"                  os: Linux\n"
"            dcf68e932572755309a5f69f3cee1bede410e907\n"
"              info\n"
"                settings\n"
"                  arch: armv8\n"
"                  os: Macos"
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:397
msgid ""
"It is recommended to include also a small consuming project in a "
"``test_package`` folder to verify the package is built correctly, and then "
"upload it to a Conan remote with :command:`conan upload`."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:400
msgid ""
"The same building policies apply: having a recipe fail if no Conan packages "
"are created, and the :command:`--build` argument is not defined. A typical "
"approach for this kind of package could be to define a :command:"
"`build_policy=\"missing\"`, especially if the URLs are also under the team's "
"control. If they are external (on the internet), it could be better to "
"create the packages and store them on your own Conan repository, so that the "
"builds do not rely on third-party URLs being available."
msgstr ""

#: ../../../tutorial/creating_packages/other_types_of_packages/package_prebuilt_binaries.rst:409
msgid ""
"`JFrog Academy Conan 2 Essentials: Creating a Recipe For Prebuilt Binaries "
"<https://academy.jfrog.com/conan-2-essentials/2269962?"
"utm_source=Conan+Docs>`__"
msgstr ""
