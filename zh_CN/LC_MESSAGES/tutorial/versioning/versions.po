# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2024, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 14:32+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../tutorial/versioning/versions.rst:4
msgid "Versions"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:6
msgid ""
"This section explains how different versions of a given package can be "
"created, first starting with manually changing the version attribute in the "
"``conanfile.py`` recipe, and then introducing the ``set_version()`` method "
"as a mechanism to automate the definition of the package version."
msgstr ""

#: ../../../tutorial/versioning/versions.rst:12
msgid ""
"This section uses very simple, empty recipes without building any code, so "
"without ``build()``, ``package()``, etc., to illustrate the versioning with "
"the simplest possible recipes, and allowing the examples to run easily and "
"to be very fast and simple. In real life, the recipes would be full-blown "
"recipes as seen in previous sections of the tutorial, building actual "
"libraries and packages."
msgstr ""

#: ../../../tutorial/versioning/versions.rst:18
msgid "Let's start with a very simple recipe:"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:20
#: ../../../tutorial/versioning/versions.rst:102
#: ../../../tutorial/versioning/versions.rst:135
#: ../../../tutorial/versioning/versions.rst:162
msgid "conanfile.py"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:20
msgid ""
"from conan import ConanFile\n"
"\n"
"class pkgRecipe(ConanFile):\n"
"    name = \"pkg\"\n"
"    version = \"1.0\"\n"
"\n"
"    # The recipe would export files and package them, but not really\n"
"    # necessary for the purpose of this part of the tutorial\n"
"    # exports_sources = \"include/*\"\n"
"    # def package(self):\n"
"    #    ..."
msgstr ""

#: ../../../tutorial/versioning/versions.rst:36
msgid "That we can create ``pkg/1.0`` package with:"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:38
msgid ""
"$ conan create .\n"
"...\n"
"pkg/1.0 .\n"
"...\n"
"\n"
"$ conan list *\n"
"Local Cache\n"
"pkg\n"
"    pkg/1.0"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:50
msgid ""
"If we now did some changes to the source files of this library, this would "
"be a new version, and we could change the ``conanfile.py`` version to "
"``version = \"1.1\"`` and create the new ``pkg/1.1`` version:"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:54
msgid ""
"# Make sure you modified conanfile.py to version=1.1\n"
"$ conan create .\n"
"...\n"
"pkg/1.1 .\n"
"...\n"
"\n"
"$ conan list *\n"
"Local Cache\n"
"pkg\n"
"    pkg/1.0\n"
"    pkg/1.1"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:68
msgid ""
"As we can see, now we see in our cache both ``pkg/1.0`` and ``pkg/1.1``. The "
"Conan cache can store any number of different versions and configurations "
"for the same ``pkg`` package."
msgstr ""

#: ../../../tutorial/versioning/versions.rst:73
msgid "Automating versions"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:75
msgid ""
"Instead of manually changing the version in ``conanfile.py``, it is possible "
"to automate it with 2 different approaches."
msgstr ""

#: ../../../tutorial/versioning/versions.rst:77
msgid ""
"First it is possible to provide the ``version`` directly in the command "
"line. In the example above, we could remove the ``version`` attribute from "
"the recipe and do:"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:80
msgid ""
"# Make sure you removed the version attribute in conanfile.py\n"
"$ conan create . --version=1.2\n"
"...\n"
"pkg/1.2 .\n"
"...\n"
"\n"
"$ conan list *\n"
"Local Cache\n"
"pkg\n"
"    pkg/1.0\n"
"    pkg/1.1\n"
"    pkg/1.2"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:96
msgid ""
"The other possibility is to use the ``set_version()`` method to define the "
"version dynamically, for example, if the version already exists in the "
"source code or in a text file, or it should be deduced from the git version."
msgstr ""

#: ../../../tutorial/versioning/versions.rst:99
msgid ""
"Let's assume that we have a ``version.txt`` file in the repo, that contains "
"just the version string ``1.3``. Then, this can be done:"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:102
msgid ""
"from conan import ConanFile\n"
"from conan.tools.files import  load\n"
"\n"
"\n"
"class pkgRecipe(ConanFile):\n"
"    name = \"pkg\"\n"
"\n"
"    def set_version(self):\n"
"        self.version = load(self, \"version.txt\")"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:116
msgid ""
"# No need to specify the version in CLI arg or in recipe attribute\n"
"$ conan create .\n"
"...\n"
"pkg/1.3 .\n"
"...\n"
"\n"
"$ conan list *\n"
"Local Cache\n"
"pkg\n"
"    pkg/1.0\n"
"    pkg/1.1\n"
"    pkg/1.2\n"
"    pkg/1.3"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:132
msgid ""
"It is also possible to combine the command line version definition, falling "
"back to reading from file if the command line argument is not provided with "
"the following syntax:"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:135
msgid ""
"def set_version(self):\n"
"    # if self.version is already defined from CLI --version arg, it will\n"
"    # not load version.txt\n"
"    self.version = self.version or load(self, \"version.txt\")"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:143
msgid ""
"# This will create the \"1.4\" version even if the version.txt file contains "
"\"1.3\"\n"
"$ conan create . --version=1.4\n"
"...\n"
"pkg/1.4 .\n"
"...\n"
"\n"
"$ conan list *\n"
"Local Cache\n"
"pkg\n"
"    pkg/1.0\n"
"    pkg/1.1\n"
"    pkg/1.2\n"
"    pkg/1.3\n"
"    pkg/1.4"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:160
msgid "Likewise, it is possible to obtain the version from a Git tag:"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:162
msgid ""
"from conan import ConanFile\n"
"from conan.tools.scm import Git\n"
"\n"
"class pkgRecipe(ConanFile):\n"
"    name = \"pkg\"\n"
"\n"
"    def set_version(self):\n"
"        git = Git(self)\n"
"        tag = git.run(\"describe --tags\")\n"
"        self.version = tag"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:177
msgid ""
"# assuming this is a git repo, and it was tagged to 1.5\n"
"$ git init .\n"
"$ git add .\n"
"$ git commit -m \"initial commit\"\n"
"$ git tag 1.5\n"
"$ conan create .\n"
"    ...\n"
"    pkg/1.5 .\n"
"    ...\n"
"\n"
"    $ conan list *\n"
"    Local Cache\n"
"    pkg\n"
"        pkg/1.0\n"
"        pkg/1.1\n"
"        pkg/1.2\n"
"        pkg/1.3\n"
"        pkg/1.4\n"
"        pkg/1.5"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:201
msgid "**Best practices**"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:203
msgid ""
"We could try to use something like the branch name or the commit as the "
"version number. However this might have some disadvantages, for example, "
"when this package is being required, it will need a explicit ``requires = "
"\"pkg/commit\"`` in every other package recipe requiring this one, and it "
"might be difficult to update consumers consistently, and to know if a newer "
"or older dependency is being used."
msgstr ""

#: ../../../tutorial/versioning/versions.rst:210
msgid "Requiring the new versions"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:212
msgid ""
"When a new package version is created, if other package recipes requiring "
"this one contain a explicit ``requires``, pinning the exact version like:"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:215
#: ../../../tutorial/versioning/versions.rst:228
msgid "app/conanfile.py"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:215
msgid ""
"from conan import ConanFile\n"
"\n"
"class AppRecipe(ConanFile):\n"
"    name = \"app\"\n"
"    version = \"1.0\"\n"
"    requires = \"pkg/1.0\""
msgstr ""

#: ../../../tutorial/versioning/versions.rst:225
msgid ""
"Then, installing or creating the ``app`` recipe will keep requiring and "
"using the ``pkg/1.0`` version and not the newer ones. To start using the new "
"``pkg`` versions, it is necessary to explicitly update the ``requires`` like:"
msgstr ""

#: ../../../tutorial/versioning/versions.rst:228
msgid ""
"from conan import ConanFile\n"
"\n"
"class AppRecipe(ConanFile):\n"
"    name = \"app\"\n"
"    version = \"1.0\"\n"
"    requires = \"pkg/1.5\""
msgstr ""

#: ../../../tutorial/versioning/versions.rst:239
msgid ""
"This process, while it achieves very good reproducibility and traceability, "
"can be a bit tedious if we are managing a large dependency graph and we want "
"to move forward to use the latest dependencies versions faster and with less "
"manual intervention. To automate this, the *version-ranges* explained in the "
"next section can be used."
msgstr ""
