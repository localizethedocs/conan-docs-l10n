# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2024, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 2.16\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 14:31+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:2
msgid "Products pipeline: distributed full pipeline with lockfiles"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:4
msgid ""
"This section will present the full and complete implementation of a multi-"
"product, multi-configuration distributed CI pipeline. It will cover "
"important implementation details:"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:7
msgid ""
"Using lockfiles to guarantee a consistent and fixed set of dependencies for "
"all configurations."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:8
msgid "Uploading built packages to the ``products`` repository."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:9
msgid "Capturing \"package lists\" and using them to run the final promotion."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:10
msgid "How to iterate the \"build-order\" programmatically"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:13
msgid ""
"Let's start as usual cleaning the local cache and defining the correct repos:"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:15
msgid ""
"# First clean the local \"build\" folder\n"
"$ pwd  # should be <path>/examples2/ci/game\n"
"$ rm -rf build  # clean the temporary build folder\n"
"$ mkdir build && cd build # To put temporary files\n"
"\n"
"$ conan remove \"*\" -c  # Make sure no packages from last run\n"
"# NOTE: The products repo is first, it will have higher priority.\n"
"$ conan remote enable products"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:27
msgid ""
"Similarly to what we did in the ``packages pipeline`` when we wanted to "
"ensure that the dependencies are exactly the same when building the "
"different configurations and products, the first necessary step is to "
"compute a ``conan.lock`` lockfile that we can pass to the different CI build "
"agents to enforce the same set of dependencies everywhere. This can be done "
"incrementally for the different ``products`` and configurations, aggregating "
"it in the final single ``conan.lock`` lockfile. This approach assumes that "
"both ``game/1.0`` and ``mapviewer/1.0`` will be using the same versions and "
"revisions of the common dependencies."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:29
msgid ""
"$ conan lock create --requires=game/1.0 --lockfile-out=conan.lock\n"
"$ conan lock create --requires=game/1.0 -s build_type=Debug --lockfile=conan."
"lock --lockfile-out=conan.lock\n"
"$ conan lock create --requires=mapviewer/1.0 --lockfile=conan.lock --"
"lockfile-out=conan.lock\n"
"$ conan lock create --requires=mapviewer/1.0 -s build_type=Debug --"
"lockfile=conan.lock --lockfile-out=conan.lock"
msgstr ""
"$ conan lock create --requires=game/1.0 --lockfile-out=conan.lock\n"
"$ conan lock create --requires=game/1.0 -s build_type=Debug --lockfile=conan."
"lock --lockfile-out=conan.lock\n"
"$ conan lock create --requires=mapviewer/1.0 --lockfile=conan.lock --"
"lockfile-out=conan.lock\n"
"$ conan lock create --requires=mapviewer/1.0 -s build_type=Debug --"
"lockfile=conan.lock --lockfile-out=conan.lock"

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:39
msgid ""
"Recall that the ``conan.lock`` arguments are mostly optional, as that is the "
"default lockfile name. The first command can be typed as ``conan lock create "
"--requires=game/1.0``. Also, all commands, including ``conan install``, if "
"they find a existing ``conan.lock`` file they will use it automatically, "
"without an explicit ``--lockfile=conan.lock``. The commands in this tutorial "
"are shown explicitly complete for completeness and didactical reasons."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:46
msgid ""
"Then, we can compute the build order for each product and configuration. "
"These commands are identical to the ones in the previous section, with the "
"only difference of adding a ``--lockfile=conan.lock`` argument:"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:50
msgid ""
"$ conan graph build-order --requires=game/1.0 --lockfile=conan.lock --"
"build=missing --order-by=recipe --format=json > game_release.json\n"
"$ conan graph build-order --requires=game/1.0 --lockfile=conan.lock --"
"build=missing -s build_type=Debug --order-by=recipe --format=json > "
"game_debug.json\n"
"$ conan graph build-order --requires=mapviewer/1.0 --lockfile=conan.lock --"
"build=missing --order-by=recipe --format=json > mapviewer_release.json\n"
"$ conan graph build-order --requires=mapviewer/1.0 --lockfile=conan.lock --"
"build=missing -s build_type=Debug --order-by=recipe --format=json > "
"mapviewer_debug.json"
msgstr ""
"$ conan graph build-order --requires=game/1.0 --lockfile=conan.lock --"
"build=missing --order-by=recipe --format=json > game_release.json\n"
"$ conan graph build-order --requires=game/1.0 --lockfile=conan.lock --"
"build=missing -s build_type=Debug --order-by=recipe --format=json > "
"game_debug.json\n"
"$ conan graph build-order --requires=mapviewer/1.0 --lockfile=conan.lock --"
"build=missing --order-by=recipe --format=json > mapviewer_release.json\n"
"$ conan graph build-order --requires=mapviewer/1.0 --lockfile=conan.lock --"
"build=missing -s build_type=Debug --order-by=recipe --format=json > "
"mapviewer_debug.json"

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:57
msgid ""
"Likewise the ``build-order-merge`` command will be identical to the previous "
"one. In this case, as this command doesn't really compute a dependency "
"graph, a ``conan.lock`` argument is not necessary, dependencies are not "
"being resolved:"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:62
msgid ""
"$ conan graph build-order-merge --file=game_release.json --file=game_debug."
"json --file=mapviewer_release.json --file=mapviewer_debug.json --reduce --"
"format=json > build_order.json"
msgstr ""
"$ conan graph build-order-merge --file=game_release.json --file=game_debug."
"json --file=mapviewer_release.json --file=mapviewer_debug.json --reduce --"
"format=json > build_order.json"

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:68
msgid ""
"So far, this process has been almost identical to the previous section one, "
"just with the difference of capturing and using a lockfile. Now, we will "
"explain the \"core\" of the ``products`` pipeline: iterating the build-order "
"and distributing the build, and gathering the resulting built packages."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:72
msgid ""
"This would be an example of some Python code that performs the iteration "
"sequentially (a real CI system would distribute the builds to different "
"agents in parallel):"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:75
msgid ""
"build_order = open(\"build_order.json\", \"r\").read()\n"
"build_order = json.loads(build_order)\n"
"to_build = build_order[\"order\"]\n"
"\n"
"pkg_lists = []  # to aggregate the uploaded package-lists\n"
"for level in to_build:\n"
"    for recipe in level:  # This could be executed in parallel\n"
"        ref = recipe[\"ref\"]\n"
"        # For every ref, multiple binary packages are being built.\n"
"        # This can be done in parallel too. Often it is for different "
"platforms\n"
"        # they will need to be distributed to different build agents\n"
"        for packages_level in recipe[\"packages\"]:\n"
"            # This could be executed in parallel too\n"
"            for package in packages_level:\n"
"                build_args = package[\"build_args\"]\n"
"                filenames = package[\"filenames\"]\n"
"                build_type = \"-s build_type=Debug\" if any(\"debug\" in f "
"for f in filenames) else \"\"\n"
"                run(f\"conan install {build_args} {build_type} --"
"lockfile=conan.lock --format=json\", file_stdout=\"graph.json\")\n"
"                run(\"conan list --graph=graph.json --format=json\", "
"file_stdout=\"built.json\")\n"
"                filename = f\"uploaded{len(pkg_lists)}.json\"\n"
"                run(f\"conan upload -l=built.json -r=products -c --"
"format=json\", file_stdout=filename)\n"
"                pkg_lists.append(filename)"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:103
msgid ""
"This code is specific for the ``--order-by=recipe`` build-order, if chosing "
"the ``--order-by=configuration``, the json is different and it would require "
"a different iteration."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:107
msgid "These are the tasks that the above Python code is doing:"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:109
msgid ""
"For every ``package`` in the build-order, a ``conan install --require=<pkg> "
"--build=<pkg>`` is issued, and the result of this command is stored in a "
"``graph.json`` file"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:110
msgid ""
"The ``conan list`` command transform this ``graph.json`` into a package list "
"called ``built.json``. Note that this package list actually stores both the "
"built packages and the necessary transitive dependencies. This is done for "
"simplicity, as later these package lists will be used for running a "
"promotion, and we also want to promote the dependencies such as ``ai/1.1.0`` "
"that were built in the ``packages pipeline`` and not by this job."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:111
msgid ""
"The ``conan upload`` command uploads the package list to the ``products`` "
"repo. Note that the ``upload`` first checks what packages already exist in "
"the repo, avoiding costly transfers if they already exist."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:112
msgid ""
"The result of the ``conan upload`` command is captured in a new package list "
"called ``uploaded<index>.json``, that we will accumulate later, that will "
"serve for the final promotion."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:115
msgid ""
"In practice this translates to the following commands (that you can execute "
"to continue the tutorial):"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:117
msgid ""
"# engine/1.0 release\n"
"$ conan install --requires=engine/1.0 --build=engine/1.0 --lockfile=conan."
"lock --format=json > graph.json\n"
"$ conan list --graph=graph.json --format=json > built.json\n"
"$ conan upload -l=built.json -r=products -c --format=json > uploaded1.json\n"
"\n"
"# engine/1.0 debug\n"
"$ conan install --requires=engine/1.0 --build=engine/1.0 --lockfile=conan."
"lock -s build_type=Debug --format=json > graph.json\n"
"$ conan list --graph=graph.json --format=json > built.json\n"
"$ conan upload -l=built.json -r=products -c --format=json > uploaded2.json\n"
"\n"
"# game/1.0 release\n"
"$ conan install --requires=game/1.0 --build=game/1.0 --lockfile=conan.lock --"
"format=json > graph.json\n"
"$ conan list --graph=graph.json --format=json > built.json\n"
"$ conan upload -l=built.json -r=products -c --format=json > uploaded3.json\n"
"\n"
"# game/1.0 debug\n"
"$ conan install --requires=game/1.0 --build=game/1.0 --lockfile=conan.lock -"
"s build_type=Debug --format=json > graph.json\n"
"$ conan list --graph=graph.json --format=json > built.json\n"
"$ conan upload -l=built.json -r=products -c --format=json > uploaded4.json"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:140
msgid ""
"After this step the newly built packages will be in the ``products`` repo "
"and we will have 4 ``uploaded1.json`` - ``uploaded4.json`` files."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:142
msgid ""
"Simplifying the different release and debug configurations, the state of our "
"repositories would be something like:"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:201
msgid ""
"We can now accumulate the different ``uploadedX.json`` files into a single "
"package list ``uploaded.json`` that contains everything:"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:203
msgid ""
"$ conan pkglist merge -l uploaded0.json -l uploaded1.json -l uploaded2.json -"
"l uploaded3.json --format=json > uploaded.json"
msgstr ""
"$ conan pkglist merge -l uploaded0.json -l uploaded1.json -l uploaded2.json -"
"l uploaded3.json --format=json > uploaded.json"

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:208
msgid ""
"And finally, if everything worked well, and we consider this new set of "
"versions and new package binaries is ready to be used by developers and "
"other CI jobs, then we can run the final promotion from the ``products`` to "
"the ``develop`` repository:"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:210
msgid "Promoting from products->develop"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:210
msgid ""
"# Promotion using Conan download/upload commands\n"
"# (slow, can be improved with art:promote custom command)\n"
"$ conan download --list=uploaded.json -r=products --format=json > promote."
"json\n"
"$ conan upload --list=promote.json -r=develop -c"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:219
msgid "And our final ``develop`` repository state will be:"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:276
msgid ""
"This state of the ``develop`` repository will have the following behavior:"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:278
msgid ""
"Developers installing ``game/1.0`` or ``engine/1.0`` will by default resolve "
"to latest ``ai/1.1.0`` and use it. They will find pre-compiled binaries for "
"the dependencies too, and they can continue developing using the latest set "
"of dependencies."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:279
msgid ""
"Developers and CI that were using a lockfile that was locking ``ai/1.0`` "
"version, will still be able to keep working with that dependency without "
"anything breaking, as the new versions and package binaries do not break or "
"invalidate the previous existing binaries."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:282
msgid ""
"At this point, the question of what to do with the lockfile used in the Ci "
"could arise. Note that the ``conan.lock`` now contains the ``ai/1.1.0`` "
"version locked. There could be different strategies, like storing this "
"lockfile in the \"products\" git repositories, making it easily available "
"when developers checkout those repos. Note, however, that this lockfile "
"matches the latest state of the ``develop`` repo, so developers checking out "
"one of the \"products\" git repositories and doing a ``conan install`` "
"against the ``develop`` server repository will naturally resolve to the same "
"dependencies stored in the lockfile."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:284
msgid ""
"It is a good idea to at least store this lockfile in any release bundle, if "
"the \"products\" are bundled somehow (a installer, a debian/rpm/choco/etc "
"package), to include or attach to this bundled release for the final users "
"of the software, the lockfile used to produce it, so no matter what changes "
"in development repositories, those lockfiles can be recovered from the "
"release information later in time."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:288
msgid "Final remarks"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:290
msgid ""
"As commented in this CI tutorial introduction, this doesn't pretend to be a "
"silver bullet, a CI system that you can deploy as-is in your organization. "
"This tutorial so far presents a \"happy path\" of a Continuous Integration "
"process for developers, and how their changes in packages that are part of "
"larger products can be tested and validated as part of those products."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:293
msgid ""
"The focus of this CI tutorial is to introduce some important concepts, good "
"practices and tools such as:"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:295
msgid ""
"The importance of defining the organization \"products\", the main "
"deliverables that need to be checked and built against new dependencies "
"versions created by developers."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:296
msgid ""
"How new dependencies versions of developers shouldn't be uploaded to the "
"main development repositories until validated, to not break other developers "
"and CI jobs."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:297
msgid ""
"How multiple repositories can be used to build a CI pipeline that isolate "
"non validated changes and new versions."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:298
msgid ""
"How large dependency graphs can be built efficiently in CI with the ``conan "
"graph build-order``, and how build-orders for different configurations and "
"products can be merged together."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:299
msgid ""
"Why ``lockfiles`` are necessary in CI when there are concurrent CI builds."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:300
msgid ""
"The importance of versioning, and the role of ``package_id`` to re-build "
"only what is necessary in large dependency graphs."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:301
msgid ""
"Not using ``user/channel`` as variable and dynamic qualifiers of packages "
"that change accross the CI pipeline, but using instead different server "
"repositories."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:302
msgid ""
"Running package promotions (copies) accross server repositories when new "
"package versions are validated."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:305
msgid ""
"There are still many implementation details, strategies, use cases, and "
"error scenarios that are not covered in this tutorial yet:"
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:307
msgid ""
"How to integrate breaking changes of a package that requires a new breaking "
"major version."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:308
msgid ""
"Different versioning strategies, using pre-releases, using versions or "
"relying on recipe revisions in certain cases."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:309
msgid ""
"How lockfiles can be stored and used accross different builds, if it is good "
"to persist them and where."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:310
msgid ""
"Different branching and merging strategies, nightly builds, releases flows."
msgstr ""

#: ../../../ci_tutorial/products_pipeline/full_pipeline.rst:312
msgid ""
"We plan to extend this CI tutorial, including more examples and use cases. "
"If you have any question or feedback, please create a ticket in https://"
"github.com/conan-io/conan/issues."
msgstr ""
