# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2022, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.54\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../creating_packages/existing_binaries.rst:4
msgid "Packaging Existing Binaries"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:6
msgid ""
"There are specific scenarios in which it is necessary to create packages "
"from existing binaries, for example from 3rd parties or binaries previously "
"built by another process or team that are not using Conan. Under these "
"circumstances building from sources is not what you want. You should package "
"the local files in the following situations:"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:10
msgid ""
"When you cannot build the packages from sources (when only pre-built "
"binaries are available)."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:11
msgid ""
"When you are developing your package locally and you want to export the "
"built artifacts to the local cache. As you don't want to rebuild again "
"(clean copy) your artifacts, you don't want to call :command:`conan create`. "
"This method will keep your build cache if you are using an IDE or calling "
"locally to the :command:`conan build` command."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:19
msgid "Packaging Pre-built Binaries"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:21
msgid ""
"Running the ``build()`` method, when the files you want to package are "
"local, results in no added value as the files copied from the user folder "
"cannot be reproduced. For this scenario, run :command:`conan export-pkg` "
"command directly."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:24
msgid ""
"A Conan recipe is still required, but is very simple and will only include "
"the package meta information. A basic recipe can be created with the :"
"command:`conan new` command:"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:26
msgid "$ conan new hello/0.1 --bare"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:30
msgid ""
"This will create and store the following package recipe in the local cache:"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:32
msgid ""
"class HelloConan(ConanFile):\n"
"    name = \"hello\"\n"
"    version = \"0.1\"\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"\n"
"    def package(self):\n"
"        self.copy(\"*\")\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.libs = self.collect_libs()"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:45
msgid ""
"The provided ``package_info()`` method scans the package files to provide "
"end-users with the name of the libraries to link to. This method can be "
"further customized to provide additional build flags (typically dependent on "
"the settings). The default ``package_info()`` applies as follows: it defines "
"headers in the \"include\" folder, libraries in the \"lib\" folder, and "
"binaries in the \"bin\" folder. A different package layout can be defined in "
"the ``package_info()`` method."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:51
msgid ""
"This package recipe can be also extended to provide support for more "
"configurations (for example, adding options: shared/static, or using "
"different settings), adding dependencies (``requires``), and more."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:55
msgid ""
"Based on the above, we can assume that our current directory contains a "
"*lib* folder with a number binaries for this \"hello\" library *libhello.a*, "
"compatible for example with Windows MinGW (gcc) version 4.9:"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:58
msgid ""
"$ conan export-pkg . hello/0.1@myuser/testing  -s os=Windows -s compiler=gcc "
"-s compiler.version=4.9 ..."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:62
msgid ""
"Having a *test_package* folder is still highly recommended for testing the "
"package locally before upload. As we don't want to build the package from "
"the sources, the flow would be:"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:65
msgid ""
"$ conan new hello/0.1 --bare --test\n"
"# customize test_package project\n"
"# customize package recipe if necessary\n"
"$ cd my/path/to/binaries\n"
"$ conan export-pkg PATH/TO/conanfile.py hello/0.1@myuser/testing  -s "
"os=Windows -s compiler=gcc -s compiler.version=4.9 ...\n"
"$ conan test PATH/TO/test_package/conanfile.py hello/0.1@myuser/testing -s "
"os=Windows -s compiler=gcc -s ..."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:74
msgid "The last two steps can be repeated for any number of configurations."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:77
msgid "Downloading and Packaging Pre-built Binaries"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:79
msgid ""
"In this scenario, creating a complete Conan recipe, with the detailed "
"retrieval of the binaries could be the preferred method, because it is "
"reproducible, and the original binaries might be traced. Follow our sample "
"recipe for this purpose:"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:83
msgid ""
"class HelloConan(ConanFile):\n"
"    name = \"hello\"\n"
"    version = \"0.1\"\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"\n"
"    def build(self):\n"
"        if self.settings.os == \"Windows\" and self.settings.compiler == "
"\"Visual Studio\":\n"
"            url = (\"https://<someurl>/downloads/hello_binary%s_%s.zip\"\n"
"                   % (str(self.settings.compiler.version), str(self.settings."
"build_type)))\n"
"        elif ...:\n"
"            url = ...\n"
"        else:\n"
"            raise Exception(\"Binary does not exist for these settings\")\n"
"        tools.get(url)\n"
"\n"
"    def package(self):\n"
"        self.copy(\"*\") # assume package as-is, but you can also copy "
"specific files or rearrange\n"
"\n"
"    def package_info(self):  # still very useful for package consumers\n"
"        self.cpp_info.libs = [\"hello\"]"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:106
msgid ""
"Typically, pre-compiled binaries come for different configurations, so the "
"only task that the ``build()`` method has to implement is to map the "
"``settings`` to the different URLs."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:111
msgid ""
"This is a standard Conan package even if the binaries are being retrieved "
"from elsewhere. The **recommended approach** is to use :command:`conan "
"create`, and include a small consuming project in addition to the above "
"recipe, to test locally and then proceed to upload the Conan package with "
"the binaries to the Conan remote with :command:`conan upload`."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:116
msgid ""
"The same building policies apply. Having a recipe fails if no Conan packages "
"are created, and the :command:`--build` argument is not defined. A typical "
"approach for this kind of packages could be to define a :command:"
"`build_policy=\"missing\"`, especially if the URLs are also under the team "
"control. If they are external (on the internet), it could be better to "
"create the packages and store them on your own Conan server, so that the "
"builds do not rely on third party URL being available."
msgstr ""
