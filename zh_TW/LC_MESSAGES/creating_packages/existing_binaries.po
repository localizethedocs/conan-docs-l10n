# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2018, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../creating_packages/existing_binaries.rst:4
msgid "Packaging existing binaries"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:6
msgid ""
"Sometimes, it is necessary to create packages from existing binaries, like "
"binaries from third parties, or previously built by another process or team "
"not using conan, so building from sources is not wanted. You would want to "
"package local files in two situations:"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:10
msgid ""
"When it is not possible to build the packages from sources (only pre-built "
"binaries available)."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:11
msgid ""
"When you are developing your package locally and want to export the built "
"artifacts to the local cache. As you don't want to rebuild again (clean "
"copy) your artifacts, you don't want to call :command:`conan create`. This "
"way you can keep your build cache if you are using an IDE or calling locally "
"to the :command:`conan build` command."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:19
msgid "Packaging pre-built binaries"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:21
msgid ""
"If the files we want to package are just local, creating a ``build()`` "
"method that would copy them from the user folder is not reproducible, so it "
"doesn't add any value. For this use case, it is possible to use :command:"
"`conan export-pkg` command directly."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:25
msgid ""
"A conan recipe is still needed, in this case it will be very simple, just "
"the meta information of the package. A basic recipe can be created with the :"
"command:`conan new` command:"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:28
msgid "$ conan new Hello/0.1 --bare"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:32
msgid ""
"This will create and store in the local cache the following package recipe:"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:34
msgid ""
"class HelloConan(ConanFile):\n"
"    name = \"Hello\"\n"
"    version = \"0.1\"\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"\n"
"    def package(self):\n"
"        self.copy(\"*\")\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.libs = self.collect_libs()"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:47
msgid ""
"The provided ``package_info()`` method will scan the package files to "
"provide the end consumers with the name of the libraries to link with. This "
"method can be further customized to provide other build flags (typically "
"conditioned to the settings). The default ``package_info()`` applies: it "
"will define headers in \"include\" folder, libraries in \"lib\" folder, "
"binaries in \"bin\" folder. A different package layout can be defined in "
"``package_info()`` method."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:53
msgid ""
"This package recipe can be also extended to provide support for more "
"configurations (for example, adding options: shared/static, or using "
"different settings), adding dependencies (``requires``), etc."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:57
msgid ""
"Then, we will assume that we have in our current directory a *lib* folder "
"with some binary for this \"hello\" library *libhello.a*, compatible for "
"example with Windows MinGW (gcc) version 4.9:"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:60
msgid ""
"$ conan export-pkg . Hello/0.1@myuser/testing  -s os=Windows -s compiler=gcc "
"-s compiler.version=4.9 ..."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:64
msgid ""
"Having a *test_package* folder is still very recommended, to locally test "
"the package before uploading. As we don't want to build the package from "
"sources, the flow would be:"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:67
msgid ""
"$ conan new Hello/0.1 --bare --test\n"
"# customize test_package project\n"
"# customize package recipe if necessary\n"
"$ cd my/path/to/binaries\n"
"$ conan export-pkg PATH/TO/conanfile.py Hello/0.1@myuser/testing  -s "
"os=Windows -s compiler=gcc -s compiler.version=4.9 ...\n"
"$ conan test PATH/TO/test_package/conanfile.py Hello/0.1@myuser/testing -s "
"os=Windows -s compiler=gcc -s ..."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:76
msgid "The last 2 steps can be repeated for any number of configurations."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:79
msgid "Downloading and Packaging pre-built binaries"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:81
msgid ""
"In this case, having a complete conan recipe, with the detailed retrieval of "
"the binaries could be the preferred way, because it has better "
"reproducibility, and the original binaries might be traced. Such a recipe "
"would be like:"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:85
msgid ""
"class HelloConan(ConanFile):\n"
"    name = \"Hello\"\n"
"    version = \"0.1\"\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"\n"
"    def build(self):\n"
"        if self.settings.os == \"Windows\" and self.compiler == \"Visual "
"Studio\":\n"
"            url = (\"https://<someurl>/downloads/hello_binary%s_%s.zip\"\n"
"                   % (str(self.settings.compiler.version), str(self.settings."
"build_type)))\n"
"        elif ...:\n"
"            url = ...\n"
"        else:\n"
"            raise Exception(\"Binary does not exist for these settings\")\n"
"        tools.get(url)\n"
"\n"
"    def package(self):\n"
"        self.copy(\"*\") # assume package as-is, but you can also copy "
"specific files or rearrange\n"
"\n"
"    def package_info(self):  # still very useful for package consumers\n"
"        self.cpp_info.libs = [\"hello\"]"
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:108
msgid ""
"Typically, pre-compiled binaries come for different configurations, so the "
"only task that the ``build()`` method has to implement is to map the "
"``settings`` to the different URLs."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:113
msgid ""
"This is a normal conan package, even if the binaries are being retrieved "
"from somewhere. The **recommended approach** is using :command:`conan "
"create`, and have a small consuming project besides the above recipe, to "
"test locally, then upload the conan package with the binaries to the conan "
"remote with :command:`conan upload`."
msgstr ""

#: ../../../creating_packages/existing_binaries.rst:118
msgid ""
"The same building policies apply. Having a recipe will fail if no conan "
"packages are created, and the :command:`--build` argument is not defined. A "
"typical approach for this kind of packages could be to define a :command:"
"`build_policy=\"missing\"`, especially if the URLs are also under the team "
"control. If they are external (internet), it could be better to create the "
"packages and store them in your own conan server, so builds do not rely on "
"the third party URL being available."
msgstr ""
