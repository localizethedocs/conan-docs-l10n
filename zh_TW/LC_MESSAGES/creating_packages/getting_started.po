# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2018, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:11+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../creating_packages/getting_started.rst:4
msgid "Getting started"
msgstr ""

#: ../../../creating_packages/getting_started.rst:6
msgid ""
"To start learning about creating packages, we will create a package from an "
"existing source code repository: https://github.com/memsharded/hello. You "
"can check that project, it is a very simple \"hello world\" C++ library, "
"using CMake as build system to build a library and an executable. It has "
"nothing related to conan in it."
msgstr ""

#: ../../../creating_packages/getting_started.rst:11
msgid ""
"We are using such github repository as an example, but the same process "
"would apply to other source code origins, like downloading a zip or tarball "
"from the internet."
msgstr ""

#: ../../../creating_packages/getting_started.rst:16
msgid ""
"For this concrete example you will need, besides a C++ compiler, both "
"*CMake* and *git* installed and in your path. They are not required by "
"conan, you could use your own build system and version control instead."
msgstr ""

#: ../../../creating_packages/getting_started.rst:21
msgid "Creating the package recipe"
msgstr ""

#: ../../../creating_packages/getting_started.rst:23
msgid ""
"First, let's create a folder for our package recipe, and use the :command:"
"`conan new` helper command that will create a working package recipe for us:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:26
msgid ""
"$ mkdir mypkg && cd mypkg\n"
"$ conan new Hello/0.1 -t"
msgstr ""

#: ../../../creating_packages/getting_started.rst:31
msgid "This will generate the following files:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:33
msgid ""
"conanfile.py\n"
"test_package\n"
"  conanfile.py\n"
"  CMakeLists.txt\n"
"  example.cpp"
msgstr ""

#: ../../../creating_packages/getting_started.rst:41
msgid ""
"At the root level, there is a *conanfile.py* which is the main recipe file, "
"the one actually defining our package. Also there is a *test_package* "
"folder, which contains a simple example consuming project that will require "
"and link with the created package. It is useful to make sure that our "
"package is correctly created."
msgstr ""

#: ../../../creating_packages/getting_started.rst:46
msgid "Let's have a look to the root package recipe *conanfile.py*:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:48
msgid ""
"from conans import ConanFile, CMake, tools\n"
"\n"
"class HelloConan(ConanFile):\n"
"    name = \"Hello\"\n"
"    version = \"0.1\"\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"    options = {\"shared\": [True, False]}\n"
"    default_options = \"shared=False\"\n"
"    generators = \"cmake\"\n"
"\n"
"    def source(self):\n"
"        self.run(\"git clone https://github.com/memsharded/hello.git\")\n"
"        self.run(\"cd hello && git checkout static_shared\")\n"
"        # This small hack might be useful to guarantee proper /MT /MD "
"linkage in MSVC\n"
"        # if the packaged project doesn't have variables to set it properly\n"
"        tools.replace_in_file(\"hello/CMakeLists.txt\", "
"\"PROJECT(MyHello)\", '''PROJECT(MyHello)\n"
"include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake)\n"
"conan_basic_setup()''')\n"
"\n"
"    def build(self):\n"
"        cmake = CMake(self)\n"
"        cmake.configure(source_folder=\"hello\")\n"
"        cmake.build()\n"
"\n"
"        # Explicit way:\n"
"        # self.run('cmake \"%s/hello\" %s' % (self.source_folder, cmake."
"command_line))\n"
"        # self.run(\"cmake --build . %s\" % cmake.build_config)\n"
"\n"
"    def package(self):\n"
"        self.copy(\"*.h\", dst=\"include\", src=\"hello\")\n"
"        self.copy(\"*hello.lib\", dst=\"lib\", keep_path=False)\n"
"        self.copy(\"*.dll\", dst=\"bin\", keep_path=False)\n"
"        self.copy(\"*.so\", dst=\"lib\", keep_path=False)\n"
"        self.copy(\"*.dylib\", dst=\"lib\", keep_path=False)\n"
"        self.copy(\"*.a\", dst=\"lib\", keep_path=False)\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.libs = [\"hello\"]"
msgstr ""

#: ../../../creating_packages/getting_started.rst:89
msgid ""
"This is a complete package recipe. Without worrying too much about every "
"detail, these are the basics:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:92
msgid ""
"The ``settings`` field defines the configuration that defines the different "
"binary packages. In this example we are defining that any change to the OS, "
"compiler, architecture or build type will generate a different binary "
"package. Remember, Conan generates different binary packages for different "
"introduced configuration (in this case settings) for the same recipe."
msgstr ""

#: ../../../creating_packages/getting_started.rst:97
msgid ""
"Note that the platform where the recipe is running and the package is being "
"build can be different from the final platform where the code will be "
"running (``self.settings.os`` and ``self.settings.arch``) if the package is "
"being cross-built. So if you want to apply a different build depending on "
"the current build machine, you need to check it:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:102
msgid ""
"def build(self):\n"
"    if platform.system() == \"Windows\":\n"
"        cmake = CMake(self)\n"
"        cmake.configure(source_folder=\"hello\")\n"
"        cmake.build()\n"
"    else:\n"
"        env_build = AutoToolsBuildEnvironment(self)\n"
"        env_build.configure()\n"
"        env_build.make()"
msgstr ""

#: ../../../creating_packages/getting_started.rst:114
msgid "Learn more in the :ref:`Cross building <cross_building>` section."
msgstr ""

#: ../../../creating_packages/getting_started.rst:116
msgid ""
"This package recipe is also able to create different binary packages for "
"static and shared libraries with the ``shared`` option, which is defaulted "
"to ``False`` (i.e. by default it will use static linkage)."
msgstr ""

#: ../../../creating_packages/getting_started.rst:120
msgid ""
"The ``source()`` method executes a :command:`git clone` to retrieve the "
"sources from github. Other origins, as downloading a zip file are also "
"available. As you can see, any manipulation of the code can be done, as "
"checking out any branch or tag, or patching the source code. In this "
"example, we are adding two lines to the existing CMake code, to ensure "
"binary compatibility. Don't worry too much about it now, we'll visit it "
"later."
msgstr ""

#: ../../../creating_packages/getting_started.rst:126
msgid ""
"The ``build()`` first configures the project, then builds it, with standard "
"CMake commands. The ``CMake`` object is just a helper to ease the "
"translation of conan settings to CMake command line arguments. Also remember "
"that **CMake is not strictly required**. You can build packages directly "
"invoking **make**, **MSBuild**, **SCons** or any other build system."
msgstr ""

#: ../../../creating_packages/getting_started.rst:131
msgid "Check the :ref:`existing build helpers <build_helpers>`."
msgstr ""

#: ../../../creating_packages/getting_started.rst:133
msgid ""
"The ``package()`` method copies artifacts (headers, libs) from the build "
"folder to the final package folder."
msgstr ""

#: ../../../creating_packages/getting_started.rst:136
msgid ""
"Finally, the ``package_info()`` method defines that consumer must link with "
"the \"hello\" library when using this package. Other information as include "
"or lib paths can be defined as well. This information is used for files "
"created by generators to be used by consumers, as *conanbuildinfo.cmake*."
msgstr ""

#: ../../../creating_packages/getting_started.rst:142
msgid "The test_package folder"
msgstr ""

#: ../../../creating_packages/getting_started.rst:146
msgid ""
"The **test_package** is different from the library unit or integration "
"tests, which should be more comprehensive. These tests are \"package\" "
"tests, and validate that the package is properly created, and that package "
"consumers will be able to link against it and reuse it."
msgstr ""

#: ../../../creating_packages/getting_started.rst:150
msgid ""
"If you have a look to the ``test_package`` folder, you will realize that the "
"``example.cpp`` and the ``CMakeLists.txt`` files don't have anything "
"special. The *test_package/conanfile.py* file is just another recipe, you "
"can think of it as the consumer *conanfile.txt* we have already seen in "
"previous sections:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:155
msgid ""
"from conans import ConanFile, CMake\n"
"import os\n"
"\n"
"class HelloTestConan(ConanFile):\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"    generators = \"cmake\"\n"
"\n"
"    def build(self):\n"
"        cmake = CMake(self)\n"
"        cmake.configure()\n"
"        cmake.build()\n"
"\n"
"    def imports(self):\n"
"        self.copy(\"*.dll\", dst=\"bin\", src=\"bin\")\n"
"        self.copy(\"*.dylib*\", dst=\"bin\", src=\"lib\")\n"
"\n"
"    def test(self):\n"
"        os.chdir(\"bin\")\n"
"        self.run(\".%sexample\" % os.sep)"
msgstr ""

#: ../../../creating_packages/getting_started.rst:177
msgid "The main differences with the above *conanfile.py* are:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:179
msgid ""
"It doesn't have a name and version, because we are not creating a package, "
"so they are not necessary."
msgstr ""

#: ../../../creating_packages/getting_started.rst:181
msgid ""
"The ``package()`` and ``package_info()`` methods are not required, since we "
"are not creating a package."
msgstr ""

#: ../../../creating_packages/getting_started.rst:183
msgid "The ``test()`` method specifies which binaries have to be run."
msgstr ""

#: ../../../creating_packages/getting_started.rst:184
msgid ""
"The ``imports()`` method is defined to copy shared libraries to the ``bin`` "
"folder, so when dynamic linkage is used, and the ``test()`` method launches "
"the ``example`` executable, they are found and ``example`` runs."
msgstr ""

#: ../../../creating_packages/getting_started.rst:190
msgid ""
"An important difference with respect to normal package recipes, is that this "
"one does not need to declare a ``requires`` attribute, to depend on the "
"``Hello/0.1@demo/testing`` package we are testing. This ``requires`` will be "
"automatically injected by conan while running. You can however declare it "
"explicitely, it will work, but you will have to remember to bump the "
"version, and possibly the user and channel if you change them."
msgstr ""

#: ../../../creating_packages/getting_started.rst:199
msgid "Creating and testing packages"
msgstr ""

#: ../../../creating_packages/getting_started.rst:201
msgid "We can create and test the package with our default settings simply by:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:203
msgid ""
"$ conan create . demo/testing\n"
"...\n"
"Hello world!"
msgstr ""

#: ../../../creating_packages/getting_started.rst:209
msgid "If you see \"Hello world!\", it worked."
msgstr ""

#: ../../../creating_packages/getting_started.rst:211
msgid "This will perform the following steps:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:213
msgid ""
"Copy (\"export\" in conan terms) the *conanfile.py* from the user folder "
"into the **local cache**."
msgstr ""

#: ../../../creating_packages/getting_started.rst:214
msgid "Install the package, forcing building it from sources."
msgstr ""

#: ../../../creating_packages/getting_started.rst:215
msgid ""
"Move to the *test_package* folder, and create a temporary *build* folder."
msgstr ""

#: ../../../creating_packages/getting_started.rst:216
msgid ""
"Execute there a :command:`conan install ..`, so it installs the requirements "
"of the *test_package/conanfile.py*. Note that it will build \"Hello\" from "
"sources."
msgstr ""

#: ../../../creating_packages/getting_started.rst:218
msgid ""
"Build and launch the *example* consuming application, calling the "
"*test_package/conanfile.py* ``build()`` and ``test()`` methods respectively."
msgstr ""

#: ../../../creating_packages/getting_started.rst:221
msgid ""
"Using conan commands, the :command:`conan create` command would be "
"equivalent to:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:223
msgid ""
"$ conan export . demo/testing\n"
"$ conan install Hello/0.1@demo/testing --build=Hello\n"
"# package is created now, use test to test it\n"
"$ conan test test_package Hello/0.1@demo/testing"
msgstr ""

#: ../../../creating_packages/getting_started.rst:230
msgid ""
"The :command:`conan create` command receives the same command line "
"parameters as :command:`conan install` so you can pass to it the same "
"settings, options, and command line switches. If you want to create and test "
"packages for different configurations, you could:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:234
msgid ""
"$ conan create . demo/testing -s build_type=Debug\n"
"$ conan create . demo/testing -o Hello:shared=True -s arch=x86\n"
"$ conan create . demo/testing -pr my_gcc49_debug_profile\n"
"...\n"
"$ conan create ..."
msgstr ""

#: ../../../creating_packages/getting_started.rst:246
msgid "Settings vs. options"
msgstr ""

#: ../../../creating_packages/getting_started.rst:248
msgid ""
"We have used settings as ``os``, ``arch`` and ``compiler``. But the above "
"package recipe also contains a ``shared`` option (defined as ``options = "
"{\"shared\": [True, False]}``). What is the difference between settings and "
"options?"
msgstr ""

#: ../../../creating_packages/getting_started.rst:252
msgid ""
"**Settings** are project-wide configuration, something that typically affect "
"to the whole project that is being built. For example the Operating System "
"or the architecture would be naturally the same for all packages in a "
"dependency graph, linking a Linux library for a Windows app, or mixing "
"architectures is impossible."
msgstr ""

#: ../../../creating_packages/getting_started.rst:257
msgid ""
"Settings cannot be defaulted in a package recipe. A recipe for a given "
"library cannot say that its default ``os=Windows``. The ``os`` will be given "
"by the environment in which that recipe is processed. It is a necessary "
"input."
msgstr ""

#: ../../../creating_packages/getting_started.rst:261
msgid ""
"Settings are configurable. You can edit, add, remove settings or subsettings "
"in your *settings.yml* file. See :ref:`the settings.yml reference "
"<settings_yml>`."
msgstr ""

#: ../../../creating_packages/getting_started.rst:264
msgid ""
"On the other hand, **options** are package-specific configuration. Being a "
"static or shared library is not something that applies to all packages. Some "
"can be header only libraries. Other packages can be just data, or package "
"executables. Or packages can contain a mixture of different artifacts. "
"``shared`` is a common option, but packages can define and use any options "
"they want."
msgstr ""

#: ../../../creating_packages/getting_started.rst:269
msgid ""
"Options are defined in the package recipe, including their allowed values, "
"and it can be defaulted by the package recipe itself. A package for a "
"library can well define that by default it will be a static library (a "
"typical default). If no one else specifies something different, the package "
"will be static."
msgstr ""

#: ../../../creating_packages/getting_started.rst:273
msgid ""
"There are some exceptions to the above, for example, settings can be defined "
"per-package, like in command line:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:275
msgid "$ conan install . -s MyPkg:compiler=gcc -s compiler=clang .."
msgstr ""

#: ../../../creating_packages/getting_started.rst:279
msgid ""
"This will use ``gcc`` for MyPkg and ``clang`` for the rest of the "
"dependencies (extremely unusual case)"
msgstr ""

#: ../../../creating_packages/getting_started.rst:281
msgid ""
"Or you can have a very widely used option in many packages and set its value "
"all at once with patterns, like:"
msgstr ""

#: ../../../creating_packages/getting_started.rst:283
msgid "$ conan install . -o *:shared=True"
msgstr ""

#: ../../../creating_packages/getting_started.rst:287
msgid ""
"Any doubts? Please check out our :ref:`FAQ section <faq>` or |write_us|."
msgstr ""

#: ../../../creating_packages/getting_started.rst:289
msgid "<a href=\"mailto:info@conan.io\" target=\"_blank\">write us</a>"
msgstr ""
