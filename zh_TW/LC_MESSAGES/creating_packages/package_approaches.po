# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2018, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:21+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../creating_packages/package_approaches.rst:2
msgid "Packaging Approaches"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:4
msgid ""
"Package recipes have three methods for controlling the package's binary "
"compatibility and for implementing different packaging approaches: :ref:"
"`method_package_id`, :ref:`method_build_id` and :ref:`method_package_info`."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:7
msgid ""
"These methods let package creators select the method most suitable for each "
"library."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:10
msgid "1 config (1 build) -> 1 package"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:12
msgid ""
"A typical approach is to have one configuration for each package containing "
"the artifacts. Using this approach, for example, the debug pre-compiled "
"libraries will be in a different package than the release pre-compiled "
"libraries."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:16
msgid ""
"So if there is a package recipe that builds a “hello” library, there will be "
"one package containing the release version of the \"hello.lib\" library and "
"a different package containing a debug version of that library (in the "
"figure denoted as \"hello_d.lib\", to make it clear, it is not necessary to "
"use different names)."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:26
msgid ""
"Using this approach, the ``package_info()`` method, allows you to set the "
"appropriate values for consumers, letting them know about the package "
"library names, necessary definitions and compile flags."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:29
msgid ""
"class HelloConan(ConanFile):\n"
"\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"\n"
"    def package_info(self):\n"
"        self.cpp_info.libs = [\"mylib\"]"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:38
msgid ""
"It is very important to note that it is declaring the ``build_type`` as a "
"setting. This means that a different package will be generated for each "
"different value of such setting."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:41
msgid ""
"The values declared by the packages (the *include*, *lib* and *bin* "
"subfolders are already defined by default, so they define the include and "
"library path to the package) are translated to variables of the respective "
"build system by the used generators. That is, running the ``cmake`` "
"generator will translate the above definition in the *conanbuildinfo.cmake* "
"to something like:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:46
msgid ""
"set(CONAN_LIBS_MYPKG mylib)\n"
"# ...\n"
"set(CONAN_LIBS mylib ${CONAN_LIBS})"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:52
msgid ""
"Those variables, will be used in the ``conan_basic_setup()`` macro to "
"actually set the relevant cmake variables."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:55
msgid ""
"If the developer wants to switch configuration of the dependencies, he will "
"usually switch with:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:57
msgid ""
"$ conan install -s build_type=Release ...\n"
"# when need to debug\n"
"$ conan install -s build_type=Debug ..."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:63
msgid ""
"These switches will be fast, since all the dependencies are already cached "
"locally."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:65
msgid ""
"This process offers a number of advantages: - It is quite easy to implement "
"and maintain. - The packages are of minimal size, so disk space and "
"transfers are faster, and builds from sources are also kept to the necessary "
"minimum. - The decoupling of configurations might help with isolating issues "
"related to mixing different types of artifacts, and also protecting valuable "
"information from deploy and distribution mistakes. For example, debug "
"artifacts might contain symbols or source code, which could help or directly "
"provide means for reverse engineering. So distributing debug artifacts by "
"mistake could be a very risky issue."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:75
msgid "Read more about this in :ref:`method_package_info`."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:78
msgid "N configs -> 1 package"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:80
msgid ""
"You may want to package both debug and release artifacts in the same "
"package, so it can be consumed from IDEs like Visual Studio. This will "
"change the debug/release configuration from the IDE, without having to "
"specify it in the command line. This type of package can contain different "
"artifacts for different configurations, and can be used for example to "
"include both the release and debug version of the \"hello\" library, in the "
"same package."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:93
msgid ""
"A complete working example of the following code can be found in a github "
"repo. You should be able to run:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:None
msgid ""
"$ git clone https://github.com/memsharded/hello_multi_config\n"
"$ cd hello_multi_config\n"
"$ conan create . user/channel -s build_type=Release\n"
"$ conan create . user/channel -s build_type=Debug --build=missing"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:103
msgid ""
"Creating a multi-configuration Debug/Release package is simple, see the "
"following example using CMake."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:106
msgid ""
"The first step will be to remove ``build_type`` from the settings. It will "
"not be an input setting, the generated package will always be the same, "
"containing both Debug and Release artifacts. The Visual Studio runtime is "
"different for debug and release (``MDd`` or ``MD``) and is set using the "
"default runtime (MD/MDd). If this meets your needs, we recommend removing "
"the ``runtime`` subsetting in the ``configure()`` method:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:112
msgid ""
"class Pkg(ConanFile):\n"
"    # build_type has been ommitted. It is not an input setting.\n"
"    settings = \"os\", \"compiler\", \"arch\"\n"
"\n"
"    def configure(self):\n"
"        # it is also necessary to remove the VS runtime\n"
"        if self.settings.compiler == \"Visual Studio\":\n"
"            del self.settings.compiler.runtime\n"
"\n"
"    def build(self):\n"
"        cmake = CMake(self)\n"
"        if cmake.is_multi_configuration:\n"
"            cmmd = 'cmake \"%s\" %s' % (self.source_folder, cmake."
"command_line)\n"
"            self.run(cmmd)\n"
"            self.run(\"cmake --build . --config Debug\")\n"
"            self.run(\"cmake --build . --config Release\")\n"
"        else:\n"
"            for config in (\"Debug\", \"Release\"):\n"
"                self.output.info(\"Building %s\" % config)\n"
"                self.run('cmake \"%s\" %s -DCMAKE_BUILD_TYPE=%s'\n"
"                        % (self.source_folder, cmake.command_line, config))\n"
"                self.run(\"cmake --build .\")\n"
"                shutil.rmtree(\"CMakeFiles\")\n"
"                os.remove(\"CMakeCache.txt\")"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:139
msgid ""
"In this case, we assume that the binaries will be differentiated with a "
"suffix in the Cmake syntax:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:142
msgid "set_target_properties(mylibrary PROPERTIES DEBUG_POSTFIX _d)"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:146
msgid "Such a package can define its information for consumers as:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:148
msgid ""
"def package_info(self):\n"
"    self.cpp_info.release.libs = [\"mylibrary\"]\n"
"    self.cpp_info.debug.libs = [\"mylibrary_d\"]"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:154
msgid "This will translate to the cmake variables:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:156
msgid ""
"set(CONAN_LIBS_MYPKG_DEBUG mylibrary_d)\n"
"set(CONAN_LIBS_MYPKG_RELEASE mylibrary)\n"
"# ...\n"
"set(CONAN_LIBS_DEBUG mylibrary_d ${CONAN_LIBS_DEBUG})\n"
"set(CONAN_LIBS_RELEASE mylibrary ${CONAN_LIBS_RELEASE})"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:164
msgid ""
"And these variables will be correctly applied to each configuration by "
"``conan_basic_setup()`` helper."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:167
msgid ""
"In this case you can still use the general and not config-specific "
"variables. For example, the include directory when set by default to "
"*include* remains the same for both debug and release. Those general "
"variables will be applied to all configurations."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:173
msgid ""
"The above code assumes that the package will always use the default Visual "
"Studio runtime (MD/MDd). To keep the package configurable for supporting "
"static(MT)/dynamic(MD) linking with the VS runtime library, do the following:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:177
msgid ""
"Keep the ``compiler.runtime`` setting, i.e. do not implement the "
"``configure()`` method removing it."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:178
msgid ""
"Don't let the CMake helper define the ``CONAN_LINK_RUNTIME`` env-var to "
"define the runtime, because defining it by the consumer will cause it to be "
"incorrectly applied to both the Debug and Release artifacts. This can be "
"done with a ``cmake.command_line.replace(\"CONAN_LINK_RUNTIME\", "
"\"CONAN_LINK_RUNTIME_MULTI\")`` to define a new variable."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:182
msgid ""
"Write a separate ``package_id()`` methods for MD/MDd and for MT/MTd defining "
"the packages to be built."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:183
msgid ""
"In *CMakeLists.txt*, use the ``CONAN_LINK_RUNTIME_MULTI`` variable to "
"correctly setup up the runtime for debug and release flags."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:186
msgid ""
"All these steps are already coded in the repo https://github.com/memsharded/"
"hello_multi_config and commented out as **\"Alternative 2\"**"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:189
msgid ""
"Also, you can use any custom configuration as they are not restricted. For "
"example, if your package is a multi-library package, you could try doing "
"something like:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:192
msgid ""
"def package_info(self):\n"
"    self.cpp_info.regex.libs = [\"myregexlib1\", \"myregexlib2\"]\n"
"    self.cpp_info.filesystem.libs = [\"myfilesystemlib\"]"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:198
msgid ""
"These specific config variables will not be automatically applied, but you "
"can directly use them in your consumer CMake build script."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:203
msgid ""
"The automatic conversion of multi-config variables to generators is "
"currently only implemented in the ``cmake`` and ``txt`` generators. If you "
"want to have support for them in another build system, please open a GitHub "
"issue."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:208
msgid "N configs (1 build) -> N packages"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:210
msgid ""
"It’s possible that an existing build script is simultaneously building "
"binaries for different configurations, like debug/release, or different "
"architectures (32/64bits), or library types (shared/static). If such a build "
"script is used in the previous “Single configuration packages” approach, it "
"will definitely work without problems. However, we’ll be wasting precious "
"build time, as we’ll be re-building the rebuilding project for each package, "
"then extracting the relevant artifacts for the relevant configuration, while "
"ignoring the others."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:217
msgid ""
"It is more efficient to build the logic, whereby the same build can be "
"reused to create different packages:"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:225
msgid ""
"This can be done by defining a ``build_id()`` method in the package recipe "
"that will specify the logic."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:228
msgid ""
"settings = \"os\", \"compiler\", \"arch\", \"build_type\"\n"
"\n"
"def build_id(self):\n"
"    self.info_build.settings.build_type = \"Any\"\n"
"\n"
"def package(self):\n"
"    if self.settings.build_type == \"Debug\":\n"
"        #package debug artifacts\n"
"    else:\n"
"        # package release"
msgstr ""

#: ../../../creating_packages/package_approaches.rst:241
msgid ""
"Note that the ``build_id()`` method uses the ``self.info_build`` object to "
"alter the build hash. If the method doesn't change it, the hash will match "
"the package folder one. By setting ``build_type=\"Any\"``, we are forcing "
"that for both the Debug and Release values of ``build_type``, the hash will "
"be the same (the particular string is mostly irrelevant, as long as it is "
"the same for both configurations). Note that the build hash ``sha3`` will be "
"different of both ``sha1`` and ``sha2`` package identifiers."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:248
msgid ""
"This does not imply that there will be strictly one build folder. There will "
"be a build folder for every configuration (architecture, compiler version, "
"etc). So if we just have Debug/Release build types, and we’re producing N "
"packages for N different configurations, we’ll have N/2 build folders, "
"saving half of the build time."
msgstr ""

#: ../../../creating_packages/package_approaches.rst:253
msgid "Read more about this in :ref:`method_build_id`."
msgstr ""
