# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2020, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.34\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:16+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../devtools/running_packages.rst:4
msgid "Running and deploying packages"
msgstr ""

#: ../../../devtools/running_packages.rst:6
msgid ""
"Executables and applications including shared libraries can also be "
"distributed, deployed and run with Conan. This might have some advantages "
"compared to deploying with other systems:"
msgstr ""

#: ../../../devtools/running_packages.rst:9
msgid ""
"A unified development and distribution tool, for all systems and platforms."
msgstr ""

#: ../../../devtools/running_packages.rst:10
msgid ""
"Manage any number of different deployment configurations in the same way you "
"manage them for development."
msgstr ""

#: ../../../devtools/running_packages.rst:11
msgid ""
"Use a Conan server remote to store all your applications and runtimes for "
"all Operating Systems, platforms and targets."
msgstr ""

#: ../../../devtools/running_packages.rst:13
msgid "There are different approaches:"
msgstr ""

#: ../../../devtools/running_packages.rst:16
msgid "Using virtual environments"
msgstr ""

#: ../../../devtools/running_packages.rst:18
msgid ""
"We can create a package that contains an executable, for example from the "
"default package template created by :command:`conan new`:"
msgstr ""

#: ../../../devtools/running_packages.rst:20
msgid "$ conan new hello/0.1"
msgstr ""

#: ../../../devtools/running_packages.rst:24
msgid ""
"The source code used contains an executable called ``greet``, but it is not "
"packaged by default. Let's modify the recipe ``package()`` method to also "
"package the executable:"
msgstr ""

#: ../../../devtools/running_packages.rst:27
msgid ""
"def package(self):\n"
"    self.copy(\"*greet*\", src=\"bin\", dst=\"bin\", keep_path=False)"
msgstr ""

#: ../../../devtools/running_packages.rst:32
msgid ""
"Now we create the package as usual, but if we try to run the executable it "
"won't be found:"
msgstr ""

#: ../../../devtools/running_packages.rst:34
msgid ""
"$ conan create . user/testing\n"
"...\n"
"hello/0.1@user/testing package(): Copied 1 '.h' files: hello.h\n"
"hello/0.1@user/testing package(): Copied 1 '.exe' files: greet.exe\n"
"hello/0.1@user/testing package(): Copied 1 '.lib' files: hello.lib\n"
"\n"
"$ greet\n"
"> ... not found..."
msgstr ""

#: ../../../devtools/running_packages.rst:45
msgid ""
"By default, Conan does not modify the environment, it will just create the "
"package in the local cache, and that is not in the system PATH, so the "
"``greet`` executable is not found."
msgstr ""

#: ../../../devtools/running_packages.rst:48
msgid ""
"The ``virtualrunenv`` generator generates files that add the package's "
"default binary locations to the necessary paths:"
msgstr ""

#: ../../../devtools/running_packages.rst:50
msgid ""
"It adds the dependencies ``lib`` subfolder to the ``DYLD_LIBRARY_PATH`` "
"environment variable (for OSX shared libraries)"
msgstr ""

#: ../../../devtools/running_packages.rst:51
msgid ""
"It adds the dependencies ``lib`` subfolder to the ``LD_LIBRARY_PATH`` "
"environment variable (for Linux shared libraries)"
msgstr ""

#: ../../../devtools/running_packages.rst:52
msgid ""
"It adds the dependencies ``bin`` subfolder to the ``PATH`` environment "
"variable (for executables)"
msgstr ""

#: ../../../devtools/running_packages.rst:54
msgid "So if we install the package, specifying such ``virtualrunenv`` like:"
msgstr ""

#: ../../../devtools/running_packages.rst:56
msgid "$ conan install hello/0.1@user/testing -g virtualrunenv"
msgstr ""

#: ../../../devtools/running_packages.rst:60
msgid ""
"This will generate a few files that can be called to activate and deactivate "
"the required environment variables"
msgstr ""

#: ../../../devtools/running_packages.rst:62
msgid ""
"$ activate_run.sh # $ source activate_run.sh in Unix/Linux\n"
"$ greet\n"
"> Hello World Release!\n"
"$ deactivate_run.sh # $ source deactivate_run.sh in Unix/Linux"
msgstr ""

#: ../../../devtools/running_packages.rst:70
msgid "Imports"
msgstr ""

#: ../../../devtools/running_packages.rst:72
msgid ""
"It is possible to define a custom conanfile (either *.txt* or *.py*), with "
"an ``imports()`` section, that can retrieve from local cache the desired "
"files. This approach requires a user conanfile."
msgstr ""

#: ../../../devtools/running_packages.rst:75
msgid ""
"For more details see the example below :ref:`runtime packages<repackage>`."
msgstr ""

#: ../../../devtools/running_packages.rst:78
msgid "Deployable packages"
msgstr ""

#: ../../../devtools/running_packages.rst:80
msgid ""
"With the ``deploy()`` method, a package can specify which files and "
"artifacts to copy to user space or to other locations in the system. Let's "
"modify the example recipe adding the ``deploy()`` method:"
msgstr ""

#: ../../../devtools/running_packages.rst:83
msgid ""
"def deploy(self):\n"
"    self.copy(\"*\", dst=\"bin\", src=\"bin\")"
msgstr ""

#: ../../../devtools/running_packages.rst:88
msgid "And run :command:`conan create`"
msgstr ""

#: ../../../devtools/running_packages.rst:90
msgid "$ conan create . user/testing"
msgstr ""

#: ../../../devtools/running_packages.rst:94
msgid ""
"With that method in our package recipe, it will copy the executable when "
"installed directly:"
msgstr ""

#: ../../../devtools/running_packages.rst:96
msgid ""
"$ conan install hello/0.1@user/testing\n"
"...\n"
"> hello/0.1@user/testing deploy(): Copied 1 '.exe' files: greet.exe\n"
"$ bin\\greet.exe\n"
"> Hello World Release!"
msgstr ""

#: ../../../devtools/running_packages.rst:104
msgid ""
"The deploy will create a *deploy_manifest.txt* file with the files that have "
"been deployed."
msgstr ""

#: ../../../devtools/running_packages.rst:106
msgid ""
"Sometimes it is useful to adjust the package ID of the deployable package in "
"order to deploy it regardless of the compiler it was compiled with:"
msgstr ""

#: ../../../devtools/running_packages.rst:109
msgid ""
"def package_id(self):\n"
"    del self.info.settings.compiler"
msgstr ""

#: ../../../devtools/running_packages.rst:116
msgid "Read more about the :ref:`deploy() <method_deploy>` method."
msgstr ""

#: ../../../devtools/running_packages.rst:121
msgid "Using the `deploy` generator"
msgstr ""

#: ../../../devtools/running_packages.rst:123
msgid ""
"The :ref:`deploy generator <deploy_generator>` is used to have all the "
"dependencies of an application copied into a single place. Then all the "
"files can be repackaged into the distribution format of choice."
msgstr ""

#: ../../../devtools/running_packages.rst:126
msgid ""
"For instance, if the application depends on boost, we may not know that it "
"also requires many other 3rt-party libraries, such as `zlib <https://zlib."
"net/>`_, `bzip2 <https://sourceware.org/bzip2/>`_, `lzma <https://tukaani."
"org/xz/>`_, `zstd <https://facebook.github.io/zstd/>`_, `iconv <https://www."
"gnu.org/software/libiconv/>`_, etc."
msgstr ""

#: ../../../devtools/running_packages.rst:134
msgid "$ conan install . -g deploy"
msgstr ""

#: ../../../devtools/running_packages.rst:138
msgid ""
"This helps to collect all the dependencies into a single place, moving them "
"out of the Conan cache."
msgstr ""

#: ../../../devtools/running_packages.rst:143
msgid "Using the `json` generator"
msgstr ""

#: ../../../devtools/running_packages.rst:145
msgid ""
"A more advanced approach is to use the :ref:`json generator "
"<json_generator>`. This generator works in a similar fashion as the `deploy` "
"one, although it doesn't copy the files to a directory. Instead, it "
"generates a JSON file with all the information about the dependencies "
"including the location of the files in the Conan cache."
msgstr ""

#: ../../../devtools/running_packages.rst:149
msgid "$ conan install . -g json"
msgstr ""

#: ../../../devtools/running_packages.rst:153
msgid ""
"The *conanbuildinfo.json* file produced, is fully machine-readable and could "
"be used by scripts to prepare the files and recreate the appropriate format "
"for distribution. The following code shows how to read the library and "
"binary directories from the *conanbuildinfo.json*:"
msgstr ""

#: ../../../devtools/running_packages.rst:156
msgid ""
"import os\n"
"import json\n"
"\n"
"data = json.load(open(\"conanbuildinfo.json\"))\n"
"\n"
"dep_lib_dirs = dict()\n"
"dep_bin_dirs = dict()\n"
"\n"
"for dep in data[\"dependencies\"]:\n"
"    root = dep[\"rootpath\"]\n"
"    lib_paths = dep[\"lib_paths\"]\n"
"    bin_paths = dep[\"bin_paths\"]\n"
"\n"
"    for lib_path in lib_paths:\n"
"        if os.listdir(lib_path):\n"
"            lib_dir = os.path.relpath(lib_path, root)\n"
"            dep_lib_dirs[lib_path] = lib_dir\n"
"    for bin_path in bin_paths:\n"
"        if os.listdir(bin_path):\n"
"            bin_dir = os.path.relpath(bin_path, root)\n"
"            dep_bin_dirs[bin_path] = bin_dir"
msgstr ""

#: ../../../devtools/running_packages.rst:180
msgid ""
"While with the `deploy` generator, all the files were copied into a folder. "
"The advantage with the `json` one is that you have fine-grained control over "
"the files and those can be directly copied to the desired layout."
msgstr ""

#: ../../../devtools/running_packages.rst:183
msgid ""
"In that sense, the script above could be easily modified to apply some sort "
"of filtering (e.g. to copy only shared libraries, and omit any static "
"libraries or auxiliary files such as pkg-config .pc files)."
msgstr ""

#: ../../../devtools/running_packages.rst:186
msgid ""
"Additionally, you could also write a simple startup script for your "
"application with the extracted information like this:"
msgstr ""

#: ../../../devtools/running_packages.rst:188
msgid ""
"executable = \"MyApp\"  # just an example\n"
"varname = \"$APPDIR\"\n"
"\n"
"def _format_dirs(dirs):\n"
"    return \":\".join([\"%s/%s\" % (varname, d) for d in dirs])\n"
"\n"
"path = _format_dirs(set(dep_bin_dirs.values()))\n"
"ld_library_path = _format_dirs(set(dep_lib_dirs.values()))\n"
"exe = varname + \"/\" + executable\n"
"\n"
"content = \"\"\"#!/usr/bin/env bash\n"
"set -ex\n"
"export PATH=$PATH:{path}\n"
"export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:{ld_library_path}\n"
"pushd $(dirname {exe})\n"
"$(basename {exe})\n"
"popd\n"
"\"\"\".format(path=path,\n"
"       ld_library_path=ld_library_path,\n"
"       exe=exe)"
msgstr ""

#: ../../../devtools/running_packages.rst:212
msgid "Running from packages"
msgstr ""

#: ../../../devtools/running_packages.rst:214
msgid ""
"If a dependency has an executable that we want to run in the conanfile, it "
"can be done directly in code using the ``run_environment=True`` argument. It "
"internally uses a ``RunEnvironment()`` helper. For example, if we want to "
"execute the :command:`greet` app while building the ``consumer`` package:"
msgstr ""

#: ../../../devtools/running_packages.rst:218
msgid ""
"from conans import ConanFile, tools, RunEnvironment\n"
"\n"
"class ConsumerConan(ConanFile):\n"
"    name = \"consumer\"\n"
"    version = \"0.1\"\n"
"    settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"    requires = \"hello/0.1@user/testing\"\n"
"\n"
"    def build(self):\n"
"        self.run(\"greet\", run_environment=True)"
msgstr ""

#: ../../../devtools/running_packages.rst:231
msgid ""
"Now run :command:`conan install` and :command:`conan build` for this "
"consumer recipe:"
msgstr ""

#: ../../../devtools/running_packages.rst:233
msgid ""
"$ conan install . && conan build .\n"
"...\n"
"Project: Running build()\n"
"Hello World Release!"
msgstr ""

#: ../../../devtools/running_packages.rst:240
msgid ""
"Instead of using the environment, it is also possible to explicitly access "
"the path of the dependencies:"
msgstr ""

#: ../../../devtools/running_packages.rst:242
msgid ""
"def build(self):\n"
"    path = os.path.join(self.deps_cpp_info[\"hello\"].rootpath, \"bin\")\n"
"    self.run([\"%s/greet\" % path])"
msgstr ""

#: ../../../devtools/running_packages.rst:248
msgid ""
"Note that this might not be enough if shared libraries exist. Using the "
"``run_environment=True`` helper above is a more complete solution."
msgstr ""

#: ../../../devtools/running_packages.rst:251
msgid ""
"This example also demonstrates using a list to specify the command to run. "
"This bypasses the system shell and works correctly even when ``path`` "
"contains special characters like whitespace or quotes that would otherwise "
"be interpreted by the shell. However, it also means that substituting "
"environment variables or the output from other commands which are normally "
"done by the shell won't work when using this method. Specify your command "
"using a plain string as shown above when you require this functionality."
msgstr ""

#: ../../../devtools/running_packages.rst:257
msgid ""
"Finally, there is another approach: the package containing the executable "
"can add its *bin* folder directly to the ``PATH``. In this case the "
"**Hello** package conanfile would contain:"
msgstr ""

#: ../../../devtools/running_packages.rst:260
msgid ""
"def package_info(self):\n"
"    self.cpp_info.libs = [\"hello\"]\n"
"    self.env_info.PATH = os.path.join(self.package_folder, \"bin\")"
msgstr ""

#: ../../../devtools/running_packages.rst:266
msgid ""
"We may also define ``DYLD_LIBRARY_PATH`` and ``LD_LIBRARY_PATH`` if they are "
"required for the executable."
msgstr ""

#: ../../../devtools/running_packages.rst:268
msgid ""
"The consumer package is simple, as the ``PATH`` environment variable "
"contains the ``greet`` executable:"
msgstr ""

#: ../../../devtools/running_packages.rst:270
msgid ""
"def build(self):\n"
"    self.run(\"greet\")"
msgstr ""

#: ../../../devtools/running_packages.rst:276
msgid ""
"Read the :ref:`next section <create_installer_packages>` for a more "
"comprenhensive explanation about using packaged executables in your recipe "
"methods."
msgstr ""

#: ../../../devtools/running_packages.rst:283
msgid "Runtime packages and re-packaging"
msgstr ""

#: ../../../devtools/running_packages.rst:285
msgid ""
"It is possible to create packages that contain only runtime binaries, "
"getting rid of all build-time dependencies. If we want to create a package "
"from the above \"hello\" one, but only containing the executable (remember "
"that the above package also contains a library, and the headers), we could "
"do:"
msgstr ""

#: ../../../devtools/running_packages.rst:289
msgid ""
"from conans import ConanFile\n"
"\n"
"class HellorunConan(ConanFile):\n"
"    name = \"hello_run\"\n"
"    version = \"0.1\"\n"
"    build_requires = \"hello/0.1@user/testing\"\n"
"    keep_imports = True\n"
"\n"
"    def imports(self):\n"
"        self.copy(\"greet*\", src=\"bin\", dst=\"bin\")\n"
"\n"
"    def package(self):\n"
"        self.copy(\"*\")"
msgstr ""

#: ../../../devtools/running_packages.rst:305
msgid "This recipe has the following characteristics:"
msgstr ""

#: ../../../devtools/running_packages.rst:307
msgid ""
"It includes the ``hello/0.1@user/testing`` package as ``build_requires``. "
"That means that it will be used to build this `hello_run` package, but once "
"the `hello_run` package is built, it will not be necessary to retrieve it."
msgstr ""

#: ../../../devtools/running_packages.rst:310
msgid ""
"It is using ``imports()`` to copy from the dependencies, in this case, the "
"executable"
msgstr ""

#: ../../../devtools/running_packages.rst:311
msgid ""
"It is using the ``keep_imports`` attribute to define that imported artifacts "
"during the ``build()`` step (which is not define, then using the default "
"empty one), are kept and not removed after build"
msgstr ""

#: ../../../devtools/running_packages.rst:313
msgid ""
"The ``package()`` method packages the imported artifacts that will be "
"created in the build folder."
msgstr ""

#: ../../../devtools/running_packages.rst:315
msgid "To create and upload this package to a remote:"
msgstr ""

#: ../../../devtools/running_packages.rst:317
msgid ""
"$ conan create . user/testing\n"
"$ conan upload hello_run* --all -r=my-remote"
msgstr ""

#: ../../../devtools/running_packages.rst:322
msgid ""
"Installing and running this package can be done using any of the methods "
"presented above. For example:"
msgstr ""

#: ../../../devtools/running_packages.rst:324
msgid ""
"$ conan install hello_run/0.1@user/testing -g virtualrunenv\n"
"# You can specify the remote with -r=my-remote\n"
"# It will not install hello/0.1@...\n"
"$ activate_run.sh # $ source activate_run.sh in Unix/Linux\n"
"$ greet\n"
"> Hello World Release!\n"
"$ deactivate_run.sh # $ source deactivate_run.sh in Unix/Linux"
msgstr ""

#: ../../../devtools/running_packages.rst:337
msgid "Deployment challenges"
msgstr ""

#: ../../../devtools/running_packages.rst:339
msgid ""
"When deploying a C/C++ application there are some specific challenges that "
"have to be solved when distributing your application. Here you will find the "
"most usual ones and some recommendations to overcome them."
msgstr ""

#: ../../../devtools/running_packages.rst:343
msgid "The C standard library"
msgstr ""

#: ../../../devtools/running_packages.rst:345
msgid ""
"A common challenge for all the applications no matter if they are written in "
"pure C or in C++ is the dependency on C standard library. The most wide-"
"spread variant of this library is GNU C library or just `glibc <https://www."
"gnu.org/software/libc/>`_."
msgstr ""

#: ../../../devtools/running_packages.rst:348
msgid "Glibc is not a just C standard library, as it provides:"
msgstr ""

#: ../../../devtools/running_packages.rst:350
msgid ""
"C functions (like ``malloc()``, ``sin()``, etc.) for various language "
"standards, including C99."
msgstr ""

#: ../../../devtools/running_packages.rst:351
msgid "POSIX functions (like posix threads in the ``pthread`` library)."
msgstr ""

#: ../../../devtools/running_packages.rst:352
msgid "BSD functions (like BSD sockets)."
msgstr ""

#: ../../../devtools/running_packages.rst:353
msgid "Wrappers for OS-specific APIs (like Linux system calls)"
msgstr ""

#: ../../../devtools/running_packages.rst:355
msgid ""
"Even if your application doesn't use directly any of these functions, they "
"are often used by other libraries, so, in practice, it's almost always in "
"actual use."
msgstr ""

#: ../../../devtools/running_packages.rst:358
msgid ""
"There are other implementations of the C standard library that present the "
"same challenge, such as `newlib <https://sourceware.org/newlib/>`_ or `musl "
"<https://www.musl-libc.org>`_, used for embedded development."
msgstr ""

#: ../../../devtools/running_packages.rst:361
msgid ""
"To illustrate the problem, a simple hello-world application compiled in a "
"modern Ubuntu distribution will give the following error when it is run in a "
"Centos 6 one:"
msgstr ""

#: ../../../devtools/running_packages.rst:364
msgid ""
"$ /hello\n"
"/hello: /lib64/libc.so.6: version 'GLIBC_2.14' not found (required by /hello)"
msgstr ""

#: ../../../devtools/running_packages.rst:369
msgid ""
"This is because the versions of the ``glibc`` are different between those "
"Linux distributions."
msgstr ""

#: ../../../devtools/running_packages.rst:371
msgid "There are several solutions to this problem:"
msgstr ""

#: ../../../devtools/running_packages.rst:373
msgid ""
"`LibcWrapGenerator <https://github.com/AppImage/AppImageKit/tree/stable/v1.0/"
"LibcWrapGenerator>`_"
msgstr ""

#: ../../../devtools/running_packages.rst:374
msgid ""
"`glibc_version_header <https://github.com/wheybags/glibc_version_header>`_"
msgstr ""

#: ../../../devtools/running_packages.rst:375
msgid "`bingcc <https://github.com/sulix/bingcc>`_"
msgstr ""

#: ../../../devtools/running_packages.rst:377
msgid ""
"Some people also advice to use static of glibc, but it's strongly "
"discouraged. One of the reasons is that newer glibc  might be using syscalls "
"that are not available in the previous versions, so it will randomly fail in "
"runtime, which is much harder to debug (the situation about system calls is "
"described below)."
msgstr ""

#: ../../../devtools/running_packages.rst:381
msgid ""
"It's possible to model either ``glibc`` version or Linux distribution name "
"in Conan by defining custom Conan sub-setting in the *settings.yml* file "
"(check out sections :ref:`add_new_settings` and :ref:"
"`add_new_sub_settings`). The process will be similar to:"
msgstr ""

#: ../../../devtools/running_packages.rst:384
msgid ""
"Define new sub-setting, for instance `os.distro`, as explained in the "
"section :ref:`add_new_sub_settings`."
msgstr ""

#: ../../../devtools/running_packages.rst:385
msgid ""
"Define compatibility mode, as explained by sections :ref:`method_package_id` "
"and :ref:`method_build_id` (e.g. you may consider some ``Ubuntu`` and "
"``Debian`` packages to be compatible with each other)"
msgstr ""

#: ../../../devtools/running_packages.rst:386
msgid "Generate different packages for each distribution."
msgstr ""

#: ../../../devtools/running_packages.rst:387
msgid "Generate deployable artifacts for each distribution."
msgstr ""

#: ../../../devtools/running_packages.rst:390
msgid "C++ standard library"
msgstr ""

#: ../../../devtools/running_packages.rst:392
msgid ""
"Usually, the default C++ standard library is `libstdc++ <https://gcc.gnu.org/"
"onlinedocs/libstdc++/>`_, but `libc++ <https://libcxx.llvm.org>`_ and "
"`stlport <http://www.stlport.org>`_ are other well-known implementations."
msgstr ""

#: ../../../devtools/running_packages.rst:395
msgid ""
"Similarly to the standard C library `glibc`, running the application linked "
"with libstdc++ in the older system may result in an error:"
msgstr ""

#: ../../../devtools/running_packages.rst:397
msgid ""
"$ /hello\n"
"/hello: /usr/lib64/libstdc++.so.6: version 'GLIBCXX_3.4.21' not found "
"(required by /hello)\n"
"/hello: /usr/lib64/libstdc++.so.6: version 'GLIBCXX_3.4.26' not found "
"(required by /hello)"
msgstr ""

#: ../../../devtools/running_packages.rst:403
msgid ""
"Fortunately, this is much easier to address by just adding ``-static-libstdc+"
"+`` compiler flag. Unlike C runtime, C++ runtime can be linked statically "
"safely, because it doesn't use system calls directly, but instead relies on "
"``libc`` to provide required wrappers."
msgstr ""

#: ../../../devtools/running_packages.rst:407
msgid "Compiler runtime"
msgstr ""

#: ../../../devtools/running_packages.rst:409
msgid ""
"Besides C and C++ runtime libraries, the compiler runtime libraries are also "
"used by applications. Those libraries usually provide lower-level functions, "
"such as compiler intrinsics or support for exception handling. Functions "
"from these runtime libraries are rarely referenced directly in code and are "
"mostly implicitly inserted by the compiler itself."
msgstr ""

#: ../../../devtools/running_packages.rst:413
msgid ""
"$ ldd ./a.out\n"
"libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f6626aee000)"
msgstr ""

#: ../../../devtools/running_packages.rst:418
msgid ""
"you can avoid this kind of dependency by the using of the ``-static-libgcc`` "
"compiler flag. However, it's not always sane thing to do, as there are "
"certain situations when applications should use shared runtime. The most "
"common is when the application wishes to throw and catch exceptions across "
"different shared libraries. Check out the `GCC manual <https://gcc.gnu.org/"
"onlinedocs/gcc/Link-Options.html>`_ for the detailed information."
msgstr ""

#: ../../../devtools/running_packages.rst:424
msgid "System API (system calls)"
msgstr ""

#: ../../../devtools/running_packages.rst:426
msgid ""
"New system calls are often introduced with new releases of `Linux kernel "
"<https://www.kernel.org>`_. If the application, or 3rd-party libraries, want "
"to take advantage of these new features, they sometimes directly refer to "
"such system calls (instead of using wrappers provided by ``glibc``)."
msgstr ""

#: ../../../devtools/running_packages.rst:430
msgid ""
"As a result, if the application was compiled on a machine with a newer "
"kernel and build system used to auto-detect available system calls, it may "
"fail to execute properly on machines with older kernels."
msgstr ""

#: ../../../devtools/running_packages.rst:433
msgid ""
"The solution is to either use a build machine with lowest supported kernel, "
"or model supported operation system (just like in case of ``glibc``). Check "
"out sections :ref:`add_new_settings` and :ref:`add_new_sub_settings` to get "
"a piece of information on how to model distribution in conan settings."
msgstr ""
