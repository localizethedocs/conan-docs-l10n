# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2019, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 1.16\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-15 10:04+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../extending/python_requires.rst:4
msgid "Python requires: reusing code [EXPERIMENTAL]"
msgstr ""

#: ../../../extending/python_requires.rst:8
msgid ""
"This is an **experimental** feature subject to breaking changes in future "
"releases."
msgstr ""

#: ../../../extending/python_requires.rst:10
msgid ""
"The ``python_requires()`` feature is a very convenient way to share files "
"and code between different recipes. A *Python Requires* is just like any "
"other recipe, it is the way it is required from the consumer what makes the "
"difference."
msgstr ""

#: ../../../extending/python_requires.rst:14
msgid ""
"The *Python Requires* recipe file, besides exporting its own required "
"sources, can export files to be used by the consumer recipes and also python "
"code in the recipe file itself."
msgstr ""

#: ../../../extending/python_requires.rst:17
msgid ""
"Let's have a look at an example showing all its capabilities (you can find "
"all the sources in `Conan examples repository`_):"
msgstr ""

#: ../../../extending/python_requires.rst:20
msgid "Python requires recipe:"
msgstr ""

#: ../../../extending/python_requires.rst:22
msgid ""
"import os\n"
"import shutil\n"
"from conans import ConanFile, CMake, tools\n"
"from scm_utils import get_version\n"
"\n"
"\n"
"class PythonRequires(ConanFile):\n"
"    name = \"pyreq\"\n"
"    version = \"version\"\n"
"\n"
"    exports = \"scm_utils.py\"\n"
"    exports_sources = \"CMakeLists.txt\"\n"
"\n"
"\n"
"def get_conanfile():\n"
"\n"
"    class BaseConanFile(ConanFile):\n"
"\n"
"        settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n"
"        options = {\"shared\": [True, False]}\n"
"        default_options = {\"shared\": False}\n"
"        generators = \"cmake\"\n"
"        exports_sources = \"src/*\"\n"
"\n"
"        def source(self):\n"
"            # Copy the CMakeLists.txt file exported with the python "
"requires\n"
"            pyreq = self.python_requires[\"pyreq\"]\n"
"            shutil.copy(src=os.path.join(pyreq.exports_sources_folder, "
"\"CMakeLists.txt\"),\n"
"                        dst=self.source_folder)\n"
"\n"
"            # Rename the project to match the consumer name\n"
"            tools.replace_in_file(os.path.join(self.source_folder, "
"\"CMakeLists.txt\"),\n"
"                                  \"add_library(mylibrary ${sources})\",\n"
"                                  \"add_library({} ${{sources}})\"."
"format(self.name))\n"
"\n"
"\n"
"        def build(self):\n"
"            cmake = CMake(self)\n"
"            cmake.configure()\n"
"            cmake.build()\n"
"\n"
"        def package(self):\n"
"            self.copy(\"*.h\", dst=\"include\", src=\"src\")\n"
"            self.copy(\"*.lib\", dst=\"lib\", keep_path=False)\n"
"            self.copy(\"*.dll\", dst=\"bin\", keep_path=False)\n"
"            self.copy(\"*.dylib*\", dst=\"lib\", keep_path=False)\n"
"            self.copy(\"*.so\", dst=\"lib\", keep_path=False)\n"
"            self.copy(\"*.a\", dst=\"lib\", keep_path=False)\n"
"\n"
"        def package_info(self):\n"
"            self.cpp_info.libs = [self.name]\n"
"\n"
"    return BaseConanFile"
msgstr ""

#: ../../../extending/python_requires.rst:78
msgid "Consumer recipe"
msgstr ""

#: ../../../extending/python_requires.rst:80
msgid ""
"from conans import ConanFile, python_requires\n"
"\n"
"\n"
"base = python_requires(\"pyreq/version@user/channel\")\n"
"\n"
"class ConsumerConan(base.get_conanfile()):\n"
"    name = \"consumer\"\n"
"    version = base.get_version()\n"
"\n"
"    # Everything else is inherited"
msgstr ""

#: ../../../extending/python_requires.rst:94
msgid ""
"We must make available for other to use the recipe with the *Python "
"Requires*, this recipe won't have any associated binaries, only the sources "
"will be needed, so we only need to execute the export and upload commands:"
msgstr ""

#: ../../../extending/python_requires.rst:98
msgid ""
"$ conan export . pyreq/version@user/channel\n"
"$ conan upload pyreq/version@user/channel -r=myremote"
msgstr ""

#: ../../../extending/python_requires.rst:103
msgid ""
"Now any consumer will be able to reuse the business logic and files "
"available in the recipe, let's have a look at the most common use cases."
msgstr ""

#: ../../../extending/python_requires.rst:108
msgid "Import a python requires"
msgstr ""

#: ../../../extending/python_requires.rst:110
msgid ""
"To import a recipe as a *Python requires* it is needed to call the "
"``python_requires()`` function with the reference as the only parameter:"
msgstr ""

#: ../../../extending/python_requires.rst:113
msgid "base = python_requires(\"pyreq/version@user/channel\")"
msgstr ""

#: ../../../extending/python_requires.rst:117
msgid ""
"All the code available in the *conanfile.py* file of the imported recipe "
"will be available in the consumer through the ``base`` variable."
msgstr ""

#: ../../../extending/python_requires.rst:122
msgid ""
"There are **several important considerations** regarding "
"``python_requires()``:"
msgstr ""

#: ../../../extending/python_requires.rst:124
msgid ""
"They are required at every step of the conan commands. If you are creating a "
"package that ``python_requires(\"MyBase/...\")``, the ``MyBase`` package "
"should be already available in the local cache or to be downloaded from the "
"remotes. Otherwise, conan will raise a \"missing package\" error."
msgstr ""

#: ../../../extending/python_requires.rst:127
msgid ""
"They do not affect the package binary ID (hash). Depending on different "
"version, or different channel of such ``python_requires()`` do not change "
"the package IDs as the normal dependencies do."
msgstr ""

#: ../../../extending/python_requires.rst:129
msgid ""
"They are imported only once. The python code that is reused is imported only "
"once, the first time it is required. Subsequent requirements of that conan "
"recipe will reuse the previously imported module. Global initialization at "
"parsing time and global state are discouraged."
msgstr ""

#: ../../../extending/python_requires.rst:132
msgid ""
"They are transitive. One recipe using ``python_requires()`` can be also "
"consumed with a ``python_requires()`` from another package recipe."
msgstr ""

#: ../../../extending/python_requires.rst:134
msgid ""
"They are not automatically updated with the ``--update`` argument from "
"remotes."
msgstr ""

#: ../../../extending/python_requires.rst:135
msgid ""
"Different packages can require different versions in their "
"``python_requires()``. They are private to each recipe, so they do not "
"conflict with each other, but it is the responsibility of the user to keep "
"consistency."
msgstr ""

#: ../../../extending/python_requires.rst:137
msgid ""
"They are not overridden from downstream consumers. Again, as they are "
"private, they are not affected by other packages, even consumers"
msgstr ""

#: ../../../extending/python_requires.rst:142
msgid "Reuse python sources"
msgstr ""

#: ../../../extending/python_requires.rst:144
msgid ""
"In the example proposed we are using two functions through the ``base`` "
"variable: ``base.get_conanfile()`` and ``base.get_version()``. The first one "
"is defined directly in the *conanfile.py* file, but the second one is in a "
"different source file that was exported together with the ``pyreq/"
"version@user/channel`` recipe using the ``exports`` attribute."
msgstr ""

#: ../../../extending/python_requires.rst:150
msgid ""
"This works without any Conan magic, it is just plain Python and you can even "
"return a class from a function and inherit from it. That's just what we are "
"proposing in this example: all the business logic in contained in the "
"*Python Requires* so every recipe will reuse it automatically. The consumer "
"only needs to define the ``name`` and ``version``:"
msgstr ""

#: ../../../extending/python_requires.rst:155
msgid ""
"from conans import ConanFile, python_requires\n"
"\n"
"\n"
"base = python_requires(\"pyreq/version@user/channel\")\n"
"\n"
"class ConsumerConan(base.get_conanfile()):\n"
"    name = \"consumer\"\n"
"    version = \"version\"\n"
"\n"
"    # Everything else is inherited"
msgstr ""

#: ../../../extending/python_requires.rst:168
msgid ""
"while all the functional code is defined in the *python requires* recipe "
"file:"
msgstr ""

#: ../../../extending/python_requires.rst:170
msgid ""
"from conans import ConanFile, python_requires\n"
"\n"
"[...]\n"
"\n"
"def get_conanfile():\n"
"\n"
"    class BaseConanFile(ConanFile):\n"
"        def source(self):\n"
"            [...]\n"
"\n"
"        def build(self):\n"
"            [...]"
msgstr ""

#: ../../../extending/python_requires.rst:187
msgid "Reuse source files"
msgstr ""

#: ../../../extending/python_requires.rst:189
msgid ""
"Up to now, we have been reusing python code, but we can also package files "
"within the *python requires* recipe and consume them afterward, that's what "
"we are doing with a *CMakeList.txt* file, it will allow us to share the "
"CMake code and ensure that all the libraries using the same *python "
"requires* will have the same build script. These are the relevant code "
"snippets from the example files:"
msgstr ""

#: ../../../extending/python_requires.rst:195
msgid ""
"The *python requires* exports the needed sources (the file exists next to "
"this *conanfile.py*):"
msgstr ""

#: ../../../extending/python_requires.rst:197
msgid ""
"class PythonRequires(ConanFile):\n"
"    name = \"pyreq\"\n"
"    version = \"version\"\n"
"\n"
"    exports_sources = \"CMakeLists.txt\"\n"
"\n"
"    [...]"
msgstr ""

#: ../../../extending/python_requires.rst:208
msgid ""
"The file will be exported together with the recipe ``pyreq/version@user/"
"channel`` during the call to ``conan export . pyreq/version@user/channel`` "
"as it is expected for any Conan package."
msgstr ""

#: ../../../extending/python_requires.rst:212
msgid ""
"The consumer recipe will copy the file from the *python requires* folder, we "
"need to make this copy ourselves, there is nothing run automatically during "
"the ``python_requires()`` call:"
msgstr ""

#: ../../../extending/python_requires.rst:216
msgid ""
"class BaseConanFile(ConanFile):\n"
"    [...]\n"
"\n"
"    def source(self):\n"
"        # Copy the CMakeLists.txt file exported with the python requires\n"
"        pyreq = self.python_requires[\"pyreq\"]\n"
"        shutil.copy(src=os.path.join(pyreq.exports_sources_folder, "
"\"CMakeLists.txt\"),\n"
"                    dst=self.source_folder)\n"
"\n"
"        # Rename the project to match the consumer name\n"
"        tools.replace_in_file(os.path.join(self.source_folder, \"CMakeLists."
"txt\"),\n"
"                              \"add_library(mylibrary ${sources})\",\n"
"                              \"add_library({} ${{sources}})\".format(self."
"name))"
msgstr ""

#: ../../../extending/python_requires.rst:233
msgid ""
"As you can see, in the inherited ``source()`` method, we are copying the "
"*CMakeLists.txt* file from the *exports_sources* folder of the python "
"requires (take a look at the :ref:`python_requires "
"attribute<python_requires_attribute>`), and modifying a line to name the "
"library with the current recipe name."
msgstr ""

#: ../../../extending/python_requires.rst:238
msgid ""
"In the example, our ``ConsumerConan`` class will also inherit the "
"``build()``, ``package()`` and ``package_info()`` method, turning the actual "
"*conanfile.py* of the library into a mere declaration of the name and "
"version."
msgstr ""

#: ../../../extending/python_requires.rst:243
msgid "You can find the full example in the `Conan examples repository`_."
msgstr ""
