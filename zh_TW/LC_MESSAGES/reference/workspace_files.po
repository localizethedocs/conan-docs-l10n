# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2024, JFrog
# This file is distributed under the same license as the conan package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: conan 2.23\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-16 08:34+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../reference/workspace_files.rst:4
msgid "Workspace files"
msgstr "工作空間檔案"

#: ../../../common/incubating_warning.inc:3
msgid ""
"This feature is part of the new incubating features. This means that it is "
"under development, and looking for user testing and feedback. For more info "
"see :ref:`Incubating section<incubating>`."
msgstr ""

#: ../../../reference/workspace_files.rst:8
msgid ""
"Workspaces are defined by the ``conanws.yml`` and/or ``conanws.py`` files "
"that will define the \"root\" workspace folder."
msgstr ""

#: ../../../reference/workspace_files.rst:11
#: ../../../reference/workspace_files.rst:16
#: ../../../reference/workspace_files.rst:28
msgid "conanws.yml"
msgstr ""

#: ../../../reference/workspace_files.rst:13
msgid ""
"The most basic implementation of a workspace is a ``conanws.yml`` file. It "
"defines the workspace's ``packages`` (editable packages). For instance, a "
"workspace ``conanws.yml`` defining 2 ``packages`` could be:"
msgstr ""

#: ../../../reference/workspace_files.rst:16
msgid ""
"packages:\n"
"   - path: dep1\n"
"     ref: dep1/0.1\n"
"   - path: dep2\n"
"     ref: dep2/0.1"
msgstr ""

#: ../../../reference/workspace_files.rst:26
msgid ""
"Moreover, it could not have the ``ref`` field, and let Conan read the *name/"
"version* from the respective *path/conanfile.py*:"
msgstr ""

#: ../../../reference/workspace_files.rst:28
msgid ""
"packages:\n"
"   - path: dep1\n"
"   - path: dep2"
msgstr ""

#: ../../../reference/workspace_files.rst:37
#: ../../../reference/workspace_files.rst:43
#: ../../../reference/workspace_files.rst:66
#: ../../../reference/workspace_files.rst:91
#: ../../../reference/workspace_files.rst:166
msgid "conanws.py"
msgstr ""

#: ../../../reference/workspace_files.rst:39
msgid ""
"A ``conanws.yml`` can be extended with a way more powerful ``conanws.py`` "
"that follows the same relationship as a ``ConanFile`` does with its "
"``conandata.yml``. If we want to dynamically define the ``packages``, for "
"example based on the existence of some ``name.txt`` and ``version.txt`` "
"files in folders, the packages could be defined in ``conanws.py`` as:"
msgstr ""

#: ../../../reference/workspace_files.rst:43
msgid ""
"import os\n"
"from conan import Workspace\n"
"\n"
"class MyWorkspace(Workspace):\n"
"\n"
"   def packages(self):\n"
"      result = []\n"
"      for f in os.listdir(self.folder):\n"
"         if os.path.isdir(os.path.join(self.folder, f)):\n"
"            with open(os.path.join(self.folder, f, \"name.txt\")) as fname:\n"
"               name = fname.read().strip()\n"
"            with open(os.path.join(self.folder, f, \"version.txt\")) as "
"fversion:\n"
"               version = fversion.read().strip()\n"
"            result.append({\"path\": f, \"ref\": f\"{name}/{version}\"})\n"
"      return result"
msgstr ""

#: ../../../reference/workspace_files.rst:63
msgid ""
"It is also possible to re-use the ``conanfile.py`` logic in ``set_name()`` "
"and ``set_version()`` methods, using the ``Workspace.load_conanfile()`` "
"helper:"
msgstr ""

#: ../../../reference/workspace_files.rst:66
msgid ""
"import os\n"
"from conan import Workspace\n"
"\n"
"class MyWorkspace(Workspace):\n"
"   def packages(self):\n"
"      result = []\n"
"      for f in os.listdir(self.folder):\n"
"         if os.path.isdir(os.path.join(self.folder, f)):\n"
"            conanfile = self.load_conanfile(f)\n"
"            result.append({\"path\": f, \"ref\": f\"{conanfile.name}/"
"{conanfile.version}\"})\n"
"      return result"
msgstr ""

#: ../../../reference/workspace_files.rst:83
msgid "conanws.py super-build ``ConanFile``"
msgstr "conanws.py super-build ``ConanFile``"

#: ../../../reference/workspace_files.rst:85
msgid ""
"The ``conanws.py`` file can contain the definition of a ``ConanFile`` that "
"represents the super-build. When the workspace dependency graph is computed, "
"all packages in the workspace are collapsed into a single node in the "
"dependency graph, and that node will have dependencies to the other packages "
"external to the workspace, that is, installed in the Conan cache."
msgstr ""

#: ../../../reference/workspace_files.rst:89
msgid ""
"The ``ConanFile`` that represents the workspace super-build project is "
"defined as:"
msgstr ""

#: ../../../reference/workspace_files.rst:91
msgid ""
"from conan import ConanFile, Workspace\n"
"from conan.tools.cmake import cmake_layout\n"
"\n"
"class MyWs(ConanFile):\n"
"   settings = \"os\", \"compiler\", \"arch\", \"build_type\"\n"
"   generators = \"CMakeToolchain\", \"CMakeDeps\"\n"
"\n"
"   def layout(self):\n"
"      cmake_layout(self)\n"
"\n"
"\n"
"class Ws(Workspace):\n"
"   def root_conanfile(self):\n"
"      return MyWs"
msgstr ""

#: ../../../reference/workspace_files.rst:110
msgid ""
"It defines that our super-build project will be a CMake project that uses "
"the ``CMakeToolchain`` and ``CMakeDeps`` generators to integrate and find "
"the external package dependencies. It is not necessary that the "
"``ConanFile`` defines ``requires`` at all, they will be computed by "
"aggregating the requires of all packages in the workspace."
msgstr ""

#: ../../../reference/workspace_files.rst:117
msgid ""
"The ``ConanFile`` inside ``conanws.py`` is a special conanfile, used "
"exclusively for the workspace super-build definition of layout and "
"generators. It shouldn't have any kind of requirements, not regular "
"``requires``, ``tool_requires`` or ``test_requires``. It obtains its "
"dependencies collecting and aggregating the workspace packages requirements. "
"It shouldn't have ``build()`` or ``package()`` methods either."
msgstr ""

#: ../../../reference/workspace_files.rst:124
msgid "conanws.py super-build workspace packages"
msgstr "conanws.py super-build workspace packages"

#: ../../../reference/workspace_files.rst:126
msgid ""
"With the ``workspace_packages`` attribute, the ``conanws.py`` super-build "
"``ConanFile`` can have access to the workspace packages, to be able to reuse "
"their functionality. For example, if we wanted to collect the behavior of "
"workspace packages toolchain definitions we could do the following. Let's "
"imagine that we have a workspace with 2 packages, ``pkga/1.2.3`` and "
"``pkgb/2.3.4``"
msgstr ""

#: ../../../reference/workspace_files.rst:131
msgid "pkga/conanfile.py"
msgstr "pkga/conanfile.py"

#: ../../../reference/workspace_files.rst:131
msgid ""
"from conan import ConanFile\n"
"\n"
"class PkgA(ConanFile):\n"
"   name = \"pkga\"\n"
"   version = \"1.2.3\"\n"
"\n"
"   def configure_toolchain(self, tc):\n"
"      tc.preprocessor_definitions[\"PKGA_SOME_DEFINITION\"] = self.version\n"
"\n"
"   def generate(self):\n"
"      tc = CMakeToolchain(self)\n"
"      self.configure_toolchain(tc)\n"
"      tc.generate()"
msgstr ""
"from conan import ConanFile\n"
"\n"
"class PkgA(ConanFile):\n"
"   name = \"pkga\"\n"
"   version = \"1.2.3\"\n"
"\n"
"   def configure_toolchain(self, tc):\n"
"      tc.preprocessor_definitions[\"PKGA_SOME_DEFINITION\"] = self.version\n"
"\n"
"   def generate(self):\n"
"      tc = CMakeToolchain(self)\n"
"      self.configure_toolchain(tc)\n"
"      tc.generate()"

#: ../../../reference/workspace_files.rst:149
msgid "pkgb/conanfile.py"
msgstr "pkgb/conanfile.py"

#: ../../../reference/workspace_files.rst:149
msgid ""
"from conan import ConanFile\n"
"class PkgB(ConanFile):\n"
"   name = \"pkgb\"\n"
"   version = \"2.3.4\"\n"
"\n"
"   def configure_toolchain(self, tc):\n"
"      tc.preprocessor_definitions[\"SOME_PKGB_DEFINE\"] = self.version\n"
"\n"
"   def generate(self):\n"
"      tc = CMakeToolchain(self)\n"
"      self.configure_toolchain(tc)\n"
"      tc.generate()"
msgstr ""
"from conan import ConanFile\n"
"class PkgB(ConanFile):\n"
"   name = \"pkgb\"\n"
"   version = \"2.3.4\"\n"
"\n"
"   def configure_toolchain(self, tc):\n"
"      tc.preprocessor_definitions[\"SOME_PKGB_DEFINE\"] = self.version\n"
"\n"
"   def generate(self):\n"
"      tc = CMakeToolchain(self)\n"
"      self.configure_toolchain(tc)\n"
"      tc.generate()"

#: ../../../reference/workspace_files.rst:166
msgid ""
"from conan import ConanFile\n"
"from conan import Workspace\n"
"from conan.tools.cmake import CMakeToolchain\n"
"\n"
"class MyWs(ConanFile):\n"
"   settings = \"arch\", \"build_type\"\n"
"   def generate(self):\n"
"      tc = CMakeToolchain(self)\n"
"      for ref, dep in self.workspace_packages.items():\n"
"         dep.configure_toolchain(tc)\n"
"      tc.generate()\n"
"\n"
"class Ws(Workspace):\n"
"   def root_conanfile(self):\n"
"      return MyWs"
msgstr ""
"from conan import ConanFile\n"
"from conan import Workspace\n"
"from conan.tools.cmake import CMakeToolchain\n"
"\n"
"class MyWs(ConanFile):\n"
"   settings = \"arch\", \"build_type\"\n"
"   def generate(self):\n"
"      tc = CMakeToolchain(self)\n"
"      for ref, dep in self.workspace_packages.items():\n"
"         dep.configure_toolchain(tc)\n"
"      tc.generate()\n"
"\n"
"class Ws(Workspace):\n"
"   def root_conanfile(self):\n"
"      return MyWs"

#: ../../../reference/workspace_files.rst:186
msgid ""
"Then, the ``workspace_packages.items()`` iteration will be able to call "
"every package in the workspace ``configure_toolchain()`` and collect all "
"their behavior in the current super-build ``CMakeToolchain``. The resulting "
"toolchain will contain the definitions for ``SOME_PKGB_DEFINE=2.3.4`` and "
"``PKGA_SOME_DEFINITION=1.2.3``."
msgstr ""

#: ../../../reference/workspace_files.rst:192
msgid "**Important**"
msgstr ""

#: ../../../reference/workspace_files.rst:194
msgid ""
"The access of ``workspace_packages`` to the workspace packages "
"``ConanFiles`` must be **read-only** and **pure**. It cannot modify the "
"workspace ``pkga`` and ``pkgb`` packages data, and it cannot have any side "
"effect. For example it is forbidden to call any method such as ``.build()`` "
"or even the ``.generate()`` method. If there is logic to be reused, it is "
"the responsibility of the developer to define some convention, such as the "
"``configure_toolchain()`` method that if called from the ``conanws.py`` will "
"not modify at all (pure) the ``pkga`` or ``pkgb`` data."
msgstr ""

#: ../../../reference/workspace_files.rst:202
msgid "conanws.py super-build options"
msgstr ""

#: ../../../reference/workspace_files.rst:204
msgid ""
"A particular case of the above ``workspace_packages`` access could be "
"reading the individual workspace packages options. A ``conanws.py`` used for "
"a super-build workspaces file can manage options in two different ways:"
msgstr ""

#: ../../../reference/workspace_files.rst:207
msgid ""
"It can define its own ``options`` with the normal ``conanfile.py`` syntax, "
"so the generated ``conan_toolchain.cmake`` for the super-project uses those "
"inputs."
msgstr ""

#: ../../../reference/workspace_files.rst:208
msgid ""
"It can collect the options of the workspace's packages with the "
"``workspace_packages`` and process them in any user-custom way."
msgstr ""

#: ../../../reference/workspace_files.rst:211
msgid "**super-project options**"
msgstr ""

#: ../../../reference/workspace_files.rst:213
msgid ""
"A ``conanws.py`` must define the options for the super-build in the "
"``ConanFile`` class, and use those options in the ``generate()`` method, as "
"it usually happens with ``conanfile.py`` files, something like:"
msgstr ""

#: ../../../reference/workspace_files.rst:215
msgid ""
"from conan import ConanFile, Workspace\n"
"\n"
"class MyWs(ConanFile):\n"
"   settings = \"arch\", \"build_type\"\n"
"   options = {\"myoption\": [1, 2, 3]}\n"
"\n"
"   def generate(self):\n"
"      self.output.info(f\"Generating with my option {self.options."
"myoption}!!!!\")\n"
"\n"
"class Ws(Workspace):\n"
"   def root_conanfile(self):\n"
"      return MyWs"
msgstr ""

#: ../../../reference/workspace_files.rst:230
msgid ""
"Then, options can be provided with the usual syntax, via profiles or command "
"line:"
msgstr ""

#: ../../../reference/workspace_files.rst:232
msgid ""
"$ conan workspace super-install -of=build -o \"*:myoption=1\"\n"
"> conanws.py base project Conanfile: Generating with my option 1!!!!"
msgstr ""

#: ../../../reference/workspace_files.rst:237
msgid ""
"Note there can be overlap with the ``options`` defined in the workspace "
"packages, as for super-projects those options are simply ignored, and only "
"the options of the super-project are taken into account to generate the "
"``conan_toolchain.cmake``. For example, the ``conanws.py`` can define a "
"``shared`` option if it is desired that the ``conan_toolchain.cmake`` will "
"correctly define ``BUILD_SHARED_LIBS`` or not when defining something like "
"``-o \"*:shared=True\"``, as the workspace packages having the ``shared`` "
"option information is discarded when the workspace packages are collapsed in "
"the dependency graph to model the super-project."
msgstr ""

#: ../../../reference/workspace_files.rst:240
msgid "**packages options**"
msgstr "**軟體包選項**"

#: ../../../reference/workspace_files.rst:242
msgid ""
"The second alternative is to collect the ``options`` of the workspace "
"packages that have been collapsed. Recall that in the final dependency "
"graph, the workspace packages are no longer represented, as they are no "
"longer individual packages but part as the current super-build. The way to "
"access their options information is via the ``workspace_packages``, and that "
"information can be used in the ``generate()`` method to do any desired "
"action at the super-build project level."
msgstr ""

#: ../../../reference/workspace_files.rst:245
msgid ""
"So let's say that a workspace containing a ``dep/0.1`` package that contains "
"the standard ``shared`` options defines the following super-build "
"``ConanFile``:"
msgstr ""

#: ../../../reference/workspace_files.rst:247
msgid ""
"from conan import ConanFile, Workspace\n"
"\n"
"class MyWs(ConanFile):\n"
"   def generate(self):\n"
"      for pkg, dep in self.workspace_packages.items():\n"
"         for k, v in dep.options.items():\n"
"            self.output.info(f\"Generating with opt {pkg}:{k}={v}!!!!\")\n"
"\n"
"class Ws(Workspace):\n"
"   def root_conanfile(self):\n"
"      return MyWs"
msgstr ""

#: ../../../reference/workspace_files.rst:262
msgid ""
"Then, when the workspace package options are defined, the workspace "
"``ConanFile`` can collect them."
msgstr ""

#: ../../../reference/workspace_files.rst:264
msgid ""
"$ conan workspace super-install -of=build -o \"*:shared=True\"\n"
"> conanws.py base project Conanfile: Generating with opt dep/0.1:"
"shared=True!!!!!!!!"
msgstr ""
"$ conan workspace super-install -of=build -o \"*:shared=True\"\n"
"> conanws.py base project Conanfile: Generating with opt dep/0.1:"
"shared=True!!!!!!!!"

#: ../../../reference/workspace_files.rst:272
msgid ""
"In practice it is the responsibility of the workspace creator to define what "
"to do with the options, either by defining its own options or collecting the "
"workspace packages ones. Note it is not possible to automatically map "
"workspace packages options to the super-project, as options are defined per-"
"package. Two different packages could have different ``shared=True`` and "
"``shared=False`` values. Also, very often, the effect on the generated "
"toolchain files is custom and implemented in each package ``generate()`` "
"method. This effect is programmatic (not declarative), it would be extremely "
"challenging to aggregate all these effects in a single toolchain."
msgstr ""

#: ../../../reference/workspace_files.rst:277
msgid "Read :ref:`the Workspace tutorial<tutorial_workspaces>` section."
msgstr ""
